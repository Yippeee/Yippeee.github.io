<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="8zDf90JHBHd6ITvkfvZxA9i6vZEXOMl1oDP3Fp7YXtA">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="学习路上">
<meta name="keywords" content="前端 js">
<meta property="og:type" content="website">
<meta property="og:title" content="依破缘">
<meta property="og:url" content="http://yippee.ink/index.html">
<meta property="og:site_name" content="依破缘">
<meta property="og:description" content="学习路上">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="依破缘">
<meta name="twitter:description" content="学习路上">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yippee.ink/">




  <title> Hexo, NexT - 依破缘学习路上 - 前端小工</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?be0a702b8fbcbc2433ff711ca69c62ed";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">依破缘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">前端小工</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/08/08/常见的排序-查找算法-JavaScript实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/常见的排序-查找算法-JavaScript实现/" itemprop="url">常见的排序, 查找算法(JavaScript实现)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T16:14:05+08:00">
                2019-08-08
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-08-27T09:10:13+08:00" content="2019-08-27">
                2019-08-27
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文拟用js实现常见的几大排序算法, 以及各种标准版本的优化. 以及总结一下查找算法</p>
</blockquote>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><blockquote>
<p>都默认选择升序(小 -&gt; 大)的排序方法</p>
</blockquote>
<p>目前我搞定的排序算法有:</p>
<ol>
<li>冒泡排序</li>
<li>插入排序</li>
<li>选择排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>堆排序</li>
<li>希尔排序(增量排序)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">arr, i, j</span>) =&gt;</span> [arr[i], arr[j]] = [arr[j], arr[i]]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序强调的是两两相邻的元素进行比较, 调整</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对冒泡排序的优化, 主要在对大部分有序的情况下, 才能体现差异, 对于乱序的数组, 都是效率很低的一种排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 1: 设置标志变量 changed</span></span><br><span class="line"><span class="comment">// 原理:  如果在一轮排序中都没有变化, 说明数组已经有序, 就可以直接退出了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length - <span class="number">1</span>,</span><br><span class="line">        sorted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; !sorted; i++) &#123;</span><br><span class="line">        sorted = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>)</span><br><span class="line">                sorted = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr: '</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法还可以再优化, 记录最后一次交换的位置, 那么后面的数组就是一定排序好了的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 1_1 标志出哪里发生了变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble_2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length - <span class="number">1</span>,</span><br><span class="line">        sorted = <span class="literal">false</span>,</span><br><span class="line">        lastPos = length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lastPos &amp;&amp; !sorted; i++) &#123;</span><br><span class="line">        sorted = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>)</span><br><span class="line">                sorted = <span class="literal">false</span></span><br><span class="line">                <span class="comment">// 记录下最后一个发生交换的位置</span></span><br><span class="line">                lastPos = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr: '</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h4><p>双向的冒泡排序, 看着就像是调酒一样, 左晃右晃的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method 2: 双向排序 (鸡尾酒排序)</span></span><br><span class="line"><span class="comment">// 原理: 先从左到右, 再从右到左, 依次轮转, 确定最大,最小,第二大,第二小,直至完成排序</span></span><br><span class="line"><span class="comment">// 优势: 能在大部分数组项已经排序好的情况下, 效率更好</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cocktailSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        left = <span class="number">0</span>,</span><br><span class="line">        right = length - <span class="number">1</span>,</span><br><span class="line">        sorted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (!sorted &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        sorted = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>)</span><br><span class="line">                sorted = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = right; j &gt; left; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j)</span><br><span class="line">                sorted = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr: '</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = temp - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[temp] &lt; arr[j]) &#123;</span><br><span class="line">                swap(arr, temp, j)</span><br><span class="line">                temp = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序是假定前序的数组是排好序的, 将后面的一个一个放入前面排好序的自己的位置.</p>
<h4 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h4><p>插入排序的优化, 可以放在在前面数组找自己的位置的时候, 这个时候其实是一个查找算法,而且前面的数组本身已经是一个拍好序的数组, 我们不使用一一遍历, 改成二分查找效率就会高一些.</p>
<blockquote>
<p>代码思路: 利用二分查找找到无序数组中第一个元素在有序数组中的位置, 将有序数组位置后面的元素全部后退一个, 再把无序数组第一个元素赋值给该位置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, item; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 修改成二分查找位置</span></span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>, flag</span><br><span class="line">        item = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            flag = ~~((left + right) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (item &lt; arr[flag]) &#123;</span><br><span class="line">                right = flag - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item &gt;= arr[flag]) &#123;</span><br><span class="line">                left = flag + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr: '</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>希尔排序也是插入的一种优化, 但是过于特殊就专门作为了一种方法.</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> smallest = i, j</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[smallest]) &#123;</span><br><span class="line">                smallest = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, smallest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序也是认为前序的数组是排序好的, 但是是从后面没有排序好的数组中选取最大(小)的直接放入末尾(开头)</p>
<p>选择排序的优化, 在于从后面没有拍好序的数组取值的时候, 可以一次循环同时取出最大和最小, 这样时间复杂度就减少了一半.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> smallest = i, largest = i</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[smallest]) &#123;</span><br><span class="line">                smallest = j</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[j] &gt; arr[largest]) &#123;</span><br><span class="line">                largest = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, smallest)</span><br><span class="line">        swap(arr, length - i - <span class="number">1</span>, largest)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log('arr: ', arr);</span></span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>堆排序也是一种选择排序的优化</p>
</blockquote>
<blockquote>
<p>和插入排序的对比,对于代码来说,其实就是插入排序的是在不断的遍历前序的数组, 而选择排序是在遍历后面的数组</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        right = [],</span><br><span class="line">        left = [];</span><br><span class="line">    <span class="keyword">let</span> pivot = (length / <span class="number">2</span>) &gt;&gt;&gt; <span class="number">0</span>,</span><br><span class="line">        pivotVal = arr.splice(pivot, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivotVal) &#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...quickSort(left), pivotVal, ...quickSort(right)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序的思想是分治法(divide), 选取一个基准, 大的放右边, 小的放左边. 直到只有一个数组的才直接返回</p>
<p>快排的优化思路: //TODO:</p>
<ol>
<li>基准的选择 (固定取首/尾, 随机取, 三数取中)</li>
<li>改递归为循环</li>
<li>分割数组至一定小的数组之后使用插入排序 </li>
</ol>
<h4 id="改递归为循环"><a href="#改递归为循环" class="headerlink" title="改递归为循环"></a>改递归为循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list = [[<span class="number">0</span>, arr.length - <span class="number">1</span>]] <span class="comment">// 指针左右都包括</span></span><br><span class="line">    <span class="keyword">while</span> (list.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> [pivot, end] = list.shift()<span class="comment">// 基准就先取第一个吧</span></span><br><span class="line">        <span class="keyword">if</span> (pivot &gt;= end) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">let</span> pivotVal = arr[pivot]</span><br><span class="line">        <span class="keyword">let</span> moveStep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = pivot + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivotVal) &#123;</span><br><span class="line">                arr.splice(moveStep + pivot, <span class="number">0</span>, arr[i])</span><br><span class="line">                arr.splice(i + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">                moveStep++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push([pivot, pivot + moveStep - <span class="number">1</span>], [pivot + moveStep + <span class="number">1</span>, end])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arrFINAL: '</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以认为快排是冒泡排序的一种改良(当然冒泡还有很多种改良的思路)</p>
</blockquote>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        mid = (length / <span class="number">2</span>) &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, mid),</span><br><span class="line">        right = arr.slice(mid)</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">while</span> (left.length || right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((left[<span class="number">0</span>] || <span class="literal">Infinity</span>) &lt; (right[<span class="number">0</span>] || <span class="literal">Infinity</span>)) &#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说快排是用了分治法的策略, 但是最完全的使用分支的策略的还是归并排序.<br>将数组不断分割(分 divide), 直到长度为1, 然后采用归并(merge)的思路, 不断的把分出来的数组合并(治 conquer).</p>
<h4 id="非递归-循环-归并排序"><a href="#非递归-循环-归并排序" class="headerlink" title="非递归(循环)归并排序"></a>非递归(循环)归并排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length</span><br><span class="line">    <span class="keyword">let</span> step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (step &lt; length) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i += step * <span class="number">2</span>) &#123;</span><br><span class="line">            arr.splice(i, step * <span class="number">2</span>, ...merge(arr.slice(i, step + i), arr.slice(step + i, step + i + step)))</span><br><span class="line">        &#125;</span><br><span class="line">        step *= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr: '</span>, arr);</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 1. minHeapify arr</span></span><br><span class="line">    minHeapify(arr, <span class="number">0</span>, length)</span><br><span class="line">    <span class="comment">// 2. sort</span></span><br><span class="line">    <span class="keyword">let</span> firstParentIndex = <span class="built_in">Math</span>.floor(length / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = firstParentIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        minHeapify(arr, i, length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minHeapify</span>(<span class="params">arr, index, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>,</span><br><span class="line">        right = left + <span class="number">1</span>,</span><br><span class="line">        minChild = left</span><br><span class="line">    <span class="keyword">if</span> (left &gt; end) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (arr[right] &lt; arr[left] &amp;&amp; right &lt;= end) &#123;</span><br><span class="line">        minChild = right</span><br><span class="line">        swap(arr, index, minChild)</span><br><span class="line">        minHeapify(arr, minChild, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序是利用大(小)顶堆第一项元素一定最大(小)的特性, 同时堆中其他的元素趋于顺序, 来实现排序.</p>
<h3 id="希尔排序-增量排序"><a href="#希尔排序-增量排序" class="headerlink" title="希尔排序(增量排序)"></a>希尔排序(增量排序)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        gap = (length / <span class="number">2</span>) &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (gap) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = i</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = temp - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[temp]) &#123;</span><br><span class="line">                    swap(arr, j, temp)</span><br><span class="line">                    temp = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = (gap / <span class="number">2</span>) &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>叫希尔排序总是容易忘了原理是什么, 还不如用原理来记住. 同时希尔排序也是插入排序的一种优化</p>
</blockquote>
<p>希尔排序通过只对增量的数据进行相互比较, 然后不断缩小增量至一.</p>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/07/02/vue-组件通信/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/vue-组件通信/" itemprop="url">vue 组件通信</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-02T19:07:24+08:00">
                2019-07-02
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-07-12T14:11:20+08:00" content="2019-07-12">
                2019-07-12
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="父子组件交互"><a href="#父子组件交互" class="headerlink" title="父子组件交互"></a>父子组件交互</h1><h2 id="prop-emit"><a href="#prop-emit" class="headerlink" title="prop $emit()"></a>prop $emit()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">    prop: [val],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeVal(value) &#123;</span><br><span class="line">            this.$emit(&apos;fChange&apos;, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child @fChange=&quot;change&quot; :val=val &gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import child from &apos;./child&apos;</span><br><span class="line">// 父组件中</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;child&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            val: &apos;1&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        change(val) &#123;</span><br><span class="line">            this.val = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现的父子组件的通信,通常认为是稍微复杂一点的,数据的传递不仅仅是为了改变的,而是作为一个playload,去完成功能的.</p>
<p>使用起来有几点注意:</p>
<p>子组件用 <code>prop</code> 属性获取父组件中的数据</p>
<p>子组件注册自定义事件,并且利用 <code>$emit()</code> 触发</p>
<p>最后对数据的处理,以及事件都是在父组件发生的.</p>
<h2 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h2><p>这是语法糖实现的双向绑定, 实则在vue中是不使用双向绑定的. 数据流都是单向的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 子组件中</span><br><span class="line">export default &#123;</span><br><span class="line">    prop: [val],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeVal(value) &#123;</span><br><span class="line">            this.$emit(&apos;update:val&apos;, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child :val.sync=val &gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import child from &apos;./child&apos;</span><br><span class="line">// 父组件中</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;child&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            val: &apos;1&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出,如果同样只是需要对诗数据进行同步的话,使用.sync 修饰符,就会非常的简单.</p>
<p>其实也就是下面的语法糖而已:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :val=val @update:val=&apos;val = $event&apos; &gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote>
<p>在看 elem 源码的时候发现了这种使用方法,后面发现这种使用方式很多了. 但是一直有一点很困惑,就是都是实现数据’双向’流动,之前的很多方法都使用的很便捷了,不知道为什么要使用这种. 后面,我搜索考察了一番,觉得应该是为了可以在实现自定义的组件的时候,保持vue本身的这么一个v-model的写法.</p>
</blockquote>
<p>使用v-modal 的作用也是保持子组件数据和父组件保持一样.</p>
<p>使用的🌰:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 子组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @change=&apos;changeVal&apos; &gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    prop: [value],</span><br><span class="line">    modal: &#123;</span><br><span class="line">        prop: &apos;value&apos;, // 这里这个名词可以自己随意定义的,定义了之后就需要在prop中申明</span><br><span class="line">        event: &apos;changeValEvent&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeVal(value) &#123;</span><br><span class="line">            this.$emit(&apos;changeValEvent&apos;, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 父组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;child v-modal=&apos;val&apos;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import child from &apos;./child&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;child&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            val: &apos;1&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的写法是对用组件的易用性有了很大的提升.同时这也只是个 prop $emit 的语法糖</p>
<p>相当于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child v-bind:&#123; $parent.modal.prop &#125; = &apos;val&apos; v-on:&#123; $parent.modal.event &#125; = &apos;val = arguments[0]&apos; &gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>$parent.modal</code> 是在子组件中配置的属性名称和事件名称.</p>
<h2 id="parent-children"><a href="#parent-children" class="headerlink" title="\$parent $children"></a>\$parent $children</h2><p>上面的几种方法,其实都是 prop 的不同的使用方法. 而真正的支持改变父或子组件的数据可以直接使用 <code>$parent $children</code></p>
<p>可以直接通过 <code>this.$parent[methodName]</code> <code>this.$parent[dataName] = sth</code> 来调用方法,以及改变数据</p>
<blockquote>
<p>这一点可以看出, vue不是纯粹的单向数据流.</p>
</blockquote>
<h3 id="children"><a href="#children" class="headerlink" title="$children"></a>$children</h3><p>$children 是一个数组, 直接子组件, 其中并不保存顺序, 也不是响应式的.</p>
<blockquote>
<p>在查阅资料的时候,可以发现这两个直接访问组件的方法是不被倡导的.官网的说法,是应急的用法.但是现在这句话没有了,不知道是什么意思.<a href="https://cn.vuejs.org/v2/api/#vm-children" target="_blank" rel="noopener">链接</a> 现在(2019-07-03)在官网没有看到有提到节制使用 $children</p>
</blockquote>
<p>在直接对子组件的方法调用的时候,还是直接用ref 注册,然后直接使用 ref 会更加方便和准确</p>
<h1 id="祖孙组件之间交互"><a href="#祖孙组件之间交互" class="headerlink" title="祖孙组件之间交互"></a>祖孙组件之间交互</h1><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="\$attrs $listeners"></a>\$attrs $listeners</h2><blockquote>
<p>开宗明义, $listeners是用来向上传递事件的, $attrs是用来向下传递数据的, 使用场景一般为多层组件的时候, 写在中间层直接传递.</p>
</blockquote>
<p>来一个🌰:</p>
<p>引用关系是这样的  parent -&gt; child -&gt; grandChild</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// parent</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;child :val=&apos;value&apos; @changeValEvent=&apos;changeVal&apos; &gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import child from &apos;./child&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    components:&#123;...&#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: &apos;hiha&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeVal(value) &#123;</span><br><span class="line">            console.log(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// child</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&apos;child&apos;&gt;</span><br><span class="line">        &lt;grandChild v-bind=&apos;$attrs&apos; v-on=&apos;$listeners&apos; &gt;&lt;/grandChild&gt; &lt;!-- 使用 $attrs $listeners 透传了数据和事件 --&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import grandChild from &apos;./grandChild&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    components:&#123;...&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// grandChild</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    prop: [&apos;val&apos;], // 直接在需要使用的子孙组件中引用prop</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: &apos;hiha&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeVal(value) &#123;</span><br><span class="line">            this.$emit(&apos;changeValEvent&apos;, value) // 直接emit祖宗组件的事件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出使用 <code>$attrs $listeners</code> 的情况都是多层组件中, 直接让数据和事件传递, 而不用再中间不需要使用的地方, 再写 emit 和 prop 做中转. 再复杂的组件关系中,使用这种方法可以简洁很多,</p>
<p>在使用 $attrs 的时候, 需要配合 inheritAttrs 属性一起使用</p>
<h3 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h3><p>来一段官网的解释:</p>
<blockquote>
<p>默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 vue 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。</p>
</blockquote>
<p>我的理解就是在配合 $attrs 使用的时候, 防止 v-bind 的数据显性的出现在HTML中.</p>
<p>以上面的代码为例, 如果是上面的写法,那么在HTML中会出现的这样的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-v-763db97b=&quot;&quot; class=&quot;child&quot; val=&quot;hiha&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在使用 $attrs 的组件 child 中设置 inheritAttrs: false, 就不会出现这样的情况了.</p>
<h2 id="event-bus"><a href="#event-bus" class="headerlink" title="event bus"></a>event bus</h2><p>一句话描述一下什么是event bus. 就是利用一个新的new,通过这个空的vue来监听($on)和触发($emit).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// bus.vue</span><br><span class="line">import vue from &apos;vue&apos;</span><br><span class="line">export default vue</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// a.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&apos;changeA&apos; &gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import bus from &apos;./bus&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: &apos;hiha&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeA(value) &#123;</span><br><span class="line">            bus.$emit(&apos;fromA&apos;, this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// b.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&apos;changeA&apos; &gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import bus from &apos;./bus&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            value: &apos;hiha&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">        bus.$on(&apos;fromA&apos;, (v) =&gt; &#123;</span><br><span class="line">            console.log(v)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy () &#123; // 不要忘记在组件销毁的时候同时注销事件监听</span><br><span class="line">        bus.$off(&apos;fromA&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉这种方式的数据流动过于随意,慎用.</p>
<p>这个封装的一个库,思路挺不错的. <a href="https://github.com/yangmingshan/vue-bus/blob/master/src/index.js" target="_blank" rel="noopener">vue-bus</a></p>
<h2 id="依赖注入-inject-provide"><a href="#依赖注入-inject-provide" class="headerlink" title="依赖注入 inject provide"></a>依赖注入 inject provide</h2><blockquote>
<p>在官网中,不推荐在业务代码使用这种方法,这个方法发设计初衷是为了高级组件的.所以在elem源码中倒是经常看到这种使用方法.</p>
</blockquote>
<p>其主要的作用是祖先组件向子孙组件注入一个依赖,无论层级关系有多深,主要关系还在都会生效.</p>
<p>这个没有怎么使用过.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/06/05/函数式编程基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/05/函数式编程基础/" itemprop="url">函数式编程基础</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-05T16:50:24+08:00">
                2019-06-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-06-05T16:50:38+08:00" content="2019-06-05">
                2019-06-05
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="pointfree"><a href="#pointfree" class="headerlink" title="pointfree"></a>pointfree</h2><p>pointfree means never have to say your data</p>
<p>永远不必说出你的数据.</p>
<p>栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是一个不好的栗子,因为函数中使用的数据</span></span><br><span class="line"><span class="keyword">var</span> snakeString = <span class="function"><span class="keyword">function</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word.toLowCase().replace(<span class="regexp">/\s+/</span>,<span class="string">'_'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree 的函数</span></span><br><span class="line"><span class="keyword">var</span> snakeStr = compose(replace(<span class="regexp">/\s+/</span>, <span class="string">'_'</span>), toLowCase)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数组合和函数柯里化"><a href="#函数组合和函数柯里化" class="headerlink" title="函数组合和函数柯里化"></a>函数组合和函数柯里化</h2><blockquote>
<p>如果说上面的pointfree模式,可以让我们体验到函数式编程的话,那么这两个基本的方法,就是一切函数式编程的基本了.</p>
</blockquote>
<p>柯里化的<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1" target="_blank" rel="noopener">简介</a><br>组合的<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html" target="_blank" rel="noopener">简介</a></p>
<p>该怎么用,这是一个经验之谈,现在我想做的是如何去实现这么两个功能函数</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>大致理一下柯里化需要达到的效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add1 = curry(add)(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> result1 = add1(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">//6</span></span><br><span class="line"><span class="keyword">let</span> result2 = add1(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>其实仔细看下,curry函数就是暂时的缓存函数的参数,直到参数个数达到函数的参数长度时候才去执行.</p>
<p>看到函数本身缓存,那么使用闭包当然是不二的选择了.</p>
<p>按上面的思路完成的第一版:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args = [].slice.call(arguments, <span class="number">1</span></span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args1 = args.concat([].slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">        <span class="keyword">if</span>(args1.length &gt;= fn.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args1)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curry(fn, args1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的写法其实很混乱,虽然是按着思路走的,但是很多地方不够精简,第二版:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn(...args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> temp(...args, ...args2)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一种箭头函数的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> temp = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.length &gt;= fn.length ? fn(...args) : <span class="function">(<span class="params">...args2</span>) =&gt;</span> temp(...args, ...args2)</span><br></pre></td></tr></table></figure></p>
<p>但是会出现错误,在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function"><span class="keyword">function</span> (<span class="params">separator, str</span>) </span>&#123; <span class="keyword">return</span> str.split(separator) &#125;)</span><br><span class="line"><span class="keyword">const</span> map = curry(<span class="function"><span class="keyword">function</span> (<span class="params">fn, arr</span>) </span>&#123; <span class="keyword">return</span> arr.map(fn) &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = split(<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'s: '</span>, s);</span><br><span class="line"><span class="keyword">let</span> qw = s(<span class="string">'0023-12-sd1221f'</span>)</span><br></pre></td></tr></table></figure></p>
<p>的情况下会报错,FIXME:缘由应该是箭头函数作用域导致的</p>
<h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>函数组合相对起来就简单多了,但是需要记住一个规则,运算的优先级是从右到左的.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = fns.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = fns[start].apply(<span class="keyword">this</span>, args)</span><br><span class="line">        <span class="keyword">while</span> (start--) &#123; result = fns[start].call(<span class="keyword">this</span>, result) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/05/16/尝试实现一个深拷贝/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/尝试实现一个深拷贝/" itemprop="url">尝试实现一个深拷贝</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T09:17:41+08:00">
                2019-05-16
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:27+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文旨在尝试实现一个功能考虑完备的深拷贝</p>
</blockquote>
<p>什么是深拷贝，什么是浅拷贝，这里就不做多余的赘述了。</p>
<h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><p>需要实现的深拷贝，需要考虑到的问题有：</p>
<ol>
<li><p>复杂的数据类型</p>
</li>
<li><p>性能上的优化，防止内存堆栈溢出</p>
</li>
<li><p>重复引用问题的解决</p>
</li>
</ol>
<p>上面就是实现的函数需要考虑到的功能，开始实现</p>
<h2 id="复杂的数据类型"><a href="#复杂的数据类型" class="headerlink" title="复杂的数据类型"></a>复杂的数据类型</h2><p>深拷贝本身需要解决的问题，就是对引用类型的内容拷贝，而不是指针拷贝。原有类型的保持当然是毕不可少的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getType = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x._prop_.constructor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source, type = Object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> type()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">		<span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">			<span class="keyword">const</span> element = source[key];</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">'object'</span>) &#123; <span class="comment">// 这个地方考虑的不够严谨    </span></span><br><span class="line">				result[key] = deepClone(element, getType(element));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result[key] = element;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过返回复杂类型的构造函数，来保证类型的一样。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>上面的解决办法使用了递归，如果在层级很深很深的情况下，是会造成爆栈的。</p>
<p>经过测试，上面的方法，大概在10000层的时候，就会产生爆栈的错误了。</p>
<p>为了解决这个问题，我们用while 来代替递归。（这个，在我之前递归的文章中有提及过）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * @param  &#123;&#125; prev</span></span><br><span class="line"><span class="comment">	 * @param  &#123;&#125; content</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">constructor</span>(prev, content) &#123;</span><br><span class="line">		<span class="keyword">this</span>.prev = prev;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneBreadth</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 广度优先遍历 使用队列  shift()出队列  push()进队列</span></span><br><span class="line">	<span class="keyword">let</span> result = <span class="keyword">new</span> source.__proto__.constructor();</span><br><span class="line">	<span class="keyword">let</span> queues = [<span class="keyword">new</span> Node(result, source)]; <span class="comment">// 队列</span></span><br><span class="line">	<span class="keyword">while</span> (queues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> item = queues.shift();</span><br><span class="line">		<span class="keyword">const</span> &#123; prev, content &#125; = item;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> content) &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'keyBreadth: '</span>, key);</span><br><span class="line">			<span class="keyword">if</span> (content.hasOwnProperty(key)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">typeof</span> content[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">					prev[key] = <span class="keyword">new</span> content[key].__proto__.constructor();</span><br><span class="line">					queues.push(<span class="keyword">new</span> Node(prev[key], content[key]));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					prev[key] = content[key];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法其实在时间上没有很大的进步，但是在处理多层级的时候不会导致堆栈溢出，但是还是会很慢。</p>
<h2 id="重复引用"><a href="#重复引用" class="headerlink" title="重复引用"></a>重复引用</h2><p>有时候会出现这样的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">q</span>: b, <span class="attr">p</span>: b&#125;</span><br></pre></td></tr></table></figure>
<p>这种时候，我们其实希望 obj 中的 q 和 p 应该是同一个引用。</p>
<p>新建一个数组来存储出现的过的引用类型，在每一次循环的时候，得判断这个值之前有没有出现过，出现过就直接用数组中存储的。</p>
<p>这里会有一个问题，这个数组中的值需要有两个属性，一个是用于判断是否出现过，一个是用于返回存储的引用指针。所以这个数组中应该存储的是一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneBreadth</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 广度优先遍历 使用队列  shift()出队列  push()进队列</span></span><br><span class="line">	<span class="keyword">let</span> result = <span class="keyword">new</span> source.__proto__.constructor();</span><br><span class="line">	<span class="keyword">let</span> queues = [<span class="keyword">new</span> Node(result, source)]; <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*======增加部分=======*/</span></span><br><span class="line">	<span class="keyword">let</span> objArr = [];</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">findInObjArr</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (iterator.source === item) &#123;</span><br><span class="line">				<span class="keyword">return</span> iterator.target;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*=======增加部分======*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (queues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> item = queues.shift();</span><br><span class="line">		<span class="keyword">const</span> &#123; prev, content &#125; = item;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> content) &#123;</span><br><span class="line">			<span class="keyword">if</span> (content.hasOwnProperty(key)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">typeof</span> content[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (findInObjArr(objArr, content[key])) &#123;</span><br><span class="line">						prev[key] = findInObjArr(objArr, content[key]);</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					prev[key] = <span class="keyword">new</span> content[key].__proto__.constructor();</span><br><span class="line">					queues.push(<span class="keyword">new</span> Node(prev[key], content[key]));</span><br><span class="line">					objArr.push(&#123;</span><br><span class="line">						target: prev[key],</span><br><span class="line">						source: content[key],</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					prev[key] = content[key];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时测试，这样还解决了引用自身的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的所有的方法，都只是提供的一个参考和一个思路。都有各自使用的场景，在特定的时候使用特定的代码。</p>
<p>当然最后不忘来一手在平常开发中常使用的，简单类型的数组的深拷贝： JSON.parse(JSON.stringify())</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/04/23/转化的规则/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/转化的规则/" itemprop="url">== 隐式转化的规则</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T18:29:55+08:00">
                2019-04-23
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:27+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>js中==会发生类型转换，这是在一开始学习js的时候都会注意到的点。但是其中的细节，往往没有深究。本文旨在对其中的细节做一个记录与梳理。</p>
</blockquote>
<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>a == b</p>
<ol>
<li><p>如果a的类型与b的类型是一样的。 a == b 等同于 a === b. a b 类型不同才进行下面的转化</p>
</li>
<li><p>null 和 undefined 在 == 的情况下，默认是相等的。</p>
</li>
<li><p>如果 a b 是 String、Number 两种类型中的， 那么在 == 中会转化成数字类型(toNumber)来做比较。</p>
</li>
<li><p>如果 a b 中有 Boolean 类型的，另一个转化成数字类型(toNumber)来做比较</p>
</li>
<li><p>如果 a b 其中一个是对象， 而另一个是 String、Number、Symbol 中的一种。将会把对象转化成基本类型(toPrimitive)，再进行比对。</p>
</li>
</ol>
<blockquote>
<p>注意: <strong>5条件的情况是，只有一个是对象，而另一个一定不能是对象，两个都是对象的情形下，是不会发生类型转化的。</strong>  其实这一点看条件一就说的很清楚了，但是每次在遇到 == 的情况下，总想着去转化。记住一点原则，typeOf 值不同才去转化。</p>
</blockquote>
<ol start="6">
<li>都不满足的情况下，返回 false</li>
</ol>
<h2 id="toPrimitive"><a href="#toPrimitive" class="headerlink" title="toPrimitive"></a>toPrimitive</h2><p><a href="https://www.ecma-international.org/ecma-262/9.0/#sec-toprimitive" target="_blank" rel="noopener">原文定义</a></p>
<p>原文说的东西太过于冗杂，经过我理解。觉得就是 valueOf 或者 toString 方法。valueOf 的优先级更高，在没有valueOf 的情况下，才去调用 toString方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">90</span>&#125;</span><br><span class="line">obj.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">obj == <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="toNumber"><a href="#toNumber" class="headerlink" title="toNumber"></a>toNumber</h2><p>转化成数字类型，不同类型的值的规则：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>转化规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>+0</td>
</tr>
<tr>
<td>Boolean</td>
<td>true =&gt; 1 ; false =&gt; 0</td>
</tr>
<tr>
<td>String</td>
<td>如果直接把 引号 去掉，可以形成一个number就返回这个number，如果不能就返回 NaN</td>
</tr>
<tr>
<td>Object</td>
<td>1. 先使用 toPrimitive  2. 再 toNumber</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/04/18/babel初探/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/babel初探/" itemprop="url">babel初探</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T11:07:01+08:00">
                2019-04-18
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:27+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><h2 id="babel-做了什么"><a href="#babel-做了什么" class="headerlink" title="babel 做了什么"></a>babel 做了什么</h2><p>babel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。</p>
<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>babel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。</p>
<p>同时，插件还分为两种：</p>
<ol>
<li>语法插件</li>
</ol>
<p>语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。</p>
<p>和转译插件的差别在于是<strong>否转化</strong>，语法插件只是改变了<strong>解析</strong>的规则</p>
<ol start="2">
<li>转译插件</li>
</ol>
<p>转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：</p>
<p>In:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="params">()</span> =&gt;</span> b;</span><br></pre></td></tr></table></figure></p>
<p>经过转译插件之后，Out:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> b;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了</strong></p>
<h3 id="使用插件的方式"><a href="#使用插件的方式" class="headerlink" title="使用插件的方式"></a>使用插件的方式</h3><p>就是NPM包引入标准的步骤：</p>
<ol>
<li>npm i babel-plugin-xxx 安装</li>
<li>把插件名字增加到配置文件中</li>
</ol>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>babel的配置文件一般有两种方式，根据使用场景选择。</p>
<ol>
<li>babel.config.js</li>
</ol>
<p>放置于项目的根目录，一般写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modele.exports = <span class="function"><span class="keyword">function</span>(<span class="params">api</span>) </span>&#123;</span><br><span class="line">    api.cache(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> presets = [ ... ];</span><br><span class="line">    <span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets,</span><br><span class="line">        plugins</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>.babelrc</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [...],</span><br><span class="line">  <span class="attr">"plugins"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。</p>
<h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a>preset</h4><p>so，preset(预设)就出来啦。 其实preset就是一整套插件的方案。</p>
<p>这样我们就不再需要一个一个的配置，而是只设置preset 就可以了。 可以设置的值有：</p>
<ol>
<li>官方内容</li>
</ol>
<p>@babel/preset-env<br>@babel/preset-flow<br>@babel/preset-react<br>@babel/preset-typescript</p>
<p>这都是一些常用环境的preset</p>
<ol start="2">
<li>stag-x </li>
</ol>
<p>stage-x 每年都会随着js新版本的提案发生变化。分为5个阶段</p>
<p>Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。<br>Stage 1 - 建议（Proposal）：这是值得跟进的。<br>Stage 2 - 草案（Draft）：初始规范。<br>Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。<br>Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>preset 中的执行顺序是从后往前进行的。和插件的执行顺序是相反的。</p>
<h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h2><p>babel 的作用已经说过，是转化js代码，但是它只是针对其语法进行转化。如果是新的API，例如新增的generator、promise 之类的全局对象，babel是不会转化的。</p>
<p>需要使用新的全局对象的时候，需要使用到 <code>@babel/polyfill</code>.</p>
<p>但是使用 <code>@babel/polyfill</code> 有几点缺点：</p>
<ol>
<li><p>导致打包尺寸很大，本身这个插件尺寸就很大。但是很多时候，我们不会全部使用其中的功能。</p>
</li>
<li><p>会污染很多的全局变量。这点只在于本身也在开发类库的时候有影响。</p>
</li>
</ol>
<p>所以，我们通常不会直接使用 <code>@babel/polyfill</code>。</p>
<h3 id="babel-runtime-amp-babel-plugin-transform-runtime"><a href="#babel-runtime-amp-babel-plugin-transform-runtime" class="headerlink" title="@babel/runtime &amp; @babel/plugin-transform-runtime"></a>@babel/runtime &amp; @babel/plugin-transform-runtime</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/04/15/js-错误捕获总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/js-错误捕获总结/" itemprop="url">js 错误捕获总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T15:01:10+08:00">
                2019-04-15
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:07+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大纲</p>
<ul>
<li>try…catch</li>
<li>window.onerror</li>
<li>window.addEventLister(‘error’,function(){}[,Boolean-IsCapture])</li>
</ul>
<ol>
<li><p>try..catch</p>
<p>try…catch是在运行时捕获错误，并用catch处理错误。</p>
<p>但是不能处理异步的错误，promise的错误也捕获不到。</p>
<p>如果是任何情况下都要执行的代码，可以用 finally 子句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.onerror</p>
<p>与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。</p>
<p>使用方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>)</span>&#123; ... return <span class="literal">true</span>/<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。</p>
<p><strong>注意</strong> <code>element.onerror = function(event){}</code></p>
<p>这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。</p>
<p>同时，这里的错误是不会冒泡到window的错误处理方法上的。</p>
<ol start="3">
<li>window.addEventLister(‘error’,function(){}[,Boolean])</li>
</ol>
<p>3-1. 事件流</p>
<blockquote>
<p>题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法</p>
</blockquote>
<p>好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。</p>
<p>首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。</p>
<p><img src="https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png" alt="捕获冒泡"></p>
<p>使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。</p>
<p>捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。</p>
<p>3-2. stopPropagation()  preventDefault()</p>
<p>上面的两个方法都会讲事件流在使用位置停止。</p>
<p>3-3 e.target  e.currentTarget</p>
<p>currentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素</p>
<blockquote>
<p>回到正题，addEventListener(‘error’,function(){…},…isCapture)</p>
</blockquote>
<p>资源加载时候的错误，是不会传到window的 onerror 上面去的。</p>
<p>复习了事件流之后，这个地方的监听资源的报错，得在 <strong>捕获</strong> 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）</p>
<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：

在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`

我的一个猜想，应该是这个错误对象只有 -->
<blockquote>
<p>error 产生的流，是个怎么样的流向啊，还没有找到。。</p>
</blockquote>
<blockquote>
<p>而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (msg, url, row, col, error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我知道错误了'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        msg, url, row, col, error</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 貌似没有啥用</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/04/09/js遗漏知识总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/js遗漏知识总结/" itemprop="url">js遗漏知识总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T14:14:02+08:00">
                2019-04-09
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-08-27T09:11:57+08:00" content="2019-08-27">
                2019-08-27
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="不得不加上的分号"><a href="#不得不加上的分号" class="headerlink" title="不得不加上的分号"></a>不得不加上的分号</h2><p>现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。</p>
<p>先直接下结论，在使用 <code>+</code> <code>-</code> <code>(</code> <code>[</code> <code>/</code> 位于行首的时候需要加上分号。</p>
<p>除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。</p>
<p>下列两种情况使用中常出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[arr[<span class="number">1</span>], arr[<span class="number">2</span>]] = [arr[<span class="number">2</span>], arr[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这种时候都需要手动加上分号</p>
<h2 id="defer-async-在script-标签中的作用以及差异"><a href="#defer-async-在script-标签中的作用以及差异" class="headerlink" title="defer async 在script 标签中的作用以及差异"></a>defer async 在script 标签中的作用以及差异</h2><p>首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签</p>
<p>区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，</p>
<p>而async 在脚本下载完成之后就执行，中断文档的渲染</p>
<p>多个defer 会按照顺序加载执行，而 async会依据下载时间</p>
<h2 id="解构赋值使用方法总结"><a href="#解构赋值使用方法总结" class="headerlink" title="解构赋值使用方法总结"></a>解构赋值使用方法总结</h2><p>解构赋值，让获取变量的值，更加的优雅，代码更加的易读。</p>
<blockquote>
<p>小提一句原理，是利用的新增的iterator 接口。</p>
</blockquote>
<h3 id="数据的解构赋值"><a href="#数据的解构赋值" class="headerlink" title="数据的解构赋值"></a>数据的解构赋值</h3><p>常规的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果需要忽略某些值，用,,来忽略<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,,d] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">// a=a,d=4</span></span><br></pre></td></tr></table></figure></p>
<p>设定默认值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">5</span>,b=<span class="number">5</span>] = [<span class="number">2</span>] <span class="comment">// a=2,b=5</span></span><br></pre></td></tr></table></figure></p>
<p>剩余参数的赋值；（使用… , 但是注意，… 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment">// a = 1, b = 2, rest = [3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="经常使用的场景"><a href="#经常使用的场景" class="headerlink" title="经常使用的场景"></a>经常使用的场景</h4><p>下面记录几种经常在使用中利用的方法：</p>
<ol>
<li><p>交换变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = [b,a]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的exec语句、函数参数argument中某个值的获取</p>
</li>
</ol>
<p>exec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>普通的情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;o, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVAl'</span>,<span class="attr">l</span>:<span class="string">'lVAL'</span>&#125; <span class="comment">// o = 'oVAl', p = undefined</span></span><br></pre></td></tr></table></figure></p>
<p>使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">o</span>:oo, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVaL'</span>,<span class="attr">p</span>:<span class="string">'pVAL'</span>&#125; <span class="comment">// oo = 'oVAl', p = 'pVAL'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;(&#123;o, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVaL'</span>,<span class="attr">p</span>:<span class="string">'pVAL'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>…rest 和 默认值的使用方法就和数组的差不多了 </p>
<h2 id="requestAnimationFrame-理解"><a href="#requestAnimationFrame-理解" class="headerlink" title="requestAnimationFrame 理解"></a>requestAnimationFrame 理解</h2><p>这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，<strong>请求动画帧</strong>。</p>
<p>接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。</p>
<p>使用注意事项。requestAnimationFrame是window调用的，这一点和setTimeout一眼的。如果要使用this的话，通常可以在外面包装一个函数，用bind绑定this。</p>
<p>例如下面通过sayBind，来保留this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.sayBind = <span class="keyword">this</span>.say.bind(<span class="keyword">this</span>)</span><br><span class="line">        requestAnimationFrame(<span class="keyword">this</span>.sayBind)</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        requestAnimationFrame(<span class="keyword">this</span>.sayBind)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="屏幕刷新频率"><a href="#屏幕刷新频率" class="headerlink" title="屏幕刷新频率"></a>屏幕刷新频率</h3><p>一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。</p>
<h3 id="与setTimeout的对比"><a href="#与setTimeout的对比" class="headerlink" title="与setTimeout的对比"></a>与setTimeout的对比</h3><p>在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？</p>
<ol>
<li><p>屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。</p>
</li>
<li><p>setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。</p>
</li>
</ol>
<p>以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。</p>
<p>同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。</p>
<p>综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout</p>
<h2 id="鼠标事件中的那些-X-和-Y"><a href="#鼠标事件中的那些-X-和-Y" class="headerlink" title="鼠标事件中的那些 X 和 Y"></a>鼠标事件中的那些 X 和 Y</h2><p>由于些历史原因，事件中定义了很多的位置信息的属性。在使用和阅读中，经常容易混淆，在这里把它们都拿出来做一个总结。</p>
<p>随便在浏览器的控制台中打印一个事件的event，就可以看到，有这些与位置或者尺寸信息相关的属性。</p>
<p><code>clientX</code> <code>clientY</code> <code>layerX</code> <code>layerY</code> <code>movementX</code>  <code>movementY</code> <code>offsetX</code> <code>offsetY</code> <code>pageX</code> <code>pageY</code> <code>screenX</code> <code>screenY</code> <code>x</code> <code>y</code></p>
<p>咋眼一看，是有点多啊。。。</p>
<h3 id="clientX-clientY"><a href="#clientX-clientY" class="headerlink" title="clientX, clientY"></a>clientX, clientY</h3><p>浏览器内容区域的X/Y坐标（不包含滚动条）</p>
<h3 id="screenX-screenY"><a href="#screenX-screenY" class="headerlink" title="screenX,screenY"></a>screenX,screenY</h3><p>屏幕中的X/Y坐标</p>
<h3 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX, pageY"></a>pageX, pageY</h3><p>整个页面的X/Y坐标，包括可以滚动区域。（在没有滚动的情形下，这个值与client的数值相同）</p>
<h3 id="layerX、layerY"><a href="#layerX、layerY" class="headerlink" title="layerX、layerY"></a>layerX、layerY</h3><p>针对于绝对定位的元素来使用的位置属性。非绝对定位时，与pageX/pageY数值相同。</p>
<p>绝对定位元素的时候，是基于元素左上角的位置。</p>
<h3 id="movementX、movementY"><a href="#movementX、movementY" class="headerlink" title="movementX、movementY"></a>movementX、movementY</h3><p>这只是 <code>mousemove</code> 事件才有的属性。 值就是上一次的值和这一次的差值。</p>
<p>等价于 <code>currentEvent.movementY = currentEvent.screenY - previousEvent.screenY.</code></p>
<h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>offset 获取的数值都是相对于父容器的值。</p>
<p>同理的还有 offsetWidth offsetHeight offsetTop offsetLeft</p>
<h3 id="x-y"><a href="#x-y" class="headerlink" title="x,y"></a>x,y</h3><p>这只是 clientX 和 clientY 的别名而已。</p>
<h2 id="canvas中移动幻影效果"><a href="#canvas中移动幻影效果" class="headerlink" title="canvas中移动幻影效果"></a>canvas中移动幻影效果</h2><blockquote>
<p>幻影效果啊，这是我小时候玩泡泡堂最想要的皮肤。小学的时候，真的被这个帅到不行…</p>
</blockquote>
<p>在一般的canvas动画中，清除上一帧，使用的方法一般是 <code>clearRect()</code></p>
<p>如果想出现幻影的效果的话，应该保留上几帧的画面，我们使用半透明的遮布去覆盖，就只会让上几帧的画面颜色变淡，到达幻影的效果。</p>
<p><code>ctx.fillStyle = &#39;rgba(255,255,255,0.6)&#39;;ctx.fillRect(0,0,width,height)</code></p>
<h2 id="触发-DOMContentLoaded"><a href="#触发-DOMContentLoaded" class="headerlink" title="触发 DOMContentLoaded"></a>触发 DOMContentLoaded</h2><p>DOMContentLoaded 主要用于区别于 onLoaded, onLoaded 会在页面的所有资源都加载完成之后触发. DOMContentLoaded 会在初始的HTML文档加载之后触发. </p>
<h3 id="初始的HTML文档加载"><a href="#初始的HTML文档加载" class="headerlink" title="初始的HTML文档加载"></a>初始的HTML文档加载</h3><blockquote>
<p>那么,什么情况下HTML文档才会加载完全呢?</p>
</blockquote>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="浏览器渲染流程"></p>
<p>HTML文档和CSS的文档是并行的线程, 是不会相互影响的. 所以说在只有HTML和CSS的时候, DOMContentLoaded会在HTML加载完成之后直接触发,不会等待css样式文件的加载.(仅CSS样式写在head的情况下)</p>
<p>但是如果有JS资源存在的情况下就会有差异, 因为JS需要读取修改文档内容(浏览器会认为需要,即便本身代码本没有操作), 所以在有JS在css文件后面的时候, DOMContentLoaded 会在所有script和及其之前的样式表加载完成之后触发.</p>
<h2 id="js-css-顺序"><a href="#js-css-顺序" class="headerlink" title="js css 顺序"></a>js css 顺序</h2><ol>
<li>css 放在BODY前面, 防止页面闪烁. css 会阻塞HTML的渲染, 会在CSS树和HTML树都解析完成之后再渲染.</li>
<li>js 放在最后, js 如果需要操作DOM元素的话, 我们希望操作的是呈现出来的最终样式(需要等待HTML文档渲染完成), 所以css 会阻塞JS的执行, js 会在之前的CSS执行完成之后才执行. 同时JS会阻塞一切资源的加载</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/04/03/css遗漏知识总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/css遗漏知识总结/" itemprop="url">css遗漏知识总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T10:04:22+08:00">
                2019-04-03
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:27+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="class匹配符"><a href="#class匹配符" class="headerlink" title="class匹配符"></a>class匹配符</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[class$='xxx']</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[class^='xxx']</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种对类匹配都可以对名称进行帅选。</p>
<h2 id="sticky-布局"><a href="#sticky-布局" class="headerlink" title="sticky 布局"></a>sticky 布局</h2><p>使用sticky可以轻易的实现固定表头类似的需求。使用方法:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">200px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用position 为 sticky的时候，还需要指定 <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 四个值中的任意一个。</p>
<p>指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。</p>
</li>
<li><p>sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。</p>
</li>
<li><p>其父元素必须得可以scroll，才可以生效。</p>
</li>
<li><p>左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的</p>
</li>
</ol>
<p>其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。</p>
<h2 id="window-getComputedStyle-方法"><a href="#window-getComputedStyle-方法" class="headerlink" title="window.getComputedStyle() 方法"></a>window.getComputedStyle() 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="built_in">window</span>.getComputedStyle(ele, [pseudoElement])</span><br></pre></td></tr></table></figure>
<p>pseudoElement 是伪元素，没有可以不传或者传null。</p>
<p>返回的值是实时的 <code>CSSStyleDeclaration</code> 对象，该对象会实时更新属性。</p>
<p><em>这个返回的CSSStyleDeclaration对象是只读的，不能修改。</em></p>
<h3 id="CSSStyleDeclaration-对象"><a href="#CSSStyleDeclaration-对象" class="headerlink" title="CSSStyleDeclaration 对象"></a>CSSStyleDeclaration 对象</h3><p>除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。</p>
<p>但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是<em>可以修改</em>的</p>
<h4 id="CSSStyleDeclaration-getPropertyPriority-property-name"><a href="#CSSStyleDeclaration-getPropertyPriority-property-name" class="headerlink" title="CSSStyleDeclaration.getPropertyPriority(property_name)"></a>CSSStyleDeclaration.getPropertyPriority(property_name)</h4><p>返回可选的优先级，”Important”, 例如： priString= styleObj.getPropertyPriority(‘color’)</p>
<h4 id="CSSStyleDeclaration-getPropertyValue-property-name"><a href="#CSSStyleDeclaration-getPropertyValue-property-name" class="headerlink" title="CSSStyleDeclaration.getPropertyValue(property_name)"></a>CSSStyleDeclaration.getPropertyValue(property_name)</h4><p>属性名可以使用驼峰命名法。</p>
<p>返回属性值。例如: valString= styleObj.getPropertyValue(‘color’)</p>
<h4 id="CSSStyleDeclaration-removeProperty-property-name"><a href="#CSSStyleDeclaration-removeProperty-property-name" class="headerlink" title="CSSStyleDeclaration.removeProperty(property_name)"></a>CSSStyleDeclaration.removeProperty(property_name)</h4><p>返回被删除的属性。</p>
<h3 id="CSSStyleDeclaration-setProperty-property-name-property-val-property-priority"><a href="#CSSStyleDeclaration-setProperty-property-name-property-val-property-priority" class="headerlink" title="CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])"></a>CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])</h3><p>没有返回值。设置属性值。</p>
<p><em>后面两个方法都只有在 style 方法中获取的对象可以使用</em></p>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>使用这个方法会导致页面回流。</p>
<h2 id="可以继承的css属性"><a href="#可以继承的css属性" class="headerlink" title="可以继承的css属性"></a>可以继承的css属性</h2><blockquote>
<p>这个问题，记不住啊..得想个办法</p>
</blockquote>
<p>继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。</p>
<p>而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。</p>
<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</p>
<p>所有元素可继承：visibility 和 cursor。</p>
<p>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。<br>暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。</p>
<p>visibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。</p>
<p>想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。</p>
<h2 id="CSS-渐变属性使用"><a href="#CSS-渐变属性使用" class="headerlink" title="CSS 渐变属性使用"></a>CSS 渐变属性使用</h2><p>使用渐变属性(gradient)可以一个元素多种颜色<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">linear-gradient</span>(to bottom,red 0%,red 50%,blue 50%,blue 100%)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.</p>
<h2 id="可替换内容的-object-fit-属性"><a href="#可替换内容的-object-fit-属性" class="headerlink" title="可替换内容的 object-fit 属性"></a>可替换内容的 object-fit 属性</h2><p>上面这个描述的可替换内容，在使用中最常用到的就是 image 标签了。参数的意义都是相对于内容的容器来说的。</p>
<p>可选的值有： fill contain cover none scale-down</p>
<p>这几个值的区别在于</p>
<ol>
<li>是否保持原图比例</li>
<li>是否填满整个容器</li>
<li>是否允许内容溢出容器</li>
</ol>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>铺满整个容器，不需要保持原图比例。</p>
<h3 id="contain"><a href="#contain" class="headerlink" title="contain"></a>contain</h3><p>铺满整个容器，但是保持图片比例，同时内容不能溢出容器。</p>
<h3 id="cover"><a href="#cover" class="headerlink" title="cover"></a>cover</h3><p>铺满整个容器，但是保持图片比例，同时内容可以溢出容器。</p>
<h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>保持原有尺寸</p>
<h3 id="scale-down"><a href="#scale-down" class="headerlink" title="scale-down"></a>scale-down</h3><p>取 none 和 contain 中尺寸小的那一个</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/2019/03/29/普通图层和复合图层/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/普通图层和复合图层/" itemprop="url">普通图层和复合图层</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T10:36:23+08:00">
                2019-03-29
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; 修改于
              <time itemprop="dateUpdated" datetime="2019-05-18T13:17:07+08:00" content="2019-05-18">
                2019-05-18
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。<br>由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结</p>
</blockquote>
<p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p>
<p>首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。</p>
<p>无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。</p>
<p>当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。</p>
<p>不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。</p>
<h3 id="如何开启硬件加速"><a href="#如何开启硬件加速" class="headerlink" title="如何开启硬件加速"></a>如何开启硬件加速</h3><p>在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。<br>最常用的方式：<code>translate3d</code>、<code>translateZ</code>。</p>
<p>很多时候在本身没有使用3D变化的时候，可以用<code>transform: translateZ(0)</code>来使用。</p>
<p>还有就是<code>opacity属性/过渡动画</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。</p>
<p>因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。</p>
<p>同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Yippee">
          <p class="site-author-name" itemprop="name">Yippee</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Yippeee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Yipper_tc" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2606794002/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yippee</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
