<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta property="og:type" content="website">
<meta property="og:title" content="依破缘">
<meta property="og:url" content="http://yippee.ink/git-blog/index.html">
<meta property="og:site_name" content="依破缘">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="依破缘">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yippee.ink/git-blog/">





  <title>依破缘</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?be0a702b8fbcbc2433ff711ca69c62ed";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">依破缘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/03/07/置顶文章/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/置顶文章/" itemprop="url">置顶文章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T15:33:56+08:00">
                2019-03-07
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-22T08:50:33+08:00" content="2019-04-22">
                2019-04-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="博客现在的规划"><a href="#博客现在的规划" class="headerlink" title="博客现在的规划"></a>博客现在的规划</h1><ul>
<li style="list-style: none"><input type="checkbox"> js函数式编程学习</li>
<li style="list-style: none"><input type="checkbox"> Lodash-分析学习<blockquote>
<p>上面第一个进行的有点困难现在.</p>
</blockquote>
</li>
</ul>
<p>2019-03-14: </p>
<ol>
<li>Promise模仿,手写了一遍实现</li>
<li>准备完整的搞一遍 js中的 this的问题</li>
</ol>
<p>2019-03-18:</p>
<ol>
<li>http 缓存知识复习</li>
<li>promise 再现</li>
</ol>
<p>2019-03-29</p>
<blockquote>
<p>首先，上述的学习任务基本完成，当然规划那两个是长期任务。</p>
</blockquote>
<p>去年七月份就刷了这篇(博客)[<a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。" target="_blank" rel="noopener">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。</a></p>
<p>浏览器的机制，到如何打开一个tab页。（涉及到进程和线程）</p>
<p>其中有很多后台的和服务器端的内容，暂时不作为我的学习内容，在这里只对其中出现的前端的内容，而我都不是很了解的内容做一个to-learn-list。</p>
<p>简单层与复合层，都是什么，这个完全不了解。(已经做了总结)<br>(看这个)[<a href="https://segmentfault.com/a/1190000012925872#articleHeader16]" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012925872#articleHeader16]</a></p>
<p>没事多看看这篇博客，对其中不太了解的知识体系做一个梳理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/23/转化的规则/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/转化的规则/" itemprop="url">== 隐式转化的规则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T18:29:55+08:00">
                2019-04-23
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-23T18:35:15+08:00" content="2019-04-23">
                2019-04-23
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/18/babel初探/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/18/babel初探/" itemprop="url">babel初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-18T11:07:01+08:00">
                2019-04-18
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-24T10:06:04+08:00" content="2019-04-24">
                2019-04-24
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><h2 id="babel-做了什么"><a href="#babel-做了什么" class="headerlink" title="babel 做了什么"></a>babel 做了什么</h2><p>babel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。</p>
<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>babel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。</p>
<p>同时，插件还分为两种：</p>
<ol>
<li>语法插件</li>
</ol>
<p>语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。</p>
<p>和转译插件的差别在于是<strong>否转化</strong>，语法插件只是改变了<strong>解析</strong>的规则</p>
<ol start="2">
<li>转译插件</li>
</ol>
<p>转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：</p>
<p>In:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="params">()</span> =&gt;</span> b;</span><br></pre></td></tr></table></figure></p>
<p>经过转译插件之后，Out:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> b;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了</strong></p>
<h3 id="使用插件的方式"><a href="#使用插件的方式" class="headerlink" title="使用插件的方式"></a>使用插件的方式</h3><p>就是NPM包引入标准的步骤：</p>
<ol>
<li>npm i babel-plugin-xxx 安装</li>
<li>把插件名字增加到配置文件中</li>
</ol>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>babel的配置文件一般有两种方式，根据使用场景选择。</p>
<ol>
<li>babel.config.js</li>
</ol>
<p>放置于项目的根目录，一般写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">modele.exports = <span class="function"><span class="keyword">function</span>(<span class="params">api</span>) </span>&#123;</span><br><span class="line">    api.cache(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> presets = [ ... ];</span><br><span class="line">    <span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        presets,</span><br><span class="line">        plugins</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>.babelrc</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [...],</span><br><span class="line">  <span class="attr">"plugins"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。</p>
<h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a>preset</h4><p>so，preset(预设)就出来啦。 其实preset就是一整套插件的方案。</p>
<p>这样我们就不再需要一个一个的配置，而是只设置preset 就可以了。 可以设置的值有：</p>
<ol>
<li>官方内容</li>
</ol>
<p>@babel/preset-env<br>@babel/preset-flow<br>@babel/preset-react<br>@babel/preset-typescript</p>
<p>这都是一些常用环境的preset</p>
<ol start="2">
<li>stag-x </li>
</ol>
<p>stage-x 每年都会随着js新版本的提案发生变化。分为5个阶段</p>
<p>Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。<br>Stage 1 - 建议（Proposal）：这是值得跟进的。<br>Stage 2 - 草案（Draft）：初始规范。<br>Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。<br>Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>preset 中的执行顺序是从后往前进行的。和插件的执行顺序是相反的。</p>
<h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h2><p>babel 的作用已经说过，是转化js代码，但是它只是针对其语法进行转化。如果是新的API，例如新增的generator、promise 之类的全局对象，babel是不会转化的。</p>
<p>需要使用新的全局对象的时候，需要使用到 <code>@babel/polyfill</code>.</p>
<p>但是使用 <code>@babel/polyfill</code> 有几点缺点：</p>
<ol>
<li><p>导致打包尺寸很大，本身这个插件尺寸就很大。但是很多时候，我们不会全部使用其中的功能。</p>
</li>
<li><p>会污染很多的全局变量。这点只在于本身也在开发类库的时候有影响。</p>
</li>
</ol>
<p>所以，我们通常不会直接使用 <code>@babel/polyfill</code>。</p>
<h3 id="babel-runtime-amp-babel-plugin-transform-runtime"><a href="#babel-runtime-amp-babel-plugin-transform-runtime" class="headerlink" title="@babel/runtime &amp; @babel/plugin-transform-runtime"></a>@babel/runtime &amp; @babel/plugin-transform-runtime</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/15/js-错误捕获总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/js-错误捕获总结/" itemprop="url">js 错误捕获总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T15:01:10+08:00">
                2019-04-15
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-22T08:50:33+08:00" content="2019-04-22">
                2019-04-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大纲</p>
<ul>
<li>try…catch</li>
<li>window.onerror</li>
<li>window.addEventLister(‘error’,function(){}[,Boolean-IsCapture])</li>
</ul>
<ol>
<li><p>try..catch</p>
<p>try…catch是在运行时捕获错误，并用catch处理错误。</p>
<p>但是不能处理异步的错误，promise的错误也捕获不到。</p>
<p>如果是任何情况下都要执行的代码，可以用 finally 子句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.onerror</p>
<p>与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。</p>
<p>使用方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>)</span>&#123; ... return <span class="literal">true</span>/<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。</p>
<p><strong>注意</strong> <code>element.onerror = function(event){}</code></p>
<p>这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。</p>
<p>同时，这里的错误是不会冒泡到window的错误处理方法上的。</p>
<ol start="3">
<li>window.addEventLister(‘error’,function(){}[,Boolean])</li>
</ol>
<p>3-1. 事件流</p>
<blockquote>
<p>题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法</p>
</blockquote>
<p>好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。</p>
<p>首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。</p>
<p><img src="https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png" alt="捕获冒泡"></p>
<p>使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。</p>
<p>捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。</p>
<p>3-2. stopPropagation()  preventDefault()</p>
<p>上面的两个方法都会讲事件流在使用位置停止。</p>
<p>3-3 e.target  e.currentTarget</p>
<p>currentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素</p>
<blockquote>
<p>回到正题，addEventListener(‘error’,function(){…},…isCapture)</p>
</blockquote>
<p>资源加载时候的错误，是不会传到window的 onerror 上面去的。</p>
<p>复习了事件流之后，这个地方的监听资源的报错，得在 <strong>捕获</strong> 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）</p>
<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：

在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`

我的一个猜想，应该是这个错误对象只有 -->
<blockquote>
<p>error 产生的流，是个怎么样的流向啊，还没有找到。。</p>
</blockquote>
<blockquote>
<p>而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (msg, url, row, col, error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我知道错误了'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        msg, url, row, col, error</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 貌似没有啥用</span></span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/09/js遗漏知识总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/js遗漏知识总结/" itemprop="url">js遗漏知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T14:14:02+08:00">
                2019-04-09
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-24T10:06:04+08:00" content="2019-04-24">
                2019-04-24
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="不得不加上的分号"><a href="#不得不加上的分号" class="headerlink" title="不得不加上的分号"></a>不得不加上的分号</h2><p>现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。</p>
<p>先直接下结论，在使用 <code>+</code> <code>-</code> <code>(</code> <code>[</code> <code>/</code> 位于行首的时候需要加上分号。</p>
<p>除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。</p>
<p>下列两种情况使用中常出现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[arr[<span class="number">1</span>], arr[<span class="number">2</span>]] = [arr[<span class="number">2</span>], arr[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>这种时候都需要手动加上分号</p>
<h2 id="defer-async-在script-标签中的作用以及差异"><a href="#defer-async-在script-标签中的作用以及差异" class="headerlink" title="defer async 在script 标签中的作用以及差异"></a>defer async 在script 标签中的作用以及差异</h2><p>首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签</p>
<p>区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，</p>
<p>而async 在脚本下载完成之后就执行，中断文档的渲染</p>
<p>多个defer 会按照顺序加载执行，而 async会依据下载时间</p>
<h2 id="解构赋值使用方法总结"><a href="#解构赋值使用方法总结" class="headerlink" title="解构赋值使用方法总结"></a>解构赋值使用方法总结</h2><p>解构赋值，让获取变量的值，更加的优雅，代码更加的易读。</p>
<blockquote>
<p>小提一句原理，是利用的新增的iterator 接口。</p>
</blockquote>
<h3 id="数据的解构赋值"><a href="#数据的解构赋值" class="headerlink" title="数据的解构赋值"></a>数据的解构赋值</h3><p>常规的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果需要忽略某些值，用,,来忽略<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,,,d] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">// a=a,d=4</span></span><br></pre></td></tr></table></figure></p>
<p>设定默认值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">5</span>,b=<span class="number">5</span>] = [<span class="number">2</span>] <span class="comment">// a=2,b=5</span></span><br></pre></td></tr></table></figure></p>
<p>剩余参数的赋值；（使用… , 但是注意，… 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,...rest] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment">// a = 1, b = 2, rest = [3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="经常使用的场景"><a href="#经常使用的场景" class="headerlink" title="经常使用的场景"></a>经常使用的场景</h4><p>下面记录几种经常在使用中利用的方法：</p>
<ol>
<li><p>交换变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a,b] = [b,a]</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式的exec语句、函数参数argument中某个值的获取</p>
</li>
</ol>
<p>exec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>普通的情况:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;o, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVAl'</span>,<span class="attr">l</span>:<span class="string">'lVAL'</span>&#125; <span class="comment">// o = 'oVAl', p = undefined</span></span><br></pre></td></tr></table></figure></p>
<p>使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">o</span>:oo, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVaL'</span>,<span class="attr">p</span>:<span class="string">'pVAL'</span>&#125; <span class="comment">// oo = 'oVAl', p = 'pVAL'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;(&#123;o, p&#125; = &#123;<span class="attr">o</span>:<span class="string">'oVaL'</span>,<span class="attr">p</span>:<span class="string">'pVAL'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>…rest 和 默认值的使用方法就和数组的差不多了 </p>
<h2 id="requestAnimationFrame-理解"><a href="#requestAnimationFrame-理解" class="headerlink" title="requestAnimationFrame 理解"></a>requestAnimationFrame 理解</h2><p>这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，<strong>请求动画帧</strong>。</p>
<p>接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。</p>
<p>使用注意事项。requestAnimationFrame是window调用的，这一点和setTimeout一眼的。如果要使用this的话，通常可以在外面包装一个函数，用bind绑定this。</p>
<p>例如下面通过sayBind，来保留this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.sayBind = <span class="keyword">this</span>.say.bind(<span class="keyword">this</span>)</span><br><span class="line">        requestAnimationFrame(<span class="keyword">this</span>.sayBind)</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        requestAnimationFrame(<span class="keyword">this</span>.sayBind)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="屏幕刷新频率"><a href="#屏幕刷新频率" class="headerlink" title="屏幕刷新频率"></a>屏幕刷新频率</h3><p>一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。</p>
<h3 id="与setTimeout的对比"><a href="#与setTimeout的对比" class="headerlink" title="与setTimeout的对比"></a>与setTimeout的对比</h3><p>在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？</p>
<ol>
<li><p>屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。</p>
</li>
<li><p>setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。</p>
</li>
</ol>
<p>以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。</p>
<p>同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。</p>
<p>综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout</p>
<h2 id="鼠标事件中的那些-X-和-Y"><a href="#鼠标事件中的那些-X-和-Y" class="headerlink" title="鼠标事件中的那些 X 和 Y"></a>鼠标事件中的那些 X 和 Y</h2><p>由于些历史原因，事件中定义了很多的位置信息的属性。在使用和阅读中，经常容易混淆，在这里把它们都拿出来做一个总结。</p>
<p>随便在浏览器的控制台中打印一个事件的event，就可以看到，有这些与位置或者尺寸信息相关的属性。</p>
<p><code>clientX</code> <code>clientY</code> <code>layerX</code> <code>layerY</code> <code>movementX</code>  <code>movementY</code> <code>offsetX</code> <code>offsetY</code> <code>pageX</code> <code>pageY</code> <code>screenX</code> <code>screenY</code> <code>x</code> <code>y</code></p>
<p>咋眼一看，是有点多啊。。。</p>
<h3 id="clientX-clientY"><a href="#clientX-clientY" class="headerlink" title="clientX, clientY"></a>clientX, clientY</h3><p>浏览器内容区域的X/Y坐标（不包含滚动条）</p>
<h3 id="screenX-screenY"><a href="#screenX-screenY" class="headerlink" title="screenX,screenY"></a>screenX,screenY</h3><p>屏幕中的X/Y坐标</p>
<h3 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX, pageY"></a>pageX, pageY</h3><p>整个页面的X/Y坐标，包括可以滚动区域。（在没有滚动的情形下，这个值与client的数值相同）</p>
<h3 id="layerX、layerY"><a href="#layerX、layerY" class="headerlink" title="layerX、layerY"></a>layerX、layerY</h3><p>针对于绝对定位的元素来使用的位置属性。非绝对定位时，与pageX/pageY数值相同。</p>
<p>绝对定位元素的时候，是基于元素左上角的位置。</p>
<h3 id="movementX、movementY"><a href="#movementX、movementY" class="headerlink" title="movementX、movementY"></a>movementX、movementY</h3><p>这只是 <code>mousemove</code> 事件才有的属性。 值就是上一次的值和这一次的差值。</p>
<p>等价于 <code>currentEvent.movementY = currentEvent.screenY - previousEvent.screenY.</code></p>
<h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>offset 获取的数值都是相对于父容器的值。</p>
<p>同理的还有 offsetWidth offsetHeight offsetTop offsetLeft</p>
<h3 id="x-y"><a href="#x-y" class="headerlink" title="x,y"></a>x,y</h3><p>这只是 clientX 和 clientY 的别名而已。</p>
<h2 id="canvas中移动幻影效果"><a href="#canvas中移动幻影效果" class="headerlink" title="canvas中移动幻影效果"></a>canvas中移动幻影效果</h2><blockquote>
<p>幻影效果啊，这是我小时候玩泡泡堂最想要的皮肤。小学的时候，真的被这个帅到不行…</p>
</blockquote>
<p>在一般的canvas动画中，清除上一帧，使用的方法一般是 <code>clearRect()</code></p>
<p>如果想出现幻影的效果的话，应该保留上几帧的画面，我们使用半透明的遮布去覆盖，就只会让上几帧的画面颜色变淡，到达幻影的效果。</p>
<p><code>ctx.fillStyle = &#39;rgba(255,255,255,0.6)&#39;;ctx.fillRect(0,0,width,height)</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/05/Regex-Golf闯关记录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/05/Regex-Golf闯关记录/" itemprop="url">Regex Golf闯关记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-05T10:43:24+08:00">
                2019-04-05
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-24T10:03:10+08:00" content="2019-04-24">
                2019-04-24
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这篇博客是对<a href="https://alf.nu/RegexGolf" target="_blank" rel="noopener">Regex Golf</a>答案的记录和总结</p>
</blockquote>
<h2 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h2><p><code>^[^o].....?$</code> 通过个数判断</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/04/03/css遗漏知识总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/css遗漏知识总结/" itemprop="url">css遗漏知识总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T10:04:22+08:00">
                2019-04-03
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-24T10:11:34+08:00" content="2019-04-24">
                2019-04-24
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="class匹配符"><a href="#class匹配符" class="headerlink" title="class匹配符"></a>class匹配符</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[class$='xxx']</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[class^='xxx']</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种对类匹配都可以对名称进行帅选。</p>
<h2 id="sticky-布局"><a href="#sticky-布局" class="headerlink" title="sticky 布局"></a>sticky 布局</h2><p>使用sticky可以轻易的实现固定表头类似的需求。使用方法:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">200px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用position 为 sticky的时候，还需要指定 <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 四个值中的任意一个。</p>
<p>指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。</p>
</li>
<li><p>sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。</p>
</li>
<li><p>其父元素必须得可以scroll，才可以生效。</p>
</li>
<li><p>左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的</p>
</li>
</ol>
<p>其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。</p>
<h2 id="window-getComputedStyle-方法"><a href="#window-getComputedStyle-方法" class="headerlink" title="window.getComputedStyle() 方法"></a>window.getComputedStyle() 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="built_in">window</span>.getComputedStyle(ele, [pseudoElement])</span><br></pre></td></tr></table></figure>
<p>pseudoElement 是伪元素，没有可以不传或者传null。</p>
<p>返回的值是实时的 <code>CSSStyleDeclaration</code> 对象，该对象会实时更新属性。</p>
<p><em>这个返回的CSSStyleDeclaration对象是只读的，不能修改。</em></p>
<h3 id="CSSStyleDeclaration-对象"><a href="#CSSStyleDeclaration-对象" class="headerlink" title="CSSStyleDeclaration 对象"></a>CSSStyleDeclaration 对象</h3><p>除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。</p>
<p>但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是<em>可以修改</em>的</p>
<h4 id="CSSStyleDeclaration-getPropertyPriority-property-name"><a href="#CSSStyleDeclaration-getPropertyPriority-property-name" class="headerlink" title="CSSStyleDeclaration.getPropertyPriority(property_name)"></a>CSSStyleDeclaration.getPropertyPriority(property_name)</h4><p>返回可选的优先级，”Important”, 例如： priString= styleObj.getPropertyPriority(‘color’)</p>
<h4 id="CSSStyleDeclaration-getPropertyValue-property-name"><a href="#CSSStyleDeclaration-getPropertyValue-property-name" class="headerlink" title="CSSStyleDeclaration.getPropertyValue(property_name)"></a>CSSStyleDeclaration.getPropertyValue(property_name)</h4><p>属性名可以使用驼峰命名法。</p>
<p>返回属性值。例如: valString= styleObj.getPropertyValue(‘color’)</p>
<h4 id="CSSStyleDeclaration-removeProperty-property-name"><a href="#CSSStyleDeclaration-removeProperty-property-name" class="headerlink" title="CSSStyleDeclaration.removeProperty(property_name)"></a>CSSStyleDeclaration.removeProperty(property_name)</h4><p>返回被删除的属性。</p>
<h3 id="CSSStyleDeclaration-setProperty-property-name-property-val-property-priority"><a href="#CSSStyleDeclaration-setProperty-property-name-property-val-property-priority" class="headerlink" title="CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])"></a>CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])</h3><p>没有返回值。设置属性值。</p>
<p><em>后面两个方法都只有在 style 方法中获取的对象可以使用</em></p>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>使用这个方法会导致页面回流。</p>
<h2 id="可以继承的css属性"><a href="#可以继承的css属性" class="headerlink" title="可以继承的css属性"></a>可以继承的css属性</h2><blockquote>
<p>这个问题，记不住啊..得想个办法</p>
</blockquote>
<p>继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。</p>
<p>而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。</p>
<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</p>
<p>所有元素可继承：visibility 和 cursor。</p>
<p>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。<br>暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。</p>
<p>visibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。</p>
<p>想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。</p>
<h2 id="CSS-渐变属性使用"><a href="#CSS-渐变属性使用" class="headerlink" title="CSS 渐变属性使用"></a>CSS 渐变属性使用</h2><p>使用渐变属性(gradient)可以一个元素多种颜色<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">linear-gradient</span>(to bottom,red 0%,red 50%,blue 50%,blue 100%)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/03/29/普通图层和复合图层/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/普通图层和复合图层/" itemprop="url">普通图层和复合图层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T10:36:23+08:00">
                2019-03-29
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-22T08:50:33+08:00" content="2019-04-22">
                2019-04-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。<br>由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结</p>
</blockquote>
<p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p>
<p>首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。</p>
<p>无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。</p>
<p>当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。</p>
<p>不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。</p>
<h3 id="如何开启硬件加速"><a href="#如何开启硬件加速" class="headerlink" title="如何开启硬件加速"></a>如何开启硬件加速</h3><p>在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。<br>最常用的方式：<code>translate3d</code>、<code>translateZ</code>。</p>
<p>很多时候在本身没有使用3D变化的时候，可以用<code>transform: translateZ(0)</code>来使用。</p>
<p>还有就是<code>opacity属性/过渡动画</code></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。</p>
<p>因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。</p>
<p>同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/03/27/http缓存/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/http缓存/" itemprop="url">http缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T16:18:20+08:00">
                2019-03-27
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-22T08:50:33+08:00" content="2019-04-22">
                2019-04-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这篇博客纯粹是搬运，因为这些知识都是看来的，没有实践过。</p>
</blockquote>
<p>原先的时候http缓存(强缓存)是直接设定缓存的时间，如果时间过了，就去服务器请求新的数据。</p>
<p>如果时间没有过，就直接从缓存数据中读取数据，<strong>不会发送请求</strong>。</p>
<p>用到的字段有： </p>
<p>Expire： 设置缓存过期时间，使用的是GMT(格林尼治时间)，这个时间是相对于服务器的</p>
<p>而由于时间是对于服务器的，无法统一。 就使用了一个新的字段： <strong>cache-control</strong></p>
<p>cache-control：设置 max-age=t 直接设置绝对过期时间<br>同时，还有其他的属性：</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-cache</td>
<td>代理服务器不能缓存数据，如果是在请求阶段就是，直接向服务器发送请求</td>
</tr>
<tr>
<td>no-store</td>
<td>所有的内容都不能被缓存</td>
</tr>
<tr>
<td>private [= ‘field-name’]</td>
<td>指定的用户或者缓存服务器才能缓存数据 </td>
</tr>
<tr>
<td>public</td>
<td><strong>只出现在响应头中</strong>，任何情况下都需要缓存数据</td>
</tr>
<tr>
<td>max-age=t</td>
<td>请求时：告知服务器接收一个在t时间之内的数据; 返回时，告知t时间内，数据不同再请求</td>
</tr>
</tbody>
</table>
<p>cache-control 中的属性可以设置多个，自由组合</p>
<p>上面的字段决定了是否会发出请求，但是请求发出之后，也不是一定会再次发送数据的。还需要进行验证</p>
<h3 id="缓存校验字段"><a href="#缓存校验字段" class="headerlink" title="缓存校验字段"></a>缓存校验字段</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yippee.ink/git-blog/2019/03/25/几种常见的递归函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yippee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依破缘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/几种常见的递归函数/" itemprop="url">几种常见的递归函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T15:53:22+08:00">
                2019-03-25
              </time>
            

            

            
          </span>
          
          
            <span class="post-updated">
              &nbsp; | &nbsp; post.updated
              <time itemprop="dateUpdated" datetime="2019-04-22T08:50:33+08:00" content="2019-04-22">
                2019-04-22
              </time>
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现</p>
</blockquote>
<h2 id="树形结构对象的遍历"><a href="#树形结构对象的遍历" class="headerlink" title="树形结构对象的遍历"></a>树形结构对象的遍历</h2><p>完成一个函数，作用是返回对象的最大深度（其实就是树的深度）</p>
<p>首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1</p>
<p>一个递归的原型就形成了</p>
<ol>
<li>相连项目之间的关系</li>
<li>递归退出的条件</li>
</ol>
<p>所以递归的套路模板一般形如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (基本情况) &#123;</span><br><span class="line">    直接返回，退出函数</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    继续调用(新的参数)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，按照上面的描述，写出这个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 判断是不是单层对象</span></span><br><span class="line">    <span class="keyword">const</span> getSons = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getObjChildren(obj).every(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(item) !== <span class="string">'[object Object]'</span> <span class="comment">// 对象类型判断</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getSons(obj)) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    getObjChildren(obj).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        max = traverse(item) &gt; max ? traverse(item) : max</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取对象的直接儿子元素，返回数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjChildren</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">const</span> element = obj[key];</span><br><span class="line">            result.push(element)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用递归就是这么做的，如果不能使用递归呢。</p>
<p>我们将思维转化一下，不要江化。</p>
<p>这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">layerTraverse</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> layer = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> queues = [] <span class="comment">// 用于存放一层的所有数据</span></span><br><span class="line">    queues = getObjChildren(obj)</span><br><span class="line">    <span class="comment">// 如何通过两个while 完成对所有节点的遍历</span></span><br><span class="line">    <span class="comment">// 第一个while 作为外圈， 判断下一层是否还有数据</span></span><br><span class="line">    <span class="comment">// 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue</span></span><br><span class="line">    <span class="keyword">while</span> (queues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        layer++</span><br><span class="line">        <span class="keyword">let</span> length = queues.length</span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> item = queues.shift()</span><br><span class="line">            queues.push(...getObjChildren(item))</span><br><span class="line">            length--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> layer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时这还利用了堆的思想。  </p>
<h2 id="阶乘、Fibonacci函数以及-HanoiTower-汉诺塔"><a href="#阶乘、Fibonacci函数以及-HanoiTower-汉诺塔" class="headerlink" title="阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)"></a>阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)</h2><p>明确这三个的定义：</p>
<p>阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1</p>
<p>Fibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1</p>
<p>HanoiTower(汉诺塔)：<br>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<ol>
<li>每次只能移动一个圆盘；</li>
<li>大盘不能叠在小盘上面。</li>
</ol>
<p>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>
<p>问：如何移？最少要移动多少次？</p>
<h3 id="Fibonacci函数"><a href="#Fibonacci函数" class="headerlink" title="Fibonacci函数"></a>Fibonacci函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。</p>
<p>这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。</p>
<p>我们不适用这些办法，我这里想做的是用循环代替递归。</p>
<p>也就是适用DP的思想，只保存当前运算时需要的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>, </span><br><span class="line">    a1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        result = result + a1</span><br><span class="line">        a1 = result - a1</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。</p>
<blockquote>
<p>update: 2019-03-29</p>
</blockquote>
<p>发现了一种更优雅的实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci3</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        [prev, curr] = [curr, curr + prev]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码量更少，更容易阅读。思路来自于MDN迭代器中的实现。</p>
<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        result = i * result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HanoiTower-汉诺塔"><a href="#HanoiTower-汉诺塔" class="headerlink" title="HanoiTower(汉诺塔)"></a>HanoiTower(汉诺塔)</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg" alt="汉诺塔"></p>
<p>思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HanoiTower</span>(<span class="params">n, from, by, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        move(<span class="number">1</span>, <span class="keyword">from</span>, to)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HanoiTower(n - <span class="number">1</span>, <span class="keyword">from</span>, by, to)</span><br><span class="line">        move(n, <span class="keyword">from</span>, to)</span><br><span class="line">        HanoiTower(n - <span class="number">1</span>, to, by, <span class="keyword">from</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">n, from, to, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`移动第<span class="subst">$&#123;n&#125;</span>个从<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span> ----&gt; <span class="subst">$&#123;to&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><blockquote>
<p>除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。</p>
</blockquote>
<p>尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。</p>
<p>只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。</p>
<p>这是对Fibonacci函数的尾递归改造：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci3</span>(<span class="params">n, val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> val2</span><br><span class="line">    <span class="keyword">return</span> Fibonacci3(n - <span class="number">1</span>, val1 + val2, val1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再对阶乘函数进行改造：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看以上两个尾递归的函数，我们在使用的时候，都得显视的传入 val1 或者 total 这种开始的值。</p>
<p>会让函数的意义不容易懂。</p>
<p>这里有两种办法，一种是<strong>柯里化</strong>，另一种是<strong>参数默认值</strong></p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>需要在外圈再包一个函数，如果是Fibonacci 函数的话。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>, val, n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Fibonacci3_1 = currying(Fibonacci3, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci3</span>(<span class="params">n, val1 = <span class="number">1</span>, val2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> val2</span><br><span class="line">    <span class="keyword">return</span> Fibonacci3(n - <span class="number">1</span>, val1 + val2, val1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Yippee">
          <p class="site-author-name" itemprop="name">Yippee</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Yippeee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Yipper_tc" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yippee</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
