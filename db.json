{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1551958778568},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1551958778568},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1551958778568},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1551958778568},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1551958778569},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1551958778569},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1551958778569},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1551958778569},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1551958778569},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1551958778569},{"_id":"themes/next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1551958778570},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1551958778570},{"_id":"themes/next/_config.yml","hash":"7ca59b4bcad9a4e2e3b7f6052dafdd6bd7d452a8","modified":1551958778570},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1551958778571},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1551958778571},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1551958778586},{"_id":"source/_drafts/HTTP相关博客.md","hash":"35d28bd8608db9e0b4eb395146a5cb1d54b78764","modified":1551958778540},{"_id":"source/_drafts/Promise的实现.md","hash":"322924e64d43466393faffef9519b7d88824417d","modified":1551958778540},{"_id":"source/_posts/2018-e5-b9-b4-e5-b9-b4-e7-bb-88-e6-80-bb-e7-bb-93.md","hash":"93e120ad34e9256698273e381d062a0791f7dc9a","modified":1553999512252},{"_id":"source/_posts/HTML-CSS知识补充.md","hash":"1d73cead63b868816f520c3f3b89983b859b8c6e","modified":1553999512253},{"_id":"source/_posts/CSS布局.md","hash":"48df540519901f4705a0f4185e5290bb7f5acbe0","modified":1553999512252},{"_id":"source/_posts/JS中的位操作符.md","hash":"dbb907b8d7e4940ce27a20f1af8797bb384825b0","modified":1553999512254},{"_id":"source/_posts/JS中的继承.md","hash":"a450da880ca135767eb57e83c32ee8e08e62e968","modified":1553999512254},{"_id":"source/_posts/Lodash-分析学习.md","hash":"738a6ca6ee1937b3ead083c71e2dffe1ddbd1dc6","modified":1553999512255},{"_id":"source/_posts/babel初探.md","hash":"238a4a24d605f7c526b299cc3171b7ba9b0a220f","modified":1555813282587},{"_id":"source/_posts/Regex-Golf闯关记录.md","hash":"dc89262957ebd7985d06818174f8ff3ea4807cb9","modified":1554455852147},{"_id":"source/_posts/css遗漏知识总结.md","hash":"d6b1fb830fd1a8a35fcc573f23694772d365ee83","modified":1555813282588},{"_id":"source/_posts/e4-b8-80-e4-ba-9b-e5-b8-b8-e8-a7-81-e7-9a-84-e9-9d-a2-e8-af-95-e9-a2-98.md","hash":"a6960b03e2518ebf1ff3dee3fec37e5c07a91772","modified":1551958778541},{"_id":"source/_posts/http缓存.md","hash":"b14af0f8a2a47346fbd939f2b48fc67f7212a11d","modified":1553999512255},{"_id":"source/_posts/js-错误捕获总结.md","hash":"f3c10cc75d26273c672519f3c121a15369a805f6","modified":1555813282588},{"_id":"source/_posts/js中的this.md","hash":"6712326902fae565498ffc7903b327f827737924","modified":1553999512255},{"_id":"source/_posts/js函数式编程学习.md","hash":"5f8fa59de4bea986860695cf90431df249fedff6","modified":1552399738441},{"_id":"source/_posts/js遗漏知识总结.md","hash":"31ab2669e7ea83059f9bb43286f62591707b7265","modified":1555813282589},{"_id":"source/_posts/to-be-my-hero.md","hash":"fb03ee3205e7585cd9fe246b67a9be3c260007ba","modified":1553999512256},{"_id":"source/_posts/what-am-i-thinking.md","hash":"ccb06bc9133e494e5a9533a6ea1c3a71214d9fd0","modified":1551958778542},{"_id":"source/_posts/关于跨域.md","hash":"d6786478b3c035ed28ea78628adf257aef246fc0","modified":1554432112699},{"_id":"source/_posts/几道面试题的知识总结.md","hash":"bdd509e9a9a1f2949d2c984784cdc8fdf3426393","modified":1552996609834},{"_id":"source/_posts/几种常见的递归函数.md","hash":"0eae821fd90a17dc2ff7cbe5eee0d012949d8f1f","modified":1553999512256},{"_id":"source/_posts/如何使用hexo-新手向.md","hash":"17da7c6c1a0b7a182f443055633e6766dd4c92f3","modified":1551958778542},{"_id":"source/_posts/普通图层和复合图层.md","hash":"e0d3349a45d0871f537159aa763f4d07550e2e1f","modified":1553999512256},{"_id":"source/_posts/正则表达式.md","hash":"99b9d02eaf5f5affa736a532f5ac995e7d551384","modified":1555813282589},{"_id":"source/_posts/理解Promise.md","hash":"4ff059201c5e12877a7ce0a390675a7e7507b1cf","modified":1553999512257},{"_id":"source/_posts/疯狂的函数.md","hash":"ae0b5a9b9c0af7e53571cfc697ebede98b3ed808","modified":1553999512258},{"_id":"source/_posts/置顶文章.md","hash":"cefbfb1ddb409545cf84d91aa0747a64490ca00f","modified":1553999512258},{"_id":"source/_posts/计算机基础知识补充.md","hash":"0b40141f2aed5e910f6999c2067dba84e865a75f","modified":1555813282589},{"_id":"source/tags/index.md","hash":"7bbce07dcd7f29bac3f8a512ca18e9d5d6de0978","modified":1553999512259},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1551958778568},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b56c01cdfc6ee7ffea8a8a9fa149263f368caef6","modified":1551958778568},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"37bd0ec1d655c601946fc5f5ac2fe8ed1e529b77","modified":1551958778568},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1551958778571},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1551958778571},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1551958778571},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1551958778571},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1551958778572},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1551958778572},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1551958778572},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1551958778572},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1551958778572},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1551958778573},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1551958778573},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1551958778573},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1551958778573},{"_id":"themes/next/layout/_layout.swig","hash":"06b1eab2e00273e0b94bd32dc682bd92c1e0a747","modified":1551958778574},{"_id":"themes/next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1551958778585},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1551958778585},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1551958778585},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1551958778585},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1551958778586},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1551958778586},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1551958778586},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1551958778586},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1551958778587},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1551958778637},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1551958778637},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1551958778637},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778605},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1551958778573},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1551958778574},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1551958778574},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1551958778574},{"_id":"themes/next/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1551958778575},{"_id":"themes/next/layout/_macro/post.swig","hash":"64578961ce14638ec725f4a0cc529fed174bb1a7","modified":1552996609835},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1551958778575},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1551958778575},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1551958778576},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1551958778576},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1551958778576},{"_id":"themes/next/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1551958778576},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1551958778576},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1551958778577},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1551958778577},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1551958778578},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1551958778579},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1551958778579},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1551958778583},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1551958778583},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1551958778583},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1551958778583},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1551958778584},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1551958778584},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1551958778605},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1551958778587},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1551958778587},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1551958778587},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1551958778587},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1551958778588},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1551958778588},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1551958778588},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1551958778588},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1551958778588},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1551958778606},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551958778606},{"_id":"themes/next/source/images/avatar.jpg","hash":"15f19891928a9a86fef4e6b8766f451a4f32e4d9","modified":1551958778606},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1551958778606},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1551958778606},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1551958778607},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1551958778607},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1551958778607},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1551958778607},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1551958778607},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551958778607},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551958778608},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1551958778608},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1551958778608},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551958778608},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778579},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778579},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778600},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778600},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778601},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778605},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551958778605},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1551958778576},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1551958778576},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1551958778577},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1551958778577},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1551958778577},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1551958778578},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1551958778578},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1551958778578},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1551958778578},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1551958778579},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1551958778579},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1551958778579},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1551958778580},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1551958778580},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1551958778580},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1551958778580},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1551958778581},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1551958778580},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1551958778581},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1551958778581},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1551958778581},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1551958778581},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1551958778582},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1551958778581},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1551958778582},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1551958778582},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1551958778582},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1551958778582},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1551958778583},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1551958778583},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1551958778585},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1551958778584},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1551958778584},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1551958778585},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1551958778600},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1551958778600},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1551958778600},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1551958778601},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1551958778604},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1551958778605},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1551958778605},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1551958778605},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1551958778608},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1551958778609},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1551958778609},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1551958778609},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1551958778609},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1551958778609},{"_id":"themes/next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1551958778609},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1551958778610},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1551958778610},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1551958778610},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1551958778610},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1551958778616},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1551958778613},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1551958778616},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1551958778619},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1551958778619},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1551958778619},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1551958778619},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1551958778620},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1551958778620},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1551958778620},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1551958778621},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1551958778621},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1551958778627},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1551958778628},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1551958778628},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1551958778628},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1551958778628},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1551958778628},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1551958778628},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1551958778629},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1551958778630},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1551958778630},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1551958778631},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1551958778631},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1551958778631},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1551958778634},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1551958778635},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1551958778636},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1551958778636},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1551958778636},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1551958778627},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1551958778584},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1551958778584},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1551958778589},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1551958778589},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1551958778589},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1551958778589},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1551958778589},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1551958778596},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1551958778599},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2915df7152ea095a6290ef69157fd67669e0e793","modified":1551958778599},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1551958778599},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1551958778599},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1551958778600},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1551958778600},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1551958778600},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1551958778601},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1551958778601},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1551958778601},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1551958778601},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1551958778601},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1551958778602},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1551958778602},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1551958778602},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1551958778603},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1551958778604},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1551958778604},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1551958778604},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1551958778604},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1551958778604},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1551958778610},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1551958778612},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1551958778613},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1551958778613},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1551958778616},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1551958778616},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1551958778618},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1551958778618},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1551958778618},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1551958778620},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1551958778620},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1551958778621},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1551958778622},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1551958778622},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1551958778634},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1551958778634},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1551958778612},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551958778626},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551958778626},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1551958778635},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1551958778591},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1551958778591},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1551958778591},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1551958778591},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1551958778591},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1551958778590},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1551958778596},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1551958778596},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1551958778595},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1551958778596},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1551958778592},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1551958778593},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"51eca243220cf57133a4becae9b78514bcfdc723","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1551958778594},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1551958778596},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1551958778596},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1551958778597},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1551958778598},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1551958778599},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1551958778599},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1551958778602},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1551958778602},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1551958778603},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1551958778611},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1551958778611},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1551958778611},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1551958778611},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1551958778617},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1551958778618},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1551958778618},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1551958778618},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551958778623},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1551958778623},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1551958778626},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1551958778615},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1551958778634},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1551958778624},{"_id":"source/CNAME","hash":"8f746c45fd197d839e8b535a062fb5c1b73ededa","modified":1555813568654},{"_id":"public/tags/index.html","hash":"0ac60651b7b256f4a2996b53beb4f3535b3c9046","modified":1555813743388},{"_id":"public/2019/04/05/Regex-Golf闯关记录/index.html","hash":"b8ed6dcbe8791b9979232bcfd1e3fff9d9db5ee0","modified":1555813743388},{"_id":"public/2019/03/27/http缓存/index.html","hash":"f5eaacc5fffbfef23af149ce95f266ee82193c70","modified":1555813743388},{"_id":"public/2019/03/13/HTML-CSS知识补充/index.html","hash":"2bc50659e1899d9a4cd872c4d89d099bb43c93b9","modified":1555813743389},{"_id":"public/2019/03/07/置顶文章/index.html","hash":"ccadbbd62fef76a5d0d7c09a9507e483cf21ff57","modified":1555813743389},{"_id":"public/2019/03/07/js函数式编程学习/index.html","hash":"556b5b469b9eee93c6d02408f600286f82f2b4dc","modified":1555813743389},{"_id":"public/2019/03/07/Lodash-分析学习/index.html","hash":"c59851bf19980286f825694e738c3593d80b1a31","modified":1555813743389},{"_id":"public/2019/01/08/what-am-i-thinking/index.html","hash":"1d221c32f2824aa2a78c281325436aaeee7c4960","modified":1555813743389},{"_id":"public/2019/01/08/e4-b8-80-e4-ba-9b-e5-b8-b8-e8-a7-81-e7-9a-84-e9-9d-a2-e8-af-95-e9-a2-98/index.html","hash":"14e7c4a1abd382914124ef5bb74d756ef327f6eb","modified":1555813743389},{"_id":"public/2018/11/20/to-be-my-hero/index.html","hash":"9570c1095c88d335e4e02fc473d8668d5783c66c","modified":1555813743389},{"_id":"public/archives/index.html","hash":"776b560f81bb04a13220def927d1723cdce9cf62","modified":1555813743389},{"_id":"public/archives/page/2/index.html","hash":"ac5e1493f9f162b181b434d3670895e691117ca0","modified":1555813743389},{"_id":"public/archives/page/3/index.html","hash":"0e8d64fc6f16cd801bffba0aa9f576e131d7dd1f","modified":1555813743389},{"_id":"public/archives/2018/index.html","hash":"040ab4921b7faaca9d78dda7754e8c7f5ef88ec7","modified":1555813743389},{"_id":"public/archives/2018/11/index.html","hash":"926c52284b4685c368aec93c2a8ca4765c1279eb","modified":1555813743389},{"_id":"public/archives/2019/index.html","hash":"f74f947b073721fef17ba19e493cc2402fe7aaac","modified":1555813743389},{"_id":"public/archives/2019/page/2/index.html","hash":"e0b5c3ac157777b7e5d7580d507b9eab0ea36802","modified":1555813743389},{"_id":"public/archives/2019/page/3/index.html","hash":"a1b545f566f88788a62614f73f9e2443944662b3","modified":1555813743389},{"_id":"public/archives/2019/01/index.html","hash":"f0c0bbd84d06c8011b7aac52364c555fb5b2421e","modified":1555813743389},{"_id":"public/archives/2019/02/index.html","hash":"8ca0c67550c4a80247b4a6f79ff3fa5b326d8510","modified":1555813743389},{"_id":"public/archives/2019/03/index.html","hash":"91f8547d7ac86db04ec985e9dfe153d5cc611720","modified":1555813743389},{"_id":"public/archives/2019/03/page/2/index.html","hash":"43654b2946893ac4d858fb1286758b0443e60364","modified":1555813743389},{"_id":"public/archives/2019/04/index.html","hash":"72bf4508afb2e7d909e477fb2417761a05139e78","modified":1555813743389},{"_id":"public/tags/总结/index.html","hash":"0bcf4e0568de19add1dc5bedbb4eb653d22120fc","modified":1555813743389},{"_id":"public/tags/css/index.html","hash":"c1aa56bf1d82763f71669543f98c1b1c19206e18","modified":1555813743389},{"_id":"public/tags/http/index.html","hash":"606f35e836083bbdaaf389301a59c3fa8e939027","modified":1555813743389},{"_id":"public/tags/js/index.html","hash":"72657f31756052fb53b0f94ab556b2971dfa8faf","modified":1555813743389},{"_id":"public/tags/JS/index.html","hash":"dc947def879eaa278993919c1d7affd3ccd713b3","modified":1555813743390},{"_id":"public/tags/杂文/index.html","hash":"4d177d50e15ecbee875b35010e7f00ba6a61960e","modified":1555813743391},{"_id":"public/tags/算法/index.html","hash":"3b3c8418d5e62c0d8758b57a97657fd5f73d208a","modified":1555813743391},{"_id":"public/tags/正则/index.html","hash":"72030a53333fae9d1698e53134213fd91a4c8a48","modified":1555813743391},{"_id":"public/tags/基础/index.html","hash":"4679d32bef94474aac934a4f93097880ee969ca2","modified":1555813743391},{"_id":"public/categories/未分类/index.html","hash":"5c8bfa2a785090c2cc328199c4f062359534a1a6","modified":1555813743391},{"_id":"public/categories/笔记/index.html","hash":"7211b16106b45e90ad7ddfe5be3c311668ed36b2","modified":1555813743391},{"_id":"public/categories/总结/index.html","hash":"6387b6123475ef669f966aa7617a61cc4add12ee","modified":1555813743391},{"_id":"public/categories/杂文/index.html","hash":"e07e693641f30ed645241100dd2cc3c92cc16c72","modified":1555813743391},{"_id":"public/2019/04/18/babel初探/index.html","hash":"542a3df3f5fadf7cc491fc8941a5754f16d7f439","modified":1555813743391},{"_id":"public/2019/04/15/js-错误捕获总结/index.html","hash":"638cb5078f3e469e09fe07cfded3b2d02b30359b","modified":1555813743392},{"_id":"public/2019/04/09/js遗漏知识总结/index.html","hash":"ffa6623ef46129e583b3454644409cd95be4a055","modified":1555813743392},{"_id":"public/2019/04/03/css遗漏知识总结/index.html","hash":"9d7719096d9b22162cbc742e32b18b82976e5481","modified":1555813743392},{"_id":"public/2019/03/29/普通图层和复合图层/index.html","hash":"c41bb91f6ff9847e1ee72aeabd63f02971a5c2c5","modified":1555813743392},{"_id":"public/2019/03/25/几种常见的递归函数/index.html","hash":"f4efa72160ddc53b1bf633bb938a68017334471d","modified":1555813743392},{"_id":"public/2019/03/19/关于跨域/index.html","hash":"ef40eb1d7b14d93bc8bec5ae62e6be004a6491dc","modified":1555813743392},{"_id":"public/2019/03/18/理解Promise/index.html","hash":"d0b2c388305493a654c1383b021cd26e41e34608","modified":1555813743392},{"_id":"public/2019/03/14/js中的this/index.html","hash":"5f6d2a14d59249e272dcacab0b24ae3c350c380f","modified":1555813743392},{"_id":"public/2019/03/13/CSS布局/index.html","hash":"9077321ce74f9d7be399c381e5beb8cc00424c45","modified":1555813743392},{"_id":"public/2019/03/12/正则表达式/index.html","hash":"c3b968491811b2e59a280361eaec64f690ac7de3","modified":1555813743392},{"_id":"public/2019/03/07/计算机基础知识补充/index.html","hash":"21737485babbac3f88273ff57a443fbdc83f6b96","modified":1555813743392},{"_id":"public/2019/03/06/几道面试题的知识总结/index.html","hash":"3503986c9a78a364c68fb02f2620a26f38a0b772","modified":1555813743392},{"_id":"public/2019/02/22/疯狂的函数/index.html","hash":"c3daef4c15a46a91f6ad15ad1e9617a2f139e4c8","modified":1555813743392},{"_id":"public/2019/01/10/JS中的继承/index.html","hash":"28e4074c9ad5d5a8d6693c3b3391af388c36c7ac","modified":1555813743392},{"_id":"public/2019/01/09/如何使用hexo-新手向/index.html","hash":"4cc9ae3baeddc596994442c80416a9683250d269","modified":1555813743392},{"_id":"public/2019/01/07/JS中的位操作符/index.html","hash":"a05f13d2bf5edf18e646d8a4c1c4202b002744f6","modified":1555813743392},{"_id":"public/2019/01/01/2018-e5-b9-b4-e5-b9-b4-e7-bb-88-e6-80-bb-e7-bb-93/index.html","hash":"7860716ad8d5df2a110301c261854410623eeec7","modified":1555813743392},{"_id":"public/index.html","hash":"2c29e69c27ac44215fbd6d0f46008a51b6753a6c","modified":1555813743392},{"_id":"public/page/2/index.html","hash":"72f17c800eaad3ccf51fed9769951b4ded932d2d","modified":1555813743392},{"_id":"public/page/3/index.html","hash":"4d4d392d252f51ae45966b618d2b14f444d9358d","modified":1555813743392},{"_id":"public/CNAME","hash":"8f746c45fd197d839e8b535a062fb5c1b73ededa","modified":1555813743396}],"Category":[{"name":"未分类","_id":"cjuqb3fhy00027dxqjhqdk698"},{"name":"笔记","_id":"cjuqb3fi600077dxq628myzek"},{"name":"总结","_id":"cjuqb3fia000c7dxqxvgolpqm"},{"name":"杂文","_id":"cjuqb3fiy00147dxqtspz17gl"}],"Data":[],"Page":[{"title":"tags","date":"2019-03-29T09:17:45.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-03-29 17:17:45\ntype: \"tags\"\n---\n","updated":"2019-03-31T02:31:52.259Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjuqb3fnw001v7dxqgq0uknim","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"HTTP相关博客","url":"31.html","id":"31","_content":"\n\\# HTTP相关博客\n\n\\### HTTP 请求\n\nHTTP请求报文由4部分组成\n\n第一部分里面包括了请求的动作和路劲以及请求版本\n\n第二部分由各种各样的键值对组成，包含了各种请求的信息以及对返回的描述\n\n第三部分则总是换行符\n\n第四部分就是请求之后的返回的内容\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n\\### HTTP 响应\n\nHTTP响应也是由4部分组成\n\n和请求的返回差异在于，第一部分的返回会有特定含义的状态码，以及状态的简短解释\n\n以及第四部分返回的是相应的内容\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n\\#### 使用chrome查看请求内容\n\n右键打开检查，点击network\n\nheaders中可以查看请求或者相应的第一二部分，Response Headers是响应的。Request Headers是请求的。\n\n第四部分都在Response里面可以查看\n\n\\-\\-\\-\\-\\-\\-\\-\n\n\\### curl命令的使用\n\n\\> curl是一个利用URL语法在命令行下工作的文件传输工具,curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化\n\n常用的：\n\n可以指定用什么命令，选项 -X get/post...\n\n-d HTTP POST方式传送数据\n\n-s silent模式\n\n参数则是目标的网址","source":"_drafts/HTTP相关博客.md","raw":"---\ntitle: HTTP相关博客\nurl: 31.html\nid: 31\ncategories:\n  - 未分类\ntags:\n---\n\n\\# HTTP相关博客\n\n\\### HTTP 请求\n\nHTTP请求报文由4部分组成\n\n第一部分里面包括了请求的动作和路劲以及请求版本\n\n第二部分由各种各样的键值对组成，包含了各种请求的信息以及对返回的描述\n\n第三部分则总是换行符\n\n第四部分就是请求之后的返回的内容\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n\\### HTTP 响应\n\nHTTP响应也是由4部分组成\n\n和请求的返回差异在于，第一部分的返回会有特定含义的状态码，以及状态的简短解释\n\n以及第四部分返回的是相应的内容\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n\\#### 使用chrome查看请求内容\n\n右键打开检查，点击network\n\nheaders中可以查看请求或者相应的第一二部分，Response Headers是响应的。Request Headers是请求的。\n\n第四部分都在Response里面可以查看\n\n\\-\\-\\-\\-\\-\\-\\-\n\n\\### curl命令的使用\n\n\\> curl是一个利用URL语法在命令行下工作的文件传输工具,curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化\n\n常用的：\n\n可以指定用什么命令，选项 -X get/post...\n\n-d HTTP POST方式传送数据\n\n-s silent模式\n\n参数则是目标的网址","slug":"HTTP相关博客","published":0,"date":"2019-03-07T11:39:38.540Z","updated":"2019-03-07T11:39:38.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fho00007dxqrozui855","content":"<p># HTTP相关博客</p>\n<p>### HTTP 请求</p>\n<p>HTTP请求报文由4部分组成</p>\n<p>第一部分里面包括了请求的动作和路劲以及请求版本</p>\n<p>第二部分由各种各样的键值对组成，包含了各种请求的信息以及对返回的描述</p>\n<p>第三部分则总是换行符</p>\n<p>第四部分就是请求之后的返回的内容</p>\n<p>---------</p>\n<p>### HTTP 响应</p>\n<p>HTTP响应也是由4部分组成</p>\n<p>和请求的返回差异在于，第一部分的返回会有特定含义的状态码，以及状态的简短解释</p>\n<p>以及第四部分返回的是相应的内容</p>\n<p>-----------</p>\n<p>#### 使用chrome查看请求内容</p>\n<p>右键打开检查，点击network</p>\n<p>headers中可以查看请求或者相应的第一二部分，Response Headers是响应的。Request Headers是请求的。</p>\n<p>第四部分都在Response里面可以查看</p>\n<p>-------</p>\n<p>### curl命令的使用</p>\n<p>> curl是一个利用URL语法在命令行下工作的文件传输工具,curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化</p>\n<p>常用的：</p>\n<p>可以指定用什么命令，选项 -X get/post…</p>\n<p>-d HTTP POST方式传送数据</p>\n<p>-s silent模式</p>\n<p>参数则是目标的网址</p>\n","site":{"data":{}},"excerpt":"","more":"<p># HTTP相关博客</p>\n<p>### HTTP 请求</p>\n<p>HTTP请求报文由4部分组成</p>\n<p>第一部分里面包括了请求的动作和路劲以及请求版本</p>\n<p>第二部分由各种各样的键值对组成，包含了各种请求的信息以及对返回的描述</p>\n<p>第三部分则总是换行符</p>\n<p>第四部分就是请求之后的返回的内容</p>\n<p>---------</p>\n<p>### HTTP 响应</p>\n<p>HTTP响应也是由4部分组成</p>\n<p>和请求的返回差异在于，第一部分的返回会有特定含义的状态码，以及状态的简短解释</p>\n<p>以及第四部分返回的是相应的内容</p>\n<p>-----------</p>\n<p>#### 使用chrome查看请求内容</p>\n<p>右键打开检查，点击network</p>\n<p>headers中可以查看请求或者相应的第一二部分，Response Headers是响应的。Request Headers是请求的。</p>\n<p>第四部分都在Response里面可以查看</p>\n<p>-------</p>\n<p>### curl命令的使用</p>\n<p>> curl是一个利用URL语法在命令行下工作的文件传输工具,curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化</p>\n<p>常用的：</p>\n<p>可以指定用什么命令，选项 -X get/post…</p>\n<p>-d HTTP POST方式传送数据</p>\n<p>-s silent模式</p>\n<p>参数则是目标的网址</p>\n"},{"title":"Promise的实现","url":"57.html","id":"57","_content":"\n> 一点预热 console.log的使用技巧\n\n    //console.log在函数中直接使用, 就会默认打印出函数的所有返回值\n    let p = new Promise((resolve, reject) => {\n        resolve('hello')\n    })\n    p.then((res) => {\n        console.log(res)\n    })\n    // equals\n    p.then(console.log)\n    //还是可以节约很多的代码的😂😂\n    \n\n然而 今天我才发现这根本不是啥console.log的特性..","source":"_drafts/Promise的实现.md","raw":"---\ntitle: Promise的实现\nurl: 57.html\nid: 57\ncategories:\n  - 笔记\ntags:\n---\n\n> 一点预热 console.log的使用技巧\n\n    //console.log在函数中直接使用, 就会默认打印出函数的所有返回值\n    let p = new Promise((resolve, reject) => {\n        resolve('hello')\n    })\n    p.then((res) => {\n        console.log(res)\n    })\n    // equals\n    p.then(console.log)\n    //还是可以节约很多的代码的😂😂\n    \n\n然而 今天我才发现这根本不是啥console.log的特性..","slug":"Promise的实现","published":0,"date":"2019-03-07T11:39:38.540Z","updated":"2019-03-07T11:39:38.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fht00017dxqvvr3nc5e","content":"<blockquote>\n<p>一点预热 console.log的使用技巧</p>\n</blockquote>\n<pre><code>//console.log在函数中直接使用, 就会默认打印出函数的所有返回值\nlet p = new Promise((resolve, reject) =&gt; {\n    resolve(&apos;hello&apos;)\n})\np.then((res) =&gt; {\n    console.log(res)\n})\n// equals\np.then(console.log)\n//还是可以节约很多的代码的😂😂\n</code></pre><p>然而 今天我才发现这根本不是啥console.log的特性..</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一点预热 console.log的使用技巧</p>\n</blockquote>\n<pre><code>//console.log在函数中直接使用, 就会默认打印出函数的所有返回值\nlet p = new Promise((resolve, reject) =&gt; {\n    resolve(&apos;hello&apos;)\n})\np.then((res) =&gt; {\n    console.log(res)\n})\n// equals\np.then(console.log)\n//还是可以节约很多的代码的😂😂\n</code></pre><p>然而 今天我才发现这根本不是啥console.log的特性..</p>\n"},{"title":"2018年年终总结","url":"47.html","id":"47","date":"2019-01-01T14:24:53.000Z","_content":"\n2011 2014 2018 初中，高中，大学，就是这三个数字。现在2018也过完了，我的学生生涯也就结束了。这一年真的经历的很多呢。\n\n[![](https://i.loli.net/2019/01/01/5c2b7744327a6.jpg)](https://i.loli.net/2019/01/01/5c2b7744327a6.jpg)\n-------------------------------------------------------------------------------------------------------\n\n## LOCATION：\n---------\n\n长沙、成都、深圳、西安、无锡、苏州、香港、珠海 \n在6月回校期间，啵啵来找了我，还一起去了一趟西安。第一次一起和啵啵出去旅游，安排的密密麻麻。有点充实。 \n刚去看了一眼days matter 来深圳其实也才308天，而且今年也是第一次来深圳，但是现在就是莫名的觉得自己都是个深圳人了。怎么说吧，深圳啊，基本上没有我没有去过的地方了。基本把足迹留在了深圳的每一个地方。当然，这得感谢小许。 \n无锡，完全去的时候心情沉重，是去加班的，而且还牺牲了国庆7天和啵啵玩的时间。 \n在无锡的时候，国庆就顺带去了苏州。 \n年末，啵啵回到深圳，一起去了趟香港迪士尼。 \n公司组织去了珠海长隆 \n长沙，成都，就不赘述了。\n\n## EVENT：\n------\n\n上班、毕业、见家长 \n\n年初来深圳上班的时候，还是对职场充满了好奇的。可是，也不过如此，很快就习惯了。 \n在去年年底，就已经觉得电子科大似乎就和自己已经没有啥关系了，5月回学校，又呆了一个半月，解决了毕业的相关事项后，就毕业了。没有什么，就是结束了而已，我想了想什么可以感动自己的，好像没有。 啵啵父母一直都是在深圳的，刚来的时候没有这个念头，然后12月啵啵从学校回来之后，这件事就被提上了日程。在啵啵生日前一周，一起吃了个饭。并且，这连着两周周末都有趣她家。觉得自己表现的很不好，有点过于紧张，不知道该做什么好。\n\n## GOODS\n-----\n\n[![](https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg)](https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg) AirPods、 apple watch4，空军一号、reebok pure黑白 \n\n这一年虽然自己开始赚钱了，但是赚的有点过于少了。没有买什么东西，耳机是有线是在是太难的用了就换了，然后手表是见啵啵妈妈的时候送的。鞋就是5月和12月，自己买的。和啵啵送的。\n\n## AFFAIR\n------\n\n400多天了，我们现在还能这么好，而且完全的习惯对方的存在，并且对对方的生活情绪完全的了解，是我一开始很难预料到的。\n\n2018最幸运的还是和你在一起。\n\n## skill \n-----------\n\n为什么会去做前端，是一开始冲忙决定的。没有想到这就成为了现在的工作领域。我还是想把它做好的，但是还是遗憾自己开始的这么晚。我始终坚信着自己的，但是还是会踟蹰于自己的前进。竟然热爱，只有坚持。\n\n## MUSIC & FILM & ANIME & VARIETY SHOW\n-----------------------------------\n\n任然是单曲着周杰伦，最近有迷上电音。（续费了QQ音乐，突然后悔了，想用apple music了。） \n电影看了蛮多，基本都是电影院看的，自己平常在家倒是看得蛮少的。 \n动漫基本没有怎么看了，猪头少年还没有看完，我们的英雄学院也有点快忘了。 \n综艺都是看了不少，吃饭必备的赶脚，吐槽大会，101。其他的都是偶尔看看。","source":"_posts/2018-e5-b9-b4-e5-b9-b4-e7-bb-88-e6-80-bb-e7-bb-93.md","raw":"---\ntitle: 2018年年终总结\nurl: 47.html\nid: 47\ncategories:\n  - 总结\ndate: 2019-01-01 22:24:53\ntags: 总结\n---\n\n2011 2014 2018 初中，高中，大学，就是这三个数字。现在2018也过完了，我的学生生涯也就结束了。这一年真的经历的很多呢。\n\n[![](https://i.loli.net/2019/01/01/5c2b7744327a6.jpg)](https://i.loli.net/2019/01/01/5c2b7744327a6.jpg)\n-------------------------------------------------------------------------------------------------------\n\n## LOCATION：\n---------\n\n长沙、成都、深圳、西安、无锡、苏州、香港、珠海 \n在6月回校期间，啵啵来找了我，还一起去了一趟西安。第一次一起和啵啵出去旅游，安排的密密麻麻。有点充实。 \n刚去看了一眼days matter 来深圳其实也才308天，而且今年也是第一次来深圳，但是现在就是莫名的觉得自己都是个深圳人了。怎么说吧，深圳啊，基本上没有我没有去过的地方了。基本把足迹留在了深圳的每一个地方。当然，这得感谢小许。 \n无锡，完全去的时候心情沉重，是去加班的，而且还牺牲了国庆7天和啵啵玩的时间。 \n在无锡的时候，国庆就顺带去了苏州。 \n年末，啵啵回到深圳，一起去了趟香港迪士尼。 \n公司组织去了珠海长隆 \n长沙，成都，就不赘述了。\n\n## EVENT：\n------\n\n上班、毕业、见家长 \n\n年初来深圳上班的时候，还是对职场充满了好奇的。可是，也不过如此，很快就习惯了。 \n在去年年底，就已经觉得电子科大似乎就和自己已经没有啥关系了，5月回学校，又呆了一个半月，解决了毕业的相关事项后，就毕业了。没有什么，就是结束了而已，我想了想什么可以感动自己的，好像没有。 啵啵父母一直都是在深圳的，刚来的时候没有这个念头，然后12月啵啵从学校回来之后，这件事就被提上了日程。在啵啵生日前一周，一起吃了个饭。并且，这连着两周周末都有趣她家。觉得自己表现的很不好，有点过于紧张，不知道该做什么好。\n\n## GOODS\n-----\n\n[![](https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg)](https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg) AirPods、 apple watch4，空军一号、reebok pure黑白 \n\n这一年虽然自己开始赚钱了，但是赚的有点过于少了。没有买什么东西，耳机是有线是在是太难的用了就换了，然后手表是见啵啵妈妈的时候送的。鞋就是5月和12月，自己买的。和啵啵送的。\n\n## AFFAIR\n------\n\n400多天了，我们现在还能这么好，而且完全的习惯对方的存在，并且对对方的生活情绪完全的了解，是我一开始很难预料到的。\n\n2018最幸运的还是和你在一起。\n\n## skill \n-----------\n\n为什么会去做前端，是一开始冲忙决定的。没有想到这就成为了现在的工作领域。我还是想把它做好的，但是还是遗憾自己开始的这么晚。我始终坚信着自己的，但是还是会踟蹰于自己的前进。竟然热爱，只有坚持。\n\n## MUSIC & FILM & ANIME & VARIETY SHOW\n-----------------------------------\n\n任然是单曲着周杰伦，最近有迷上电音。（续费了QQ音乐，突然后悔了，想用apple music了。） \n电影看了蛮多，基本都是电影院看的，自己平常在家倒是看得蛮少的。 \n动漫基本没有怎么看了，猪头少年还没有看完，我们的英雄学院也有点快忘了。 \n综艺都是看了不少，吃饭必备的赶脚，吐槽大会，101。其他的都是偶尔看看。","slug":"2018-e5-b9-b4-e5-b9-b4-e7-bb-88-e6-80-bb-e7-bb-93","published":1,"updated":"2019-03-31T02:31:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fhy00037dxq5klan254","content":"<p>2011 2014 2018 初中，高中，大学，就是这三个数字。现在2018也过完了，我的学生生涯也就结束了。这一年真的经历的很多呢。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a href=\"https://i.loli.net/2019/01/01/5c2b7744327a6.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/01/5c2b7744327a6.jpg\" alt=\"\"></a></h2><h2 id=\"LOCATION：\"><a href=\"#LOCATION：\" class=\"headerlink\" title=\"LOCATION：\"></a>LOCATION：</h2><hr>\n<p>长沙、成都、深圳、西安、无锡、苏州、香港、珠海<br>在6月回校期间，啵啵来找了我，还一起去了一趟西安。第一次一起和啵啵出去旅游，安排的密密麻麻。有点充实。<br>刚去看了一眼days matter 来深圳其实也才308天，而且今年也是第一次来深圳，但是现在就是莫名的觉得自己都是个深圳人了。怎么说吧，深圳啊，基本上没有我没有去过的地方了。基本把足迹留在了深圳的每一个地方。当然，这得感谢小许。<br>无锡，完全去的时候心情沉重，是去加班的，而且还牺牲了国庆7天和啵啵玩的时间。<br>在无锡的时候，国庆就顺带去了苏州。<br>年末，啵啵回到深圳，一起去了趟香港迪士尼。<br>公司组织去了珠海长隆<br>长沙，成都，就不赘述了。</p>\n<h2 id=\"EVENT：\"><a href=\"#EVENT：\" class=\"headerlink\" title=\"EVENT：\"></a>EVENT：</h2><hr>\n<p>上班、毕业、见家长 </p>\n<p>年初来深圳上班的时候，还是对职场充满了好奇的。可是，也不过如此，很快就习惯了。<br>在去年年底，就已经觉得电子科大似乎就和自己已经没有啥关系了，5月回学校，又呆了一个半月，解决了毕业的相关事项后，就毕业了。没有什么，就是结束了而已，我想了想什么可以感动自己的，好像没有。 啵啵父母一直都是在深圳的，刚来的时候没有这个念头，然后12月啵啵从学校回来之后，这件事就被提上了日程。在啵啵生日前一周，一起吃了个饭。并且，这连着两周周末都有趣她家。觉得自己表现的很不好，有点过于紧张，不知道该做什么好。</p>\n<h2 id=\"GOODS\"><a href=\"#GOODS\" class=\"headerlink\" title=\"GOODS\"></a>GOODS</h2><hr>\n<p><a href=\"https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg\" alt=\"\"></a> AirPods、 apple watch4，空军一号、reebok pure黑白 </p>\n<p>这一年虽然自己开始赚钱了，但是赚的有点过于少了。没有买什么东西，耳机是有线是在是太难的用了就换了，然后手表是见啵啵妈妈的时候送的。鞋就是5月和12月，自己买的。和啵啵送的。</p>\n<h2 id=\"AFFAIR\"><a href=\"#AFFAIR\" class=\"headerlink\" title=\"AFFAIR\"></a>AFFAIR</h2><hr>\n<p>400多天了，我们现在还能这么好，而且完全的习惯对方的存在，并且对对方的生活情绪完全的了解，是我一开始很难预料到的。</p>\n<p>2018最幸运的还是和你在一起。</p>\n<h2 id=\"skill\"><a href=\"#skill\" class=\"headerlink\" title=\"skill\"></a>skill</h2><hr>\n<p>为什么会去做前端，是一开始冲忙决定的。没有想到这就成为了现在的工作领域。我还是想把它做好的，但是还是遗憾自己开始的这么晚。我始终坚信着自己的，但是还是会踟蹰于自己的前进。竟然热爱，只有坚持。</p>\n<h2 id=\"MUSIC-amp-FILM-amp-ANIME-amp-VARIETY-SHOW\"><a href=\"#MUSIC-amp-FILM-amp-ANIME-amp-VARIETY-SHOW\" class=\"headerlink\" title=\"MUSIC &amp; FILM &amp; ANIME &amp; VARIETY SHOW\"></a>MUSIC &amp; FILM &amp; ANIME &amp; VARIETY SHOW</h2><hr>\n<p>任然是单曲着周杰伦，最近有迷上电音。（续费了QQ音乐，突然后悔了，想用apple music了。）<br>电影看了蛮多，基本都是电影院看的，自己平常在家倒是看得蛮少的。<br>动漫基本没有怎么看了，猪头少年还没有看完，我们的英雄学院也有点快忘了。<br>综艺都是看了不少，吃饭必备的赶脚，吐槽大会，101。其他的都是偶尔看看。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2011 2014 2018 初中，高中，大学，就是这三个数字。现在2018也过完了，我的学生生涯也就结束了。这一年真的经历的很多呢。</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a href=\"https://i.loli.net/2019/01/01/5c2b7744327a6.jpg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/01/5c2b7744327a6.jpg\" alt=\"\"></a></h2><h2 id=\"LOCATION：\"><a href=\"#LOCATION：\" class=\"headerlink\" title=\"LOCATION：\"></a>LOCATION：</h2><hr>\n<p>长沙、成都、深圳、西安、无锡、苏州、香港、珠海<br>在6月回校期间，啵啵来找了我，还一起去了一趟西安。第一次一起和啵啵出去旅游，安排的密密麻麻。有点充实。<br>刚去看了一眼days matter 来深圳其实也才308天，而且今年也是第一次来深圳，但是现在就是莫名的觉得自己都是个深圳人了。怎么说吧，深圳啊，基本上没有我没有去过的地方了。基本把足迹留在了深圳的每一个地方。当然，这得感谢小许。<br>无锡，完全去的时候心情沉重，是去加班的，而且还牺牲了国庆7天和啵啵玩的时间。<br>在无锡的时候，国庆就顺带去了苏州。<br>年末，啵啵回到深圳，一起去了趟香港迪士尼。<br>公司组织去了珠海长隆<br>长沙，成都，就不赘述了。</p>\n<h2 id=\"EVENT：\"><a href=\"#EVENT：\" class=\"headerlink\" title=\"EVENT：\"></a>EVENT：</h2><hr>\n<p>上班、毕业、见家长 </p>\n<p>年初来深圳上班的时候，还是对职场充满了好奇的。可是，也不过如此，很快就习惯了。<br>在去年年底，就已经觉得电子科大似乎就和自己已经没有啥关系了，5月回学校，又呆了一个半月，解决了毕业的相关事项后，就毕业了。没有什么，就是结束了而已，我想了想什么可以感动自己的，好像没有。 啵啵父母一直都是在深圳的，刚来的时候没有这个念头，然后12月啵啵从学校回来之后，这件事就被提上了日程。在啵啵生日前一周，一起吃了个饭。并且，这连着两周周末都有趣她家。觉得自己表现的很不好，有点过于紧张，不知道该做什么好。</p>\n<h2 id=\"GOODS\"><a href=\"#GOODS\" class=\"headerlink\" title=\"GOODS\"></a>GOODS</h2><hr>\n<p><a href=\"https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/01/5c2b77dacdb7f.jpeg\" alt=\"\"></a> AirPods、 apple watch4，空军一号、reebok pure黑白 </p>\n<p>这一年虽然自己开始赚钱了，但是赚的有点过于少了。没有买什么东西，耳机是有线是在是太难的用了就换了，然后手表是见啵啵妈妈的时候送的。鞋就是5月和12月，自己买的。和啵啵送的。</p>\n<h2 id=\"AFFAIR\"><a href=\"#AFFAIR\" class=\"headerlink\" title=\"AFFAIR\"></a>AFFAIR</h2><hr>\n<p>400多天了，我们现在还能这么好，而且完全的习惯对方的存在，并且对对方的生活情绪完全的了解，是我一开始很难预料到的。</p>\n<p>2018最幸运的还是和你在一起。</p>\n<h2 id=\"skill\"><a href=\"#skill\" class=\"headerlink\" title=\"skill\"></a>skill</h2><hr>\n<p>为什么会去做前端，是一开始冲忙决定的。没有想到这就成为了现在的工作领域。我还是想把它做好的，但是还是遗憾自己开始的这么晚。我始终坚信着自己的，但是还是会踟蹰于自己的前进。竟然热爱，只有坚持。</p>\n<h2 id=\"MUSIC-amp-FILM-amp-ANIME-amp-VARIETY-SHOW\"><a href=\"#MUSIC-amp-FILM-amp-ANIME-amp-VARIETY-SHOW\" class=\"headerlink\" title=\"MUSIC &amp; FILM &amp; ANIME &amp; VARIETY SHOW\"></a>MUSIC &amp; FILM &amp; ANIME &amp; VARIETY SHOW</h2><hr>\n<p>任然是单曲着周杰伦，最近有迷上电音。（续费了QQ音乐，突然后悔了，想用apple music了。）<br>电影看了蛮多，基本都是电影院看的，自己平常在家倒是看得蛮少的。<br>动漫基本没有怎么看了，猪头少年还没有看完，我们的英雄学院也有点快忘了。<br>综艺都是看了不少，吃饭必备的赶脚，吐槽大会，101。其他的都是偶尔看看。</p>\n"},{"title":"HTML&CSS知识补充","date":"2019-03-13T07:35:34.000Z","_content":"CSS 渐变属性使用\n使用渐变属性(gradient)可以一个元素多种颜色\n```css\ndiv{\n    background-image:linear-gradient(to bottom,red 0%,red 50%,blue 50%,blue 100%)\n}\n```\n因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.\n","source":"_posts/HTML-CSS知识补充.md","raw":"---\ntitle: HTML&CSS知识补充\ndate: 2019-03-13 15:35:34\ntags: css\n---\nCSS 渐变属性使用\n使用渐变属性(gradient)可以一个元素多种颜色\n```css\ndiv{\n    background-image:linear-gradient(to bottom,red 0%,red 50%,blue 50%,blue 100%)\n}\n```\n因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.\n","slug":"HTML-CSS知识补充","published":1,"updated":"2019-03-31T02:31:52.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fi000047dxq7jyy6xvw","content":"<p>CSS 渐变属性使用<br>使用渐变属性(gradient)可以一个元素多种颜色<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:<span class=\"built_in\">linear-gradient</span>(to bottom,red 0%,red 50%,blue 50%,blue 100%)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CSS 渐变属性使用<br>使用渐变属性(gradient)可以一个元素多种颜色<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:<span class=\"built_in\">linear-gradient</span>(to bottom,red 0%,red 50%,blue 50%,blue 100%)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为本身属性是渐变的,所有需要对同一个位置(除了首位之外)需要把结束和开始的颜色都标注出来,就可以达到锐化的效果.</p>\n"},{"title":"JS中的位操作符","url":"61.html","id":"61","date":"2019-01-07T03:39:05.000Z","_content":"\n> 位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.\n\n刚刚看到位操作的英语 bit operation \n\n在看mdn中的Polyfill中,常常可以看到这样的做法: length = length >>> 0 google一下, 在使用 >>>0的时候,基本上保证了参数不会为负数,但是可能会为其他类型的数值,这样就会把其他类型的都变成0.作用和~~是一样的.\n\n>这里再吐槽一句js吧.这设计的啥玩意啊,有点太混乱的了.上面的原因都是位操作符会把参数全部转成32位的2进制的补码进行操作,而且对参数没有限制, 所以是非数组的数值,都被当成了0进行的操作.同时还会忽略掉62位浮点型的精度,所以对于数字也只会保留数字的整数部分.\n\n先总结这样使用的作用 **1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分** \n\n为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: [位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6) \n\n说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算.同时数值在计算机中存储都是用的补码,然后再转回到10进制呈现. \n\n对于负数的操作,记录一下.  当发现数值的首位是1的时候, 说明此时数为负数. 所以就不能直接转成10进制的数值. 需要取反,然后加一(就是补码操作).然后再把**负数符号加上去**.反之,如果本身首位都是0了,则说明是正数, 直接转成10进制就完事了.\n\n**同时在js中,**\n\n 名称 | 操作 | 举例\n ------------ | ------------- | ------------\n<<(左移位)\t | 将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. **左边移出的几位被丢弃.右边多出的空位由0补齐** | 9<<2产生36，因为1001移位2比特向左变为100100，它是36。\n\\>>(带符号右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由原值的最左边数字补齐**. | 9>>2产生2，因为1001移位2位向右变为10，其是2。同样，-9>>2产生-3，由于符号被保留。\n\\>>>(补零右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由0补齐**. | 19>>>2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。\n\n左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. \n\n例如 19 << 2 -> 76 -19 << 2 -> 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 >> 2 -> 4 10010 变成了 100 -> 4 -19 >> 4 -> -5 \n\n-19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -> -5 \n\n两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 >>> 2 -> 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 >>> 2 -> 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0\n\n* * *\n\n接下来再对其他的位操作对理解 先看一道题:\n\n[![](https://i.loli.net/2019/01/07/5c32efafcf701.png)](https://i.loli.net/2019/01/07/5c32efafcf701.png) \n\n大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96),在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -> 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a & b >> 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a & b << 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.\n```js\nfunction tc_add (a, b) {\n    while (b != 0) {\n        let _a = a ^ b\n        let _b = (a & b) << 1\n        a = _a\n        b = _b\n        console.log('a:', a)\n        console.log('b:', b)\n    }\n    return a\n}\nconsole.log(tc_add(9, 5))\n// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算\n```\n\n再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身\n\n> 这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题\n\n题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 \n\n看这个题目, 想法有没有和这个交换变量的题的思想一模一样... 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..\n\n>2019 - 03 - 06 add\n\n### 按位逻辑操作符\n\n>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数:\n\n同时 | & 是js中的位比较符号, 也是对其数的二进制进行的位操作.\n\n| 是或, &是与 , ~ 是非 \n\n举一个使用&的栗子,在 js中的 Node的 API - compareDocumentPosition\n在这个 API中, 返回值都是二进制\n\n`node.compareDocumentPosition( otherNode ) `\n\n返回值 | 含义\n- | -\n1 | 不在同一个文档中\n2 | otherNode 在 node 之前\n4 | otherNode 在 node 之后\n8 | otherNode 包含 node\n16 |  otherNode 被 node 包含\n\n**注意:这个compare是 other和 node之间的关系**\n\n而且,关系并存的情况下,返回的值是和. \n所以,这个地方就是用到的& 来进行判断了.\n\n`node.compareDocumentPosition( otherNode ) & 4`返回的如果是false,则说明other不在 node 之后,反之则反.\n\n~也是按位操作符,按位取反\n对于是数值的情况下, ~x = -(x + 1)\n\n使用情景:\n和indexOf 一起使用, ``` if(~str.indexOf(searchStr)) { // 包含} ```\n\n同时还可以使用 ~~ 将操作符转化成32位有符号正数\n```js\n~~ null // 0\n~~ undefined // 0\n~~ NaN // 0\n~~ {} // 0\n~~ true // 1\n~~ '' // 0\n~~ 'string' // 0\n~~ '1' // 1\n~~ Number.POSITIVE_INFINITY // 0\n\n~~ 1.2 // 1\n~~ -1.2 // -1\n~~ 1.6 // 1\n~~ -1.6 // -1\n~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 32)) // 0\n```","source":"_posts/JS中的位操作符.md","raw":"---\ntitle: JS中的位操作符\ntags: js\nurl: 61.html\nid: 61\ncategories:\n  - 笔记\ndate: 2019-01-07 11:39:05\n---\n\n> 位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.\n\n刚刚看到位操作的英语 bit operation \n\n在看mdn中的Polyfill中,常常可以看到这样的做法: length = length >>> 0 google一下, 在使用 >>>0的时候,基本上保证了参数不会为负数,但是可能会为其他类型的数值,这样就会把其他类型的都变成0.作用和~~是一样的.\n\n>这里再吐槽一句js吧.这设计的啥玩意啊,有点太混乱的了.上面的原因都是位操作符会把参数全部转成32位的2进制的补码进行操作,而且对参数没有限制, 所以是非数组的数值,都被当成了0进行的操作.同时还会忽略掉62位浮点型的精度,所以对于数字也只会保留数字的整数部分.\n\n先总结这样使用的作用 **1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分** \n\n为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: [位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6) \n\n说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算.同时数值在计算机中存储都是用的补码,然后再转回到10进制呈现. \n\n对于负数的操作,记录一下.  当发现数值的首位是1的时候, 说明此时数为负数. 所以就不能直接转成10进制的数值. 需要取反,然后加一(就是补码操作).然后再把**负数符号加上去**.反之,如果本身首位都是0了,则说明是正数, 直接转成10进制就完事了.\n\n**同时在js中,**\n\n 名称 | 操作 | 举例\n ------------ | ------------- | ------------\n<<(左移位)\t | 将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. **左边移出的几位被丢弃.右边多出的空位由0补齐** | 9<<2产生36，因为1001移位2比特向左变为100100，它是36。\n\\>>(带符号右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由原值的最左边数字补齐**. | 9>>2产生2，因为1001移位2位向右变为10，其是2。同样，-9>>2产生-3，由于符号被保留。\n\\>>>(补零右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由0补齐**. | 19>>>2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。\n\n左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. \n\n例如 19 << 2 -> 76 -19 << 2 -> 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 >> 2 -> 4 10010 变成了 100 -> 4 -19 >> 4 -> -5 \n\n-19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -> -5 \n\n两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 >>> 2 -> 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 >>> 2 -> 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0\n\n* * *\n\n接下来再对其他的位操作对理解 先看一道题:\n\n[![](https://i.loli.net/2019/01/07/5c32efafcf701.png)](https://i.loli.net/2019/01/07/5c32efafcf701.png) \n\n大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96),在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -> 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a & b >> 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a & b << 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.\n```js\nfunction tc_add (a, b) {\n    while (b != 0) {\n        let _a = a ^ b\n        let _b = (a & b) << 1\n        a = _a\n        b = _b\n        console.log('a:', a)\n        console.log('b:', b)\n    }\n    return a\n}\nconsole.log(tc_add(9, 5))\n// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算\n```\n\n再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身\n\n> 这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题\n\n题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 \n\n看这个题目, 想法有没有和这个交换变量的题的思想一模一样... 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..\n\n>2019 - 03 - 06 add\n\n### 按位逻辑操作符\n\n>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数:\n\n同时 | & 是js中的位比较符号, 也是对其数的二进制进行的位操作.\n\n| 是或, &是与 , ~ 是非 \n\n举一个使用&的栗子,在 js中的 Node的 API - compareDocumentPosition\n在这个 API中, 返回值都是二进制\n\n`node.compareDocumentPosition( otherNode ) `\n\n返回值 | 含义\n- | -\n1 | 不在同一个文档中\n2 | otherNode 在 node 之前\n4 | otherNode 在 node 之后\n8 | otherNode 包含 node\n16 |  otherNode 被 node 包含\n\n**注意:这个compare是 other和 node之间的关系**\n\n而且,关系并存的情况下,返回的值是和. \n所以,这个地方就是用到的& 来进行判断了.\n\n`node.compareDocumentPosition( otherNode ) & 4`返回的如果是false,则说明other不在 node 之后,反之则反.\n\n~也是按位操作符,按位取反\n对于是数值的情况下, ~x = -(x + 1)\n\n使用情景:\n和indexOf 一起使用, ``` if(~str.indexOf(searchStr)) { // 包含} ```\n\n同时还可以使用 ~~ 将操作符转化成32位有符号正数\n```js\n~~ null // 0\n~~ undefined // 0\n~~ NaN // 0\n~~ {} // 0\n~~ true // 1\n~~ '' // 0\n~~ 'string' // 0\n~~ '1' // 1\n~~ Number.POSITIVE_INFINITY // 0\n\n~~ 1.2 // 1\n~~ -1.2 // -1\n~~ 1.6 // 1\n~~ -1.6 // -1\n~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31)) // -2147483648 = -2^31\n~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1\n~~ (Math.pow(2, 32)) // 0\n```","slug":"JS中的位操作符","published":1,"updated":"2019-03-31T02:31:52.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fi200067dxqtm859u4l","content":"<blockquote>\n<p>位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.</p>\n</blockquote>\n<p>刚刚看到位操作的英语 bit operation </p>\n<p>在看mdn中的Polyfill中,常常可以看到这样的做法: length = length &gt;&gt;&gt; 0 google一下, 在使用 &gt;&gt;&gt;0的时候,基本上保证了参数不会为负数,但是可能会为其他类型的数值,这样就会把其他类型的都变成0.作用和~~是一样的.</p>\n<blockquote>\n<p>这里再吐槽一句js吧.这设计的啥玩意啊,有点太混乱的了.上面的原因都是位操作符会把参数全部转成32位的2进制的补码进行操作,而且对参数没有限制, 所以是非数组的数值,都被当成了0进行的操作.同时还会忽略掉62位浮点型的精度,所以对于数字也只会保留数字的整数部分.</p>\n</blockquote>\n<p>先总结这样使用的作用 <strong>1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分</strong> </p>\n<p>为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">位操作符</a> </p>\n<p>说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算.同时数值在计算机中存储都是用的补码,然后再转回到10进制呈现. </p>\n<p>对于负数的操作,记录一下.  当发现数值的首位是1的时候, 说明此时数为负数. 所以就不能直接转成10进制的数值. 需要取反,然后加一(就是补码操作).然后再把<strong>负数符号加上去</strong>.反之,如果本身首位都是0了,则说明是正数, 直接转成10进制就完事了.</p>\n<p><strong>同时在js中,</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>操作</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;&lt;(左移位)</td>\n<td>将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. <strong>左边移出的几位被丢弃.右边多出的空位由0补齐</strong></td>\n<td>9&lt;&lt;2产生36，因为1001移位2比特向左变为100100，它是36。</td>\n</tr>\n<tr>\n<td>>&gt;(带符号右移)</td>\n<td>将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. <strong>左边多出的空位由原值的最左边数字补齐</strong>.</td>\n<td>9&gt;&gt;2产生2，因为1001移位2位向右变为10，其是2。同样，-9&gt;&gt;2产生-3，由于符号被保留。</td>\n</tr>\n<tr>\n<td>>&gt;&gt;(补零右移)</td>\n<td>将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. <strong>左边多出的空位由0补齐</strong>.</td>\n<td>19&gt;&gt;&gt;2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。</td>\n</tr>\n</tbody>\n</table>\n<p>左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. </p>\n<p>例如 19 &lt;&lt; 2 -&gt; 76 -19 &lt;&lt; 2 -&gt; 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 &gt;&gt; 2 -&gt; 4 10010 变成了 100 -&gt; 4 -19 &gt;&gt; 4 -&gt; -5 </p>\n<p>-19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -&gt; -5 </p>\n<p>两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 &gt;&gt;&gt; 2 -&gt; 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 &gt;&gt;&gt; 2 -&gt; 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0</p>\n<hr>\n<p>接下来再对其他的位操作对理解 先看一道题:</p>\n<p><a href=\"https://i.loli.net/2019/01/07/5c32efafcf701.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/07/5c32efafcf701.png\" alt=\"\"></a> </p>\n<p>大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.<a href=\"https://baike.baidu.com/item/%E5%BC%82%E6%88%96\" target=\"_blank\" rel=\"noopener\">异或</a>,在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -&gt; 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a &amp; b &gt;&gt; 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a &amp; b &lt;&lt; 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tc_add</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _a = a ^ b</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _b = (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">        a = _a</span><br><span class=\"line\">        b = _b</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>, a)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'b:'</span>, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tc_add(<span class=\"number\">9</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"comment\">// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算</span></span><br></pre></td></tr></table></figure></p>\n<p>再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身</p>\n<blockquote>\n<p>这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题</p>\n</blockquote>\n<p>题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 </p>\n<p>看这个题目, 想法有没有和这个交换变量的题的思想一模一样… 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..</p>\n<blockquote>\n<p>2019 - 03 - 06 add</p>\n</blockquote>\n<h3 id=\"按位逻辑操作符\"><a href=\"#按位逻辑操作符\" class=\"headerlink\" title=\"按位逻辑操作符\"></a>按位逻辑操作符</h3><blockquote>\n<p>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数:</p>\n</blockquote>\n<p>同时 | &amp; 是js中的位比较符号, 也是对其数的二进制进行的位操作.</p>\n<p>| 是或, &amp;是与 , ~ 是非 </p>\n<p>举一个使用&amp;的栗子,在 js中的 Node的 API - compareDocumentPosition<br>在这个 API中, 返回值都是二进制</p>\n<p><code>node.compareDocumentPosition( otherNode )</code></p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>不在同一个文档中</td>\n</tr>\n<tr>\n<td>2</td>\n<td>otherNode 在 node 之前</td>\n</tr>\n<tr>\n<td>4</td>\n<td>otherNode 在 node 之后</td>\n</tr>\n<tr>\n<td>8</td>\n<td>otherNode 包含 node</td>\n</tr>\n<tr>\n<td>16</td>\n<td>otherNode 被 node 包含</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:这个compare是 other和 node之间的关系</strong></p>\n<p>而且,关系并存的情况下,返回的值是和.<br>所以,这个地方就是用到的&amp; 来进行判断了.</p>\n<p><code>node.compareDocumentPosition( otherNode ) &amp; 4</code>返回的如果是false,则说明other不在 node 之后,反之则反.</p>\n<p>~也是按位操作符,按位取反<br>对于是数值的情况下, ~x = -(x + 1)</p>\n<p>使用情景:<br>和indexOf 一起使用, <figure class=\"highlight plain\"><figcaption><span>&#123;</span><a href=\"//\">包含&#125; ```</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">同时还可以使用 ~~ 将操作符转化成32位有符号正数</span><br><span class=\"line\">```js</span><br><span class=\"line\">~~ null // 0</span><br><span class=\"line\">~~ undefined // 0</span><br><span class=\"line\">~~ NaN // 0</span><br><span class=\"line\">~~ &#123;&#125; // 0</span><br><span class=\"line\">~~ true // 1</span><br><span class=\"line\">~~ &apos;&apos; // 0</span><br><span class=\"line\">~~ &apos;string&apos; // 0</span><br><span class=\"line\">~~ &apos;1&apos; // 1</span><br><span class=\"line\">~~ Number.POSITIVE_INFINITY // 0</span><br><span class=\"line\"></span><br><span class=\"line\">~~ 1.2 // 1</span><br><span class=\"line\">~~ -1.2 // -1</span><br><span class=\"line\">~~ 1.6 // 1</span><br><span class=\"line\">~~ -1.6 // -1</span><br><span class=\"line\">~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1</span><br><span class=\"line\">~~ (Math.pow(2, 31)) // -2147483648 = -2^31</span><br><span class=\"line\">~~ (-Math.pow(2, 31)) // -2147483648 = -2^31</span><br><span class=\"line\">~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1</span><br><span class=\"line\">~~ (Math.pow(2, 32)) // 0</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.</p>\n</blockquote>\n<p>刚刚看到位操作的英语 bit operation </p>\n<p>在看mdn中的Polyfill中,常常可以看到这样的做法: length = length &gt;&gt;&gt; 0 google一下, 在使用 &gt;&gt;&gt;0的时候,基本上保证了参数不会为负数,但是可能会为其他类型的数值,这样就会把其他类型的都变成0.作用和~~是一样的.</p>\n<blockquote>\n<p>这里再吐槽一句js吧.这设计的啥玩意啊,有点太混乱的了.上面的原因都是位操作符会把参数全部转成32位的2进制的补码进行操作,而且对参数没有限制, 所以是非数组的数值,都被当成了0进行的操作.同时还会忽略掉62位浮点型的精度,所以对于数字也只会保留数字的整数部分.</p>\n</blockquote>\n<p>先总结这样使用的作用 <strong>1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分</strong> </p>\n<p>为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\" target=\"_blank\" rel=\"noopener\">位操作符</a> </p>\n<p>说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算.同时数值在计算机中存储都是用的补码,然后再转回到10进制呈现. </p>\n<p>对于负数的操作,记录一下.  当发现数值的首位是1的时候, 说明此时数为负数. 所以就不能直接转成10进制的数值. 需要取反,然后加一(就是补码操作).然后再把<strong>负数符号加上去</strong>.反之,如果本身首位都是0了,则说明是正数, 直接转成10进制就完事了.</p>\n<p><strong>同时在js中,</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>操作</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;&lt;(左移位)</td>\n<td>将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. <strong>左边移出的几位被丢弃.右边多出的空位由0补齐</strong></td>\n<td>9&lt;&lt;2产生36，因为1001移位2比特向左变为100100，它是36。</td>\n</tr>\n<tr>\n<td>>&gt;(带符号右移)</td>\n<td>将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. <strong>左边多出的空位由原值的最左边数字补齐</strong>.</td>\n<td>9&gt;&gt;2产生2，因为1001移位2位向右变为10，其是2。同样，-9&gt;&gt;2产生-3，由于符号被保留。</td>\n</tr>\n<tr>\n<td>>&gt;&gt;(补零右移)</td>\n<td>将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. <strong>左边多出的空位由0补齐</strong>.</td>\n<td>19&gt;&gt;&gt;2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。</td>\n</tr>\n</tbody>\n</table>\n<p>左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. </p>\n<p>例如 19 &lt;&lt; 2 -&gt; 76 -19 &lt;&lt; 2 -&gt; 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 &gt;&gt; 2 -&gt; 4 10010 变成了 100 -&gt; 4 -19 &gt;&gt; 4 -&gt; -5 </p>\n<p>-19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -&gt; -5 </p>\n<p>两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 &gt;&gt;&gt; 2 -&gt; 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 &gt;&gt;&gt; 2 -&gt; 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0</p>\n<hr>\n<p>接下来再对其他的位操作对理解 先看一道题:</p>\n<p><a href=\"https://i.loli.net/2019/01/07/5c32efafcf701.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/01/07/5c32efafcf701.png\" alt=\"\"></a> </p>\n<p>大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.<a href=\"https://baike.baidu.com/item/%E5%BC%82%E6%88%96\" target=\"_blank\" rel=\"noopener\">异或</a>,在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -&gt; 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a &amp; b &gt;&gt; 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a &amp; b &lt;&lt; 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tc_add</span> (<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (b != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _a = a ^ b</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _b = (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">        a = _a</span><br><span class=\"line\">        b = _b</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>, a)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'b:'</span>, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tc_add(<span class=\"number\">9</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"comment\">// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算</span></span><br></pre></td></tr></table></figure></p>\n<p>再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身</p>\n<blockquote>\n<p>这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题</p>\n</blockquote>\n<p>题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 </p>\n<p>看这个题目, 想法有没有和这个交换变量的题的思想一模一样… 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..</p>\n<blockquote>\n<p>2019 - 03 - 06 add</p>\n</blockquote>\n<h3 id=\"按位逻辑操作符\"><a href=\"#按位逻辑操作符\" class=\"headerlink\" title=\"按位逻辑操作符\"></a>按位逻辑操作符</h3><blockquote>\n<p>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数:</p>\n</blockquote>\n<p>同时 | &amp; 是js中的位比较符号, 也是对其数的二进制进行的位操作.</p>\n<p>| 是或, &amp;是与 , ~ 是非 </p>\n<p>举一个使用&amp;的栗子,在 js中的 Node的 API - compareDocumentPosition<br>在这个 API中, 返回值都是二进制</p>\n<p><code>node.compareDocumentPosition( otherNode )</code></p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>不在同一个文档中</td>\n</tr>\n<tr>\n<td>2</td>\n<td>otherNode 在 node 之前</td>\n</tr>\n<tr>\n<td>4</td>\n<td>otherNode 在 node 之后</td>\n</tr>\n<tr>\n<td>8</td>\n<td>otherNode 包含 node</td>\n</tr>\n<tr>\n<td>16</td>\n<td>otherNode 被 node 包含</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意:这个compare是 other和 node之间的关系</strong></p>\n<p>而且,关系并存的情况下,返回的值是和.<br>所以,这个地方就是用到的&amp; 来进行判断了.</p>\n<p><code>node.compareDocumentPosition( otherNode ) &amp; 4</code>返回的如果是false,则说明other不在 node 之后,反之则反.</p>\n<p>~也是按位操作符,按位取反<br>对于是数值的情况下, ~x = -(x + 1)</p>\n<p>使用情景:<br>和indexOf 一起使用, <figure class=\"highlight plain\"><figcaption><span>&#123;</span><a href=\"//\">包含&#125; ```</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">同时还可以使用 ~~ 将操作符转化成32位有符号正数</span><br><span class=\"line\">```js</span><br><span class=\"line\">~~ null // 0</span><br><span class=\"line\">~~ undefined // 0</span><br><span class=\"line\">~~ NaN // 0</span><br><span class=\"line\">~~ &#123;&#125; // 0</span><br><span class=\"line\">~~ true // 1</span><br><span class=\"line\">~~ &apos;&apos; // 0</span><br><span class=\"line\">~~ &apos;string&apos; // 0</span><br><span class=\"line\">~~ &apos;1&apos; // 1</span><br><span class=\"line\">~~ Number.POSITIVE_INFINITY // 0</span><br><span class=\"line\"></span><br><span class=\"line\">~~ 1.2 // 1</span><br><span class=\"line\">~~ -1.2 // -1</span><br><span class=\"line\">~~ 1.6 // 1</span><br><span class=\"line\">~~ -1.6 // -1</span><br><span class=\"line\">~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1</span><br><span class=\"line\">~~ (Math.pow(2, 31)) // -2147483648 = -2^31</span><br><span class=\"line\">~~ (-Math.pow(2, 31)) // -2147483648 = -2^31</span><br><span class=\"line\">~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1</span><br><span class=\"line\">~~ (Math.pow(2, 32)) // 0</span><br></pre></td></tr></table></figure></p>\n"},{"title":"CSS布局","date":"2019-03-13T03:16:24.000Z","_content":"\n### 两栏布局\n> 两栏布局的要求一般是要求一左一右铺满整个界面,同时,左边(或者是右边)的元素固定宽度,另一边的元素随着浏览器的变化而变化\n\n页面布局:(左侧固定300px)\n```html\n<body>\n    <div id=\"left\"></div>\n    <div id=\"right\"></div>\n</body>\n```\n#### float方法\n\n```css\nbody{\n    height:100px;\n}\n#left{\n    float:left;\n    height:100%;\n    width:300px;\n}\n#right{\n    margin-right:300px;\n    height:100%;\n}\n```\n#### flex方法\n\n```css\nbody {\n    height: 300px;\n    display: flex;\n    flex-direction: row;\n}\n\n#left {\n    flex: 0 0 300px;\n    height: 100%;\n    background-color: red;\n}\n\n#right {\n    flex: 1 1 auto;\n    height: 100%;\n    background-color: blue;\n}\n```\n\n### 三栏布局\n\n>三栏布局同时也是经常出现的考点之一.一般的情形是,两边的模块是固定的,中间的模块随着浏览器的宽度适应.\n\n### margin 和 利用BFC布局\n\n>这两种布局都有一个确定,就是主体元素需要最后加载.\n\n```html\n<div id=\"parent\">\n    <div id=\"left\"></div>\n    <div id=\"right\"></div>\n    <div id=\"main\"></div>\n</div>\n```\n\n```css\n#parent{\n    height: 200px;\n}\n#left{\n    display: float;\n    float: left;\n    width: 300px;\n    height: 100%;\n    background-color: red;\n}\n#right{\n    display: float;\n    float: right;\n    width: 300px;\n    height: 100%;\n    background-color: green;\n}\n#main{\n    height: 100%;\n    background-color: blue;\n    /* 这里有两种做法,一种是用margin,一种是用BFC */\n    /* margin: 0 300px; */\n    overflow: hidden;\n}\n```\n\n#### flex布局\n>使用flex布局就看起来易用,舒适多了\n```html\n<div id=\"parent\">\n  <div id=\"left\"></div>\n  <div id=\"main\">\n    <p style=\"text-align:center\">我们是中间的啊</p>\n  </div>\n  <div id=\"right\"></div>\n</div>\n```\n\n```css\n#parent {\n    height: 200px;\n    display: flex;\n}\n#left {\n    flex: 0 0 300px;\n    background-color: red;\n}\n#right {\n    flex: 0 0 300px;\n    background-color: green;\n}\n#main {\n    flex: 1 1 auto;\n    background-color: blue;\n}\n```\n\n### 垂直水平居中\n\n```html\n<div id=\"parent\">\n    <div id=\"main\"></div>\n</div>\n```\n\n#### 水平居中\n\n>水平居中分为两种情况,一种是DIV宽度一定的,一种是宽度不定的\n\n##### 对于宽度已知的水平居中\n\n```css\n#main{\n    display: inline-block;\n    width: 200px;\n    height: 200px\n}\n#parent{\n    test-align:center;\n}\n```\n在宽度已知的情况,只需要在父元素上加上`test-align:center;`,甚至没有父元素也可以加一个div\n\n##### 对于宽度未知的水平居中\n\n使用 `margin: 0 auto`;\n\n#### 水平垂直居中\n\n##### 绝对定位\n\n```css\n#main{\n    position: relative;\n}\n#parent{\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%)\n}\n```\n\n绝对定位的思想就是让子元素基于父元素进行绝对定位\n\n##### flex布局\n\n```css\n#main{\n    height: 300px;\n    background-color: grey;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n#parent{\n\n}\n```\n\n使用flex布局在对对齐的设置就是主要在父元素上的设置,看的文章都是以前的,都会提到兼容性的问题,但是感觉现在都兼容的很好了.那些之前的hack的方法,实在是不想用了","source":"_posts/CSS布局.md","raw":"---\ntitle: CSS布局\ndate: 2019-03-13 11:16:24\ntags: css\n---\n\n### 两栏布局\n> 两栏布局的要求一般是要求一左一右铺满整个界面,同时,左边(或者是右边)的元素固定宽度,另一边的元素随着浏览器的变化而变化\n\n页面布局:(左侧固定300px)\n```html\n<body>\n    <div id=\"left\"></div>\n    <div id=\"right\"></div>\n</body>\n```\n#### float方法\n\n```css\nbody{\n    height:100px;\n}\n#left{\n    float:left;\n    height:100%;\n    width:300px;\n}\n#right{\n    margin-right:300px;\n    height:100%;\n}\n```\n#### flex方法\n\n```css\nbody {\n    height: 300px;\n    display: flex;\n    flex-direction: row;\n}\n\n#left {\n    flex: 0 0 300px;\n    height: 100%;\n    background-color: red;\n}\n\n#right {\n    flex: 1 1 auto;\n    height: 100%;\n    background-color: blue;\n}\n```\n\n### 三栏布局\n\n>三栏布局同时也是经常出现的考点之一.一般的情形是,两边的模块是固定的,中间的模块随着浏览器的宽度适应.\n\n### margin 和 利用BFC布局\n\n>这两种布局都有一个确定,就是主体元素需要最后加载.\n\n```html\n<div id=\"parent\">\n    <div id=\"left\"></div>\n    <div id=\"right\"></div>\n    <div id=\"main\"></div>\n</div>\n```\n\n```css\n#parent{\n    height: 200px;\n}\n#left{\n    display: float;\n    float: left;\n    width: 300px;\n    height: 100%;\n    background-color: red;\n}\n#right{\n    display: float;\n    float: right;\n    width: 300px;\n    height: 100%;\n    background-color: green;\n}\n#main{\n    height: 100%;\n    background-color: blue;\n    /* 这里有两种做法,一种是用margin,一种是用BFC */\n    /* margin: 0 300px; */\n    overflow: hidden;\n}\n```\n\n#### flex布局\n>使用flex布局就看起来易用,舒适多了\n```html\n<div id=\"parent\">\n  <div id=\"left\"></div>\n  <div id=\"main\">\n    <p style=\"text-align:center\">我们是中间的啊</p>\n  </div>\n  <div id=\"right\"></div>\n</div>\n```\n\n```css\n#parent {\n    height: 200px;\n    display: flex;\n}\n#left {\n    flex: 0 0 300px;\n    background-color: red;\n}\n#right {\n    flex: 0 0 300px;\n    background-color: green;\n}\n#main {\n    flex: 1 1 auto;\n    background-color: blue;\n}\n```\n\n### 垂直水平居中\n\n```html\n<div id=\"parent\">\n    <div id=\"main\"></div>\n</div>\n```\n\n#### 水平居中\n\n>水平居中分为两种情况,一种是DIV宽度一定的,一种是宽度不定的\n\n##### 对于宽度已知的水平居中\n\n```css\n#main{\n    display: inline-block;\n    width: 200px;\n    height: 200px\n}\n#parent{\n    test-align:center;\n}\n```\n在宽度已知的情况,只需要在父元素上加上`test-align:center;`,甚至没有父元素也可以加一个div\n\n##### 对于宽度未知的水平居中\n\n使用 `margin: 0 auto`;\n\n#### 水平垂直居中\n\n##### 绝对定位\n\n```css\n#main{\n    position: relative;\n}\n#parent{\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%)\n}\n```\n\n绝对定位的思想就是让子元素基于父元素进行绝对定位\n\n##### flex布局\n\n```css\n#main{\n    height: 300px;\n    background-color: grey;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n#parent{\n\n}\n```\n\n使用flex布局在对对齐的设置就是主要在父元素上的设置,看的文章都是以前的,都会提到兼容性的问题,但是感觉现在都兼容的很好了.那些之前的hack的方法,实在是不想用了","slug":"CSS布局","published":1,"updated":"2019-03-31T02:31:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fi600087dxqp9v6dv96","content":"<h3 id=\"两栏布局\"><a href=\"#两栏布局\" class=\"headerlink\" title=\"两栏布局\"></a>两栏布局</h3><blockquote>\n<p>两栏布局的要求一般是要求一左一右铺满整个界面,同时,左边(或者是右边)的元素固定宽度,另一边的元素随着浏览器的变化而变化</p>\n</blockquote>\n<p>页面布局:(左侧固定300px)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"float方法\"><a href=\"#float方法\" class=\"headerlink\" title=\"float方法\"></a>float方法</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex方法\"><a href=\"#flex方法\" class=\"headerlink\" title=\"flex方法\"></a>flex方法</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三栏布局\"><a href=\"#三栏布局\" class=\"headerlink\" title=\"三栏布局\"></a>三栏布局</h3><blockquote>\n<p>三栏布局同时也是经常出现的考点之一.一般的情形是,两边的模块是固定的,中间的模块随着浏览器的宽度适应.</p>\n</blockquote>\n<h3 id=\"margin-和-利用BFC布局\"><a href=\"#margin-和-利用BFC布局\" class=\"headerlink\" title=\"margin 和 利用BFC布局\"></a>margin 和 利用BFC布局</h3><blockquote>\n<p>这两种布局都有一个确定,就是主体元素需要最后加载.</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: float;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: float;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"comment\">/* 这里有两种做法,一种是用margin,一种是用BFC */</span></span><br><span class=\"line\">    <span class=\"comment\">/* margin: 0 300px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h4><blockquote>\n<p>使用flex布局就看起来易用,舒适多了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"text-align:center\"</span>&gt;</span>我们是中间的啊<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#parent</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"垂直水平居中\"><a href=\"#垂直水平居中\" class=\"headerlink\" title=\"垂直水平居中\"></a>垂直水平居中</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h4><blockquote>\n<p>水平居中分为两种情况,一种是DIV宽度一定的,一种是宽度不定的</p>\n</blockquote>\n<h5 id=\"对于宽度已知的水平居中\"><a href=\"#对于宽度已知的水平居中\" class=\"headerlink\" title=\"对于宽度已知的水平居中\"></a>对于宽度已知的水平居中</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">test-align</span>:center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在宽度已知的情况,只需要在父元素上加上<code>test-align:center;</code>,甚至没有父元素也可以加一个div</p>\n<h5 id=\"对于宽度未知的水平居中\"><a href=\"#对于宽度未知的水平居中\" class=\"headerlink\" title=\"对于宽度未知的水平居中\"></a>对于宽度未知的水平居中</h5><p>使用 <code>margin: 0 auto</code>;</p>\n<h4 id=\"水平垂直居中\"><a href=\"#水平垂直居中\" class=\"headerlink\" title=\"水平垂直居中\"></a>水平垂直居中</h4><h5 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绝对定位的思想就是让子元素基于父元素进行绝对定位</p>\n<h5 id=\"flex布局-1\"><a href=\"#flex布局-1\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: grey;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用flex布局在对对齐的设置就是主要在父元素上的设置,看的文章都是以前的,都会提到兼容性的问题,但是感觉现在都兼容的很好了.那些之前的hack的方法,实在是不想用了</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"两栏布局\"><a href=\"#两栏布局\" class=\"headerlink\" title=\"两栏布局\"></a>两栏布局</h3><blockquote>\n<p>两栏布局的要求一般是要求一左一右铺满整个界面,同时,左边(或者是右边)的元素固定宽度,另一边的元素随着浏览器的变化而变化</p>\n</blockquote>\n<p>页面布局:(左侧固定300px)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"float方法\"><a href=\"#float方法\" class=\"headerlink\" title=\"float方法\"></a>float方法</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>:left;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin-right</span>:<span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex方法\"><a href=\"#flex方法\" class=\"headerlink\" title=\"flex方法\"></a>flex方法</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-direction</span>: row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三栏布局\"><a href=\"#三栏布局\" class=\"headerlink\" title=\"三栏布局\"></a>三栏布局</h3><blockquote>\n<p>三栏布局同时也是经常出现的考点之一.一般的情形是,两边的模块是固定的,中间的模块随着浏览器的宽度适应.</p>\n</blockquote>\n<h3 id=\"margin-和-利用BFC布局\"><a href=\"#margin-和-利用BFC布局\" class=\"headerlink\" title=\"margin 和 利用BFC布局\"></a>margin 和 利用BFC布局</h3><blockquote>\n<p>这两种布局都有一个确定,就是主体元素需要最后加载.</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: float;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: float;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">    <span class=\"comment\">/* 这里有两种做法,一种是用margin,一种是用BFC */</span></span><br><span class=\"line\">    <span class=\"comment\">/* margin: 0 300px; */</span></span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h4><blockquote>\n<p>使用flex布局就看起来易用,舒适多了<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"left\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"text-align:center\"</span>&gt;</span>我们是中间的啊<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"right\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#parent</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#right</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">flex</span>: <span class=\"number\">1</span> <span class=\"number\">1</span> auto;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"垂直水平居中\"><a href=\"#垂直水平居中\" class=\"headerlink\" title=\"垂直水平居中\"></a>垂直水平居中</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"水平居中\"><a href=\"#水平居中\" class=\"headerlink\" title=\"水平居中\"></a>水平居中</h4><blockquote>\n<p>水平居中分为两种情况,一种是DIV宽度一定的,一种是宽度不定的</p>\n</blockquote>\n<h5 id=\"对于宽度已知的水平居中\"><a href=\"#对于宽度已知的水平居中\" class=\"headerlink\" title=\"对于宽度已知的水平居中\"></a>对于宽度已知的水平居中</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">test-align</span>:center;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在宽度已知的情况,只需要在父元素上加上<code>test-align:center;</code>,甚至没有父元素也可以加一个div</p>\n<h5 id=\"对于宽度未知的水平居中\"><a href=\"#对于宽度未知的水平居中\" class=\"headerlink\" title=\"对于宽度未知的水平居中\"></a>对于宽度未知的水平居中</h5><p>使用 <code>margin: 0 auto</code>;</p>\n<h4 id=\"水平垂直居中\"><a href=\"#水平垂直居中\" class=\"headerlink\" title=\"水平垂直居中\"></a>水平垂直居中</h4><h5 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-50%, -50%)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绝对定位的思想就是让子元素基于父元素进行绝对定位</p>\n<h5 id=\"flex布局-1\"><a href=\"#flex布局-1\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h5><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: grey;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#parent</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用flex布局在对对齐的设置就是主要在父元素上的设置,看的文章都是以前的,都会提到兼容性的问题,但是感觉现在都兼容的很好了.那些之前的hack的方法,实在是不想用了</p>\n"},{"title":"JS中的继承","date":"2019-01-10T06:33:09.000Z","_content":"\n> 文中方法全部来自<<JavaScript高级程序设计一书>>\n\n先想一个需求, 这里有一个父类方法, 包含了全部的共有属性, 我们想自己利用这个方法来创造继承于其中的子类方法\n```js\nfunction SuperClass(id) {\n    this.id = id\n    this.name = 'fatherFunction'\n    this.colors = ['red', 'bule']\n}\n\nSueperClass.prototype.say = function () {\n    console.log(this.id, this.name, this.colors)\n}\n```\n在上面我们定义了一个父类构造方法, 其中包含属性id,name,colors,还定义了它的一个方法say\n\n### 原型链继承\n```js\nfunction Child_chain () { // 定义的子类\n    this.name = 'Child_Prototype_chain'\n}\nChild_chain.prototype = new SuperClass('10')\nlet child_chain1 = new Child_chain()\nchild_chain1.colors.push('yellow')\nchild_chain1.say()\nlet child_chain2 = new Child_chain()\nchild_chain2.say()\n```\n原型链继承是直接利用原型链实现的继承方法, 将原型继承父类实例的方法和属性\n当子类中调用其本身没有的属性和方法的时候,会在原型链上查找就可以调用父类上的属性和方法了,就实现了继承\n\n> 原型链继承的缺点： 1. 所有实例共享属性和方法，如果某一个实例修改了对象类型（引用类型）的属性的话，所有的实例的属性都会变化。 2.无法在创建实例的时候，向超类的构造函数传递参数\n\n### 构造函数继承\n\n```js\nfunction Child_constructor (id) {\n    SuperClass.call(this, id) // key\n}\nlet child_constructor = new Child_constructor('20')\nlet child_constructor2 = new Child_constructor('21')\n```\n用构造函数实现继承的时候,每一个子类的实例都会调用一次父类的构造函数,保证了数据的独立性\n但是这样并不是完整的继承,这样的方法只实现了属性的继承,而对方法没有继承。在使用方法的时候需要在构造函数内部定义方法，方法就没有复用的了。\nso,就是组合继承出场的时候了.\n\n### 组合继承\n\n在组合继承中,还是使用构造函数一样的继承方法,但是会在子类的原型上再进行一些操作\n```js\nChild_constructor.prototype = new SuperClass() // 实现对父类中的方法的继承\nChild_constructor.prototype.constructor = Child_constructor // 同时还需要把constructor属性更改回来\n```\n这样就完成了一个完整的继承,当然还是有不够完美的地方,那就是调用了父类的构造函数两次,这些都是很浪费的\n\n### 寄生组合继承\n\n这个方法的出现原因主要是为了解决父类构造函数被调用了两次的问题,`Super.call()`这个继承属性的构造函数是没有什么办法可以去省略的,但是在原型链中指定子类的原型其实没有必要用父类的构造函数,因为我们其实需要父类的原型的一个副本而已\n\n就衍生了一个创造副本的函数\n```js\nfunction object (o) {\n    var F = new function()\n    F.prototype = o\n    return new F()\n}\n```\n>这个函数在ECMAScript5中用Object.create()进行了规范\n\n那么寄生组合继承就可以完成了\n```js\nfunction Child_inherit (id) {\n    SuperClass.call(this, id)\n}\n\nChild_inherit.prototype = object(SuperClass.prototype)\nChild_inherit.prototype.constructor  = Child_inherit\n```\n就OK啦\n\n#### class完成继承\n\n>上面的方法看着就反人类,官方也这么觉得了,自然现在就有官方的解决办法了.类似JAVA,用class来完成继承\n```js\nclass Super {\n    constructor (name) {\n        this.name = name\n    }\n    sayName () {\n        console.log(this.name)\n    }\n}\n\nclass Child extends Super {\n    constructor (name, id) {\n        super(name) // 实现继承\n        this.id = id\n    }\n}\n```\n关于class见[more](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class)\n\n### 关于ES6中的关键字 super\n\n在ES6中使用extend完成继承的话，在子类constructor 中必须使用super关键字。\n\n同时super可以作为方法，也可以作为对象。作为方法只能在constructor中使用，而在方法中，可以将super作为对象使用。\n\n#### 作为方法\n\n在ES6的constructor 中使用super() ，相当于 `Super.call()`\n\n#### 作为对象\n\n##### 在方法中使用\n\n相当于 super 指向 父类的原型 `Super.prototype`.\n\n但是super 内部的this 指向的是子类中的this， 所以在使用的时候， 是 `Super.prototype.call()`\n\n##### 在静态方法中使用\n\n在静态方法中使用的时候，super 指向的是 Super , 就不再是 Super的原型了","source":"_posts/JS中的继承.md","raw":"---\ntitle: JS中的继承\ndate: 2019-01-10 14:33:09\ntags: js\n---\n\n> 文中方法全部来自<<JavaScript高级程序设计一书>>\n\n先想一个需求, 这里有一个父类方法, 包含了全部的共有属性, 我们想自己利用这个方法来创造继承于其中的子类方法\n```js\nfunction SuperClass(id) {\n    this.id = id\n    this.name = 'fatherFunction'\n    this.colors = ['red', 'bule']\n}\n\nSueperClass.prototype.say = function () {\n    console.log(this.id, this.name, this.colors)\n}\n```\n在上面我们定义了一个父类构造方法, 其中包含属性id,name,colors,还定义了它的一个方法say\n\n### 原型链继承\n```js\nfunction Child_chain () { // 定义的子类\n    this.name = 'Child_Prototype_chain'\n}\nChild_chain.prototype = new SuperClass('10')\nlet child_chain1 = new Child_chain()\nchild_chain1.colors.push('yellow')\nchild_chain1.say()\nlet child_chain2 = new Child_chain()\nchild_chain2.say()\n```\n原型链继承是直接利用原型链实现的继承方法, 将原型继承父类实例的方法和属性\n当子类中调用其本身没有的属性和方法的时候,会在原型链上查找就可以调用父类上的属性和方法了,就实现了继承\n\n> 原型链继承的缺点： 1. 所有实例共享属性和方法，如果某一个实例修改了对象类型（引用类型）的属性的话，所有的实例的属性都会变化。 2.无法在创建实例的时候，向超类的构造函数传递参数\n\n### 构造函数继承\n\n```js\nfunction Child_constructor (id) {\n    SuperClass.call(this, id) // key\n}\nlet child_constructor = new Child_constructor('20')\nlet child_constructor2 = new Child_constructor('21')\n```\n用构造函数实现继承的时候,每一个子类的实例都会调用一次父类的构造函数,保证了数据的独立性\n但是这样并不是完整的继承,这样的方法只实现了属性的继承,而对方法没有继承。在使用方法的时候需要在构造函数内部定义方法，方法就没有复用的了。\nso,就是组合继承出场的时候了.\n\n### 组合继承\n\n在组合继承中,还是使用构造函数一样的继承方法,但是会在子类的原型上再进行一些操作\n```js\nChild_constructor.prototype = new SuperClass() // 实现对父类中的方法的继承\nChild_constructor.prototype.constructor = Child_constructor // 同时还需要把constructor属性更改回来\n```\n这样就完成了一个完整的继承,当然还是有不够完美的地方,那就是调用了父类的构造函数两次,这些都是很浪费的\n\n### 寄生组合继承\n\n这个方法的出现原因主要是为了解决父类构造函数被调用了两次的问题,`Super.call()`这个继承属性的构造函数是没有什么办法可以去省略的,但是在原型链中指定子类的原型其实没有必要用父类的构造函数,因为我们其实需要父类的原型的一个副本而已\n\n就衍生了一个创造副本的函数\n```js\nfunction object (o) {\n    var F = new function()\n    F.prototype = o\n    return new F()\n}\n```\n>这个函数在ECMAScript5中用Object.create()进行了规范\n\n那么寄生组合继承就可以完成了\n```js\nfunction Child_inherit (id) {\n    SuperClass.call(this, id)\n}\n\nChild_inherit.prototype = object(SuperClass.prototype)\nChild_inherit.prototype.constructor  = Child_inherit\n```\n就OK啦\n\n#### class完成继承\n\n>上面的方法看着就反人类,官方也这么觉得了,自然现在就有官方的解决办法了.类似JAVA,用class来完成继承\n```js\nclass Super {\n    constructor (name) {\n        this.name = name\n    }\n    sayName () {\n        console.log(this.name)\n    }\n}\n\nclass Child extends Super {\n    constructor (name, id) {\n        super(name) // 实现继承\n        this.id = id\n    }\n}\n```\n关于class见[more](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class)\n\n### 关于ES6中的关键字 super\n\n在ES6中使用extend完成继承的话，在子类constructor 中必须使用super关键字。\n\n同时super可以作为方法，也可以作为对象。作为方法只能在constructor中使用，而在方法中，可以将super作为对象使用。\n\n#### 作为方法\n\n在ES6的constructor 中使用super() ，相当于 `Super.call()`\n\n#### 作为对象\n\n##### 在方法中使用\n\n相当于 super 指向 父类的原型 `Super.prototype`.\n\n但是super 内部的this 指向的是子类中的this， 所以在使用的时候， 是 `Super.prototype.call()`\n\n##### 在静态方法中使用\n\n在静态方法中使用的时候，super 指向的是 Super , 就不再是 Super的原型了","slug":"JS中的继承","published":1,"updated":"2019-03-31T02:31:52.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fi800097dxqi204gqun","content":"<blockquote>\n<p>文中方法全部来自&lt;&lt;JavaScript高级程序设计一书&gt;&gt;</p>\n</blockquote>\n<p>先想一个需求, 这里有一个父类方法, 包含了全部的共有属性, 我们想自己利用这个方法来创造继承于其中的子类方法<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'fatherFunction'</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'bule'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SueperClass.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.id, <span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.colors)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上面我们定义了一个父类构造方法, 其中包含属性id,name,colors,还定义了它的一个方法say</p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_chain</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 定义的子类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Child_Prototype_chain'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child_chain.prototype = <span class=\"keyword\">new</span> SuperClass(<span class=\"string\">'10'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_chain1 = <span class=\"keyword\">new</span> Child_chain()</span><br><span class=\"line\">child_chain1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">child_chain1.say()</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_chain2 = <span class=\"keyword\">new</span> Child_chain()</span><br><span class=\"line\">child_chain2.say()</span><br></pre></td></tr></table></figure>\n<p>原型链继承是直接利用原型链实现的继承方法, 将原型继承父类实例的方法和属性<br>当子类中调用其本身没有的属性和方法的时候,会在原型链上查找就可以调用父类上的属性和方法了,就实现了继承</p>\n<blockquote>\n<p>原型链继承的缺点： 1. 所有实例共享属性和方法，如果某一个实例修改了对象类型（引用类型）的属性的话，所有的实例的属性都会变化。 2.无法在创建实例的时候，向超类的构造函数传递参数</p>\n</blockquote>\n<h3 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_constructor</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id) <span class=\"comment\">// key</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_constructor = <span class=\"keyword\">new</span> Child_constructor(<span class=\"string\">'20'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_constructor2 = <span class=\"keyword\">new</span> Child_constructor(<span class=\"string\">'21'</span>)</span><br></pre></td></tr></table></figure>\n<p>用构造函数实现继承的时候,每一个子类的实例都会调用一次父类的构造函数,保证了数据的独立性<br>但是这样并不是完整的继承,这样的方法只实现了属性的继承,而对方法没有继承。在使用方法的时候需要在构造函数内部定义方法，方法就没有复用的了。<br>so,就是组合继承出场的时候了.</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>在组合继承中,还是使用构造函数一样的继承方法,但是会在子类的原型上再进行一些操作<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Child_constructor.prototype = <span class=\"keyword\">new</span> SuperClass() <span class=\"comment\">// 实现对父类中的方法的继承</span></span><br><span class=\"line\">Child_constructor.prototype.constructor = Child_constructor <span class=\"comment\">// 同时还需要把constructor属性更改回来</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了一个完整的继承,当然还是有不够完美的地方,那就是调用了父类的构造函数两次,这些都是很浪费的</p>\n<h3 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h3><p>这个方法的出现原因主要是为了解决父类构造函数被调用了两次的问题,<code>Super.call()</code>这个继承属性的构造函数是没有什么办法可以去省略的,但是在原型链中指定子类的原型其实没有必要用父类的构造函数,因为我们其实需要父类的原型的一个副本而已</p>\n<p>就衍生了一个创造副本的函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">F</span>.<span class=\"title\">prototype</span> = <span class=\"title\">o</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">new</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这个函数在ECMAScript5中用Object.create()进行了规范</p>\n</blockquote>\n<p>那么寄生组合继承就可以完成了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_inherit</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child_inherit.prototype = object(SuperClass.prototype)</span><br><span class=\"line\">Child_inherit.prototype.constructor  = Child_inherit</span><br></pre></td></tr></table></figure></p>\n<p>就OK啦</p>\n<h4 id=\"class完成继承\"><a href=\"#class完成继承\" class=\"headerlink\" title=\"class完成继承\"></a>class完成继承</h4><blockquote>\n<p>上面的方法看着就反人类,官方也这么觉得了,自然现在就有官方的解决办法了.类似JAVA,用class来完成继承<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sayName () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Super</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name, id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name) <span class=\"comment\">// 实现继承</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>关于class见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class\" target=\"_blank\" rel=\"noopener\">more</a></p>\n<h3 id=\"关于ES6中的关键字-super\"><a href=\"#关于ES6中的关键字-super\" class=\"headerlink\" title=\"关于ES6中的关键字 super\"></a>关于ES6中的关键字 super</h3><p>在ES6中使用extend完成继承的话，在子类constructor 中必须使用super关键字。</p>\n<p>同时super可以作为方法，也可以作为对象。作为方法只能在constructor中使用，而在方法中，可以将super作为对象使用。</p>\n<h4 id=\"作为方法\"><a href=\"#作为方法\" class=\"headerlink\" title=\"作为方法\"></a>作为方法</h4><p>在ES6的constructor 中使用super() ，相当于 <code>Super.call()</code></p>\n<h4 id=\"作为对象\"><a href=\"#作为对象\" class=\"headerlink\" title=\"作为对象\"></a>作为对象</h4><h5 id=\"在方法中使用\"><a href=\"#在方法中使用\" class=\"headerlink\" title=\"在方法中使用\"></a>在方法中使用</h5><p>相当于 super 指向 父类的原型 <code>Super.prototype</code>.</p>\n<p>但是super 内部的this 指向的是子类中的this， 所以在使用的时候， 是 <code>Super.prototype.call()</code></p>\n<h5 id=\"在静态方法中使用\"><a href=\"#在静态方法中使用\" class=\"headerlink\" title=\"在静态方法中使用\"></a>在静态方法中使用</h5><p>在静态方法中使用的时候，super 指向的是 Super , 就不再是 Super的原型了</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>文中方法全部来自&lt;&lt;JavaScript高级程序设计一书&gt;&gt;</p>\n</blockquote>\n<p>先想一个需求, 这里有一个父类方法, 包含了全部的共有属性, 我们想自己利用这个方法来创造继承于其中的子类方法<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperClass</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'fatherFunction'</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'bule'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SueperClass.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.id, <span class=\"keyword\">this</span>.name, <span class=\"keyword\">this</span>.colors)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上面我们定义了一个父类构造方法, 其中包含属性id,name,colors,还定义了它的一个方法say</p>\n<h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_chain</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 定义的子类</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Child_Prototype_chain'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child_chain.prototype = <span class=\"keyword\">new</span> SuperClass(<span class=\"string\">'10'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_chain1 = <span class=\"keyword\">new</span> Child_chain()</span><br><span class=\"line\">child_chain1.colors.push(<span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">child_chain1.say()</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_chain2 = <span class=\"keyword\">new</span> Child_chain()</span><br><span class=\"line\">child_chain2.say()</span><br></pre></td></tr></table></figure>\n<p>原型链继承是直接利用原型链实现的继承方法, 将原型继承父类实例的方法和属性<br>当子类中调用其本身没有的属性和方法的时候,会在原型链上查找就可以调用父类上的属性和方法了,就实现了继承</p>\n<blockquote>\n<p>原型链继承的缺点： 1. 所有实例共享属性和方法，如果某一个实例修改了对象类型（引用类型）的属性的话，所有的实例的属性都会变化。 2.无法在创建实例的时候，向超类的构造函数传递参数</p>\n</blockquote>\n<h3 id=\"构造函数继承\"><a href=\"#构造函数继承\" class=\"headerlink\" title=\"构造函数继承\"></a>构造函数继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_constructor</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id) <span class=\"comment\">// key</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_constructor = <span class=\"keyword\">new</span> Child_constructor(<span class=\"string\">'20'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> child_constructor2 = <span class=\"keyword\">new</span> Child_constructor(<span class=\"string\">'21'</span>)</span><br></pre></td></tr></table></figure>\n<p>用构造函数实现继承的时候,每一个子类的实例都会调用一次父类的构造函数,保证了数据的独立性<br>但是这样并不是完整的继承,这样的方法只实现了属性的继承,而对方法没有继承。在使用方法的时候需要在构造函数内部定义方法，方法就没有复用的了。<br>so,就是组合继承出场的时候了.</p>\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>在组合继承中,还是使用构造函数一样的继承方法,但是会在子类的原型上再进行一些操作<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Child_constructor.prototype = <span class=\"keyword\">new</span> SuperClass() <span class=\"comment\">// 实现对父类中的方法的继承</span></span><br><span class=\"line\">Child_constructor.prototype.constructor = Child_constructor <span class=\"comment\">// 同时还需要把constructor属性更改回来</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就完成了一个完整的继承,当然还是有不够完美的地方,那就是调用了父类的构造函数两次,这些都是很浪费的</p>\n<h3 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h3><p>这个方法的出现原因主要是为了解决父类构造函数被调用了两次的问题,<code>Super.call()</code>这个继承属性的构造函数是没有什么办法可以去省略的,但是在原型链中指定子类的原型其实没有必要用父类的构造函数,因为我们其实需要父类的原型的一个副本而已</p>\n<p>就衍生了一个创造副本的函数<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span> (<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">F</span>.<span class=\"title\">prototype</span> = <span class=\"title\">o</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">return</span> <span class=\"title\">new</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这个函数在ECMAScript5中用Object.create()进行了规范</p>\n</blockquote>\n<p>那么寄生组合继承就可以完成了<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child_inherit</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">    SuperClass.call(<span class=\"keyword\">this</span>, id)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child_inherit.prototype = object(SuperClass.prototype)</span><br><span class=\"line\">Child_inherit.prototype.constructor  = Child_inherit</span><br></pre></td></tr></table></figure></p>\n<p>就OK啦</p>\n<h4 id=\"class完成继承\"><a href=\"#class完成继承\" class=\"headerlink\" title=\"class完成继承\"></a>class完成继承</h4><blockquote>\n<p>上面的方法看着就反人类,官方也这么觉得了,自然现在就有官方的解决办法了.类似JAVA,用class来完成继承<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sayName () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title\">Super</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name, id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name) <span class=\"comment\">// 实现继承</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>关于class见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class\" target=\"_blank\" rel=\"noopener\">more</a></p>\n<h3 id=\"关于ES6中的关键字-super\"><a href=\"#关于ES6中的关键字-super\" class=\"headerlink\" title=\"关于ES6中的关键字 super\"></a>关于ES6中的关键字 super</h3><p>在ES6中使用extend完成继承的话，在子类constructor 中必须使用super关键字。</p>\n<p>同时super可以作为方法，也可以作为对象。作为方法只能在constructor中使用，而在方法中，可以将super作为对象使用。</p>\n<h4 id=\"作为方法\"><a href=\"#作为方法\" class=\"headerlink\" title=\"作为方法\"></a>作为方法</h4><p>在ES6的constructor 中使用super() ，相当于 <code>Super.call()</code></p>\n<h4 id=\"作为对象\"><a href=\"#作为对象\" class=\"headerlink\" title=\"作为对象\"></a>作为对象</h4><h5 id=\"在方法中使用\"><a href=\"#在方法中使用\" class=\"headerlink\" title=\"在方法中使用\"></a>在方法中使用</h5><p>相当于 super 指向 父类的原型 <code>Super.prototype</code>.</p>\n<p>但是super 内部的this 指向的是子类中的this， 所以在使用的时候， 是 <code>Super.prototype.call()</code></p>\n<h5 id=\"在静态方法中使用\"><a href=\"#在静态方法中使用\" class=\"headerlink\" title=\"在静态方法中使用\"></a>在静态方法中使用</h5><p>在静态方法中使用的时候，super 指向的是 Super , 就不再是 Super的原型了</p>\n"},{"title":"Lodash 分析学习","date":"2019-03-07T07:22:17.000Z","_content":"> 稍微拿了几个函数研究了一下lodash的原码, 可以发现几个特点.\n\n一个是函数的防止意外性, 一般在写功能函数的时候,我不会去考虑如果传的参数不是我们想要的类型,会怎么处理.\n然而在lodash中,功能函数都会对不是预料之中的类型做处理的.例如需要返回数组的情况,传参在不符合规范的情况下,函数就会默认的返回一个空数组.而不是直接的报错.\n\n还有就是对位操作符的使用, 两种情况, 一种是需要使用length的时候, 很多时候我们都需要置零,或者是转换成数值类型.\n这个时候用位操作符就可以很方便的解决这个问题.(这个我在之前的位操作符的博客中有写到过,这里做一个大概的总结)\n\n使用>>>0 右移0位,将其他类型置为0, 同时还会把正数转成正整数,一般都是对length使用,完全符合使用场景\n\n使用n >>>1 等同于 parseInt(n / 2), 可以在取中间数的使用,  现在可以想到的使用场景就是二分法中取中间key的时候.\n\n未完待续~","source":"_posts/Lodash-分析学习.md","raw":"---\ntitle: Lodash 分析学习\ndate: 2019-03-07 15:22:17\ntags: js\n---\n> 稍微拿了几个函数研究了一下lodash的原码, 可以发现几个特点.\n\n一个是函数的防止意外性, 一般在写功能函数的时候,我不会去考虑如果传的参数不是我们想要的类型,会怎么处理.\n然而在lodash中,功能函数都会对不是预料之中的类型做处理的.例如需要返回数组的情况,传参在不符合规范的情况下,函数就会默认的返回一个空数组.而不是直接的报错.\n\n还有就是对位操作符的使用, 两种情况, 一种是需要使用length的时候, 很多时候我们都需要置零,或者是转换成数值类型.\n这个时候用位操作符就可以很方便的解决这个问题.(这个我在之前的位操作符的博客中有写到过,这里做一个大概的总结)\n\n使用>>>0 右移0位,将其他类型置为0, 同时还会把正数转成正整数,一般都是对length使用,完全符合使用场景\n\n使用n >>>1 等同于 parseInt(n / 2), 可以在取中间数的使用,  现在可以想到的使用场景就是二分法中取中间key的时候.\n\n未完待续~","slug":"Lodash-分析学习","published":1,"updated":"2019-03-31T02:31:52.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fia000e7dxqz5nooz9x","content":"<blockquote>\n<p>稍微拿了几个函数研究了一下lodash的原码, 可以发现几个特点.</p>\n</blockquote>\n<p>一个是函数的防止意外性, 一般在写功能函数的时候,我不会去考虑如果传的参数不是我们想要的类型,会怎么处理.<br>然而在lodash中,功能函数都会对不是预料之中的类型做处理的.例如需要返回数组的情况,传参在不符合规范的情况下,函数就会默认的返回一个空数组.而不是直接的报错.</p>\n<p>还有就是对位操作符的使用, 两种情况, 一种是需要使用length的时候, 很多时候我们都需要置零,或者是转换成数值类型.<br>这个时候用位操作符就可以很方便的解决这个问题.(这个我在之前的位操作符的博客中有写到过,这里做一个大概的总结)</p>\n<p>使用&gt;&gt;&gt;0 右移0位,将其他类型置为0, 同时还会把正数转成正整数,一般都是对length使用,完全符合使用场景</p>\n<p>使用n &gt;&gt;&gt;1 等同于 parseInt(n / 2), 可以在取中间数的使用,  现在可以想到的使用场景就是二分法中取中间key的时候.</p>\n<p>未完待续~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>稍微拿了几个函数研究了一下lodash的原码, 可以发现几个特点.</p>\n</blockquote>\n<p>一个是函数的防止意外性, 一般在写功能函数的时候,我不会去考虑如果传的参数不是我们想要的类型,会怎么处理.<br>然而在lodash中,功能函数都会对不是预料之中的类型做处理的.例如需要返回数组的情况,传参在不符合规范的情况下,函数就会默认的返回一个空数组.而不是直接的报错.</p>\n<p>还有就是对位操作符的使用, 两种情况, 一种是需要使用length的时候, 很多时候我们都需要置零,或者是转换成数值类型.<br>这个时候用位操作符就可以很方便的解决这个问题.(这个我在之前的位操作符的博客中有写到过,这里做一个大概的总结)</p>\n<p>使用&gt;&gt;&gt;0 右移0位,将其他类型置为0, 同时还会把正数转成正整数,一般都是对length使用,完全符合使用场景</p>\n<p>使用n &gt;&gt;&gt;1 等同于 parseInt(n / 2), 可以在取中间数的使用,  现在可以想到的使用场景就是二分法中取中间key的时候.</p>\n<p>未完待续~</p>\n"},{"title":"babel初探","date":"2019-04-18T03:07:01.000Z","_content":"\n# babel\n\n## babel 做了什么\n\nbabel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。\n\n## 运行方式\n\n分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。\n\n### 插件\n\nbabel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。\n\n同时，插件还分为两种：\n\n1. 语法插件\n\n语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。\n\n和转译插件的差别在于是**否转化**，语法插件只是改变了**解析**的规则\n\n2. 转译插件\n\n转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：\n\nIn: \n```js\nvar a = () => {};\nvar b = () => b;\n```\n经过转译插件之后，Out:\n```js\nvar a = function() {};\nvar b = function () {return b;};\n```\n\n**注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了**\n\n### 使用插件的方式\n\n就是NPM包引入标准的步骤：\n\n1. npm i babel-plugin-xxx 安装\n2. 把插件名字增加到配置文件中\n\n这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。\n\nso，preset(预设)就出来啦。 其实preset就是一整套插件的方案。\n\n","source":"_posts/babel初探.md","raw":"---\ntitle: babel初探\ndate: 2019-04-18 11:07:01\ntags:\n---\n\n# babel\n\n## babel 做了什么\n\nbabel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。\n\n## 运行方式\n\n分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。\n\n### 插件\n\nbabel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。\n\n同时，插件还分为两种：\n\n1. 语法插件\n\n语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。\n\n和转译插件的差别在于是**否转化**，语法插件只是改变了**解析**的规则\n\n2. 转译插件\n\n转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：\n\nIn: \n```js\nvar a = () => {};\nvar b = () => b;\n```\n经过转译插件之后，Out:\n```js\nvar a = function() {};\nvar b = function () {return b;};\n```\n\n**注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了**\n\n### 使用插件的方式\n\n就是NPM包引入标准的步骤：\n\n1. npm i babel-plugin-xxx 安装\n2. 把插件名字增加到配置文件中\n\n这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。\n\nso，preset(预设)就出来啦。 其实preset就是一整套插件的方案。\n\n","slug":"babel初探","published":1,"updated":"2019-04-21T02:21:22.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fic000f7dxqbgmvgm08","content":"<h1 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h1><h2 id=\"babel-做了什么\"><a href=\"#babel-做了什么\" class=\"headerlink\" title=\"babel 做了什么\"></a>babel 做了什么</h2><p>babel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。</p>\n<h2 id=\"运行方式\"><a href=\"#运行方式\" class=\"headerlink\" title=\"运行方式\"></a>运行方式</h2><p>分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>babel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。</p>\n<p>同时，插件还分为两种：</p>\n<ol>\n<li>语法插件</li>\n</ol>\n<p>语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。</p>\n<p>和转译插件的差别在于是<strong>否转化</strong>，语法插件只是改变了<strong>解析</strong>的规则</p>\n<ol start=\"2\">\n<li>转译插件</li>\n</ol>\n<p>转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：</p>\n<p>In:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> b;</span><br></pre></td></tr></table></figure></p>\n<p>经过转译插件之后，Out:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> b;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了</strong></p>\n<h3 id=\"使用插件的方式\"><a href=\"#使用插件的方式\" class=\"headerlink\" title=\"使用插件的方式\"></a>使用插件的方式</h3><p>就是NPM包引入标准的步骤：</p>\n<ol>\n<li>npm i babel-plugin-xxx 安装</li>\n<li>把插件名字增加到配置文件中</li>\n</ol>\n<p>这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。</p>\n<p>so，preset(预设)就出来啦。 其实preset就是一整套插件的方案。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h1><h2 id=\"babel-做了什么\"><a href=\"#babel-做了什么\" class=\"headerlink\" title=\"babel 做了什么\"></a>babel 做了什么</h2><p>babel 就是将js中新的语法转化成低版本的JS，一般转成ES5大部分浏览器就够了。</p>\n<h2 id=\"运行方式\"><a href=\"#运行方式\" class=\"headerlink\" title=\"运行方式\"></a>运行方式</h2><p>分为三个阶段：解析，转换，生成。 其中的具体功能是利用AST实现的。</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>babel本身不具有转化的功能，转化的功能都被分解到plugin中去了。这样利用控制，同时在使用babel时候，配置就是必不可少的了。</p>\n<p>同时，插件还分为两种：</p>\n<ol>\n<li>语法插件</li>\n</ol>\n<p>语法插件主要是用于新语法中一些新提供的语法，在老版本中，会认为是错误的语法，而在新版中认为是可以使用的语法。使用语法插件后，就不会报错，会认为这样是正确的。</p>\n<p>和转译插件的差别在于是<strong>否转化</strong>，语法插件只是改变了<strong>解析</strong>的规则</p>\n<ol start=\"2\">\n<li>转译插件</li>\n</ol>\n<p>转译插件插件则是为了支持新式的代码，将它转化成浏览器支持的版本。例如箭头函数：</p>\n<p>In:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> b;</span><br></pre></td></tr></table></figure></p>\n<p>经过转译插件之后，Out:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> b;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意的是，转译插件中会用到语法插件的情况，转译插件会直接启动，不同我们同时制定了</strong></p>\n<h3 id=\"使用插件的方式\"><a href=\"#使用插件的方式\" class=\"headerlink\" title=\"使用插件的方式\"></a>使用插件的方式</h3><p>就是NPM包引入标准的步骤：</p>\n<ol>\n<li>npm i babel-plugin-xxx 安装</li>\n<li>把插件名字增加到配置文件中</li>\n</ol>\n<p>这个时候肯定会觉得，那一个项目得用到的插件肯定很多啊，这么一个一个的配置肯定很麻烦啊。</p>\n<p>so，preset(预设)就出来啦。 其实preset就是一整套插件的方案。</p>\n"},{"title":"Regex Golf闯关记录","date":"2019-04-05T02:43:24.000Z","_content":"\n> 这篇博客是对[Regex Golf](https://alf.nu/RegexGolf)答案的记录和总结\n\n## Order\n\n`^[^o].....?$` 通过个数判断\n\n","source":"_posts/Regex-Golf闯关记录.md","raw":"---\ntitle: Regex Golf闯关记录\ndate: 2019-04-05 10:43:24\ntags: \n---\n\n> 这篇博客是对[Regex Golf](https://alf.nu/RegexGolf)答案的记录和总结\n\n## Order\n\n`^[^o].....?$` 通过个数判断\n\n","slug":"Regex-Golf闯关记录","published":1,"updated":"2019-04-05T09:17:32.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fig000j7dxqksns7x74","content":"<blockquote>\n<p>这篇博客是对<a href=\"https://alf.nu/RegexGolf\" target=\"_blank\" rel=\"noopener\">Regex Golf</a>答案的记录和总结</p>\n</blockquote>\n<h2 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a>Order</h2><p><code>^[^o].....?$</code> 通过个数判断</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这篇博客是对<a href=\"https://alf.nu/RegexGolf\" target=\"_blank\" rel=\"noopener\">Regex Golf</a>答案的记录和总结</p>\n</blockquote>\n<h2 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a>Order</h2><p><code>^[^o].....?$</code> 通过个数判断</p>\n"},{"title":"css遗漏知识总结","date":"2019-04-03T02:04:22.000Z","_content":"\n## class匹配符\n  \n```css\n[class$='xxx']{\n\n}\n\n[class^='xxx']{\n    \n}\n```\n\n这两种对类匹配都可以对名称进行帅选。\n\n## sticky 布局\n\n使用sticky可以轻易的实现固定表头类似的需求。使用方法:\n\n```css\n.demo{\n    position:sticky;\n    top: 200px\n}\n```\n\n在使用position 为 sticky的时候，还需要指定 `left` `right` `top` `bottom` 四个值中的任意一个。\n\n指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。\n\n### 注意事项\n\n1. sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。\n\n2. sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。\n\n3. 其父元素必须得可以scroll，才可以生效。\n\n4. 左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的\n\n\n其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。\n\n\n## window.getComputedStyle() 方法\n\n```js\nlet style = window.getComputedStyle(ele, [pseudoElement])\n```\n\npseudoElement 是伪元素，没有可以不传或者传null。\n\n返回的值是实时的 `CSSStyleDeclaration` 对象，该对象会实时更新属性。\n\n*这个返回的CSSStyleDeclaration对象是只读的，不能修改。*\n\n### CSSStyleDeclaration 对象\n\n除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。\n\n但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是*可以修改*的\n\n#### CSSStyleDeclaration.getPropertyPriority(property_name)\n\n返回可选的优先级，”Important\", 例如： priString= styleObj.getPropertyPriority('color')\n\n#### CSSStyleDeclaration.getPropertyValue(property_name)\n\n属性名可以使用驼峰命名法。\n\n返回属性值。例如: valString= styleObj.getPropertyValue('color')\n\n#### CSSStyleDeclaration.removeProperty(property_name)\n\n返回被删除的属性。\n\n### CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])\n\n没有返回值。设置属性值。\n\n*后面两个方法都只有在 style 方法中获取的对象可以使用*\n\n### 影响\n\n使用这个方法会导致页面回流。\n\n## 可以继承的css属性\n\n> 这个问题，记不住啊..得想个办法\n\n继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。\n\n而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。\n\n不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。\n\n所有元素可继承：visibility 和 cursor。\n\n内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。\n\n### 总结\n\n可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。\n暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。\n\nvisibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。\n\n想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。","source":"_posts/css遗漏知识总结.md","raw":"---\ntitle: css遗漏知识总结\ndate: 2019-04-03 10:04:22\ntags:\n---\n\n## class匹配符\n  \n```css\n[class$='xxx']{\n\n}\n\n[class^='xxx']{\n    \n}\n```\n\n这两种对类匹配都可以对名称进行帅选。\n\n## sticky 布局\n\n使用sticky可以轻易的实现固定表头类似的需求。使用方法:\n\n```css\n.demo{\n    position:sticky;\n    top: 200px\n}\n```\n\n在使用position 为 sticky的时候，还需要指定 `left` `right` `top` `bottom` 四个值中的任意一个。\n\n指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。\n\n### 注意事项\n\n1. sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。\n\n2. sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。\n\n3. 其父元素必须得可以scroll，才可以生效。\n\n4. 左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的\n\n\n其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。\n\n\n## window.getComputedStyle() 方法\n\n```js\nlet style = window.getComputedStyle(ele, [pseudoElement])\n```\n\npseudoElement 是伪元素，没有可以不传或者传null。\n\n返回的值是实时的 `CSSStyleDeclaration` 对象，该对象会实时更新属性。\n\n*这个返回的CSSStyleDeclaration对象是只读的，不能修改。*\n\n### CSSStyleDeclaration 对象\n\n除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。\n\n但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是*可以修改*的\n\n#### CSSStyleDeclaration.getPropertyPriority(property_name)\n\n返回可选的优先级，”Important\", 例如： priString= styleObj.getPropertyPriority('color')\n\n#### CSSStyleDeclaration.getPropertyValue(property_name)\n\n属性名可以使用驼峰命名法。\n\n返回属性值。例如: valString= styleObj.getPropertyValue('color')\n\n#### CSSStyleDeclaration.removeProperty(property_name)\n\n返回被删除的属性。\n\n### CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])\n\n没有返回值。设置属性值。\n\n*后面两个方法都只有在 style 方法中获取的对象可以使用*\n\n### 影响\n\n使用这个方法会导致页面回流。\n\n## 可以继承的css属性\n\n> 这个问题，记不住啊..得想个办法\n\n继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。\n\n而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。\n\n不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。\n\n所有元素可继承：visibility 和 cursor。\n\n内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。\n\n### 总结\n\n可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。\n暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。\n\nvisibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。\n\n想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。","slug":"css遗漏知识总结","published":1,"updated":"2019-04-21T02:21:22.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fij000l7dxqqncwyngi","content":"<h2 id=\"class匹配符\"><a href=\"#class匹配符\" class=\"headerlink\" title=\"class匹配符\"></a>class匹配符</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class$='xxx']</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class^='xxx']</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两种对类匹配都可以对名称进行帅选。</p>\n<h2 id=\"sticky-布局\"><a href=\"#sticky-布局\" class=\"headerlink\" title=\"sticky 布局\"></a>sticky 布局</h2><p>使用sticky可以轻易的实现固定表头类似的需求。使用方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:sticky;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">200px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在使用position 为 sticky的时候，还需要指定 <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 四个值中的任意一个。</p>\n<p>指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。</p>\n</li>\n<li><p>sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。</p>\n</li>\n<li><p>其父元素必须得可以scroll，才可以生效。</p>\n</li>\n<li><p>左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的</p>\n</li>\n</ol>\n<p>其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。</p>\n<h2 id=\"window-getComputedStyle-方法\"><a href=\"#window-getComputedStyle-方法\" class=\"headerlink\" title=\"window.getComputedStyle() 方法\"></a>window.getComputedStyle() 方法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> style = <span class=\"built_in\">window</span>.getComputedStyle(ele, [pseudoElement])</span><br></pre></td></tr></table></figure>\n<p>pseudoElement 是伪元素，没有可以不传或者传null。</p>\n<p>返回的值是实时的 <code>CSSStyleDeclaration</code> 对象，该对象会实时更新属性。</p>\n<p><em>这个返回的CSSStyleDeclaration对象是只读的，不能修改。</em></p>\n<h3 id=\"CSSStyleDeclaration-对象\"><a href=\"#CSSStyleDeclaration-对象\" class=\"headerlink\" title=\"CSSStyleDeclaration 对象\"></a>CSSStyleDeclaration 对象</h3><p>除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。</p>\n<p>但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是<em>可以修改</em>的</p>\n<h4 id=\"CSSStyleDeclaration-getPropertyPriority-property-name\"><a href=\"#CSSStyleDeclaration-getPropertyPriority-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.getPropertyPriority(property_name)\"></a>CSSStyleDeclaration.getPropertyPriority(property_name)</h4><p>返回可选的优先级，”Important”, 例如： priString= styleObj.getPropertyPriority(‘color’)</p>\n<h4 id=\"CSSStyleDeclaration-getPropertyValue-property-name\"><a href=\"#CSSStyleDeclaration-getPropertyValue-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.getPropertyValue(property_name)\"></a>CSSStyleDeclaration.getPropertyValue(property_name)</h4><p>属性名可以使用驼峰命名法。</p>\n<p>返回属性值。例如: valString= styleObj.getPropertyValue(‘color’)</p>\n<h4 id=\"CSSStyleDeclaration-removeProperty-property-name\"><a href=\"#CSSStyleDeclaration-removeProperty-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.removeProperty(property_name)\"></a>CSSStyleDeclaration.removeProperty(property_name)</h4><p>返回被删除的属性。</p>\n<h3 id=\"CSSStyleDeclaration-setProperty-property-name-property-val-property-priority\"><a href=\"#CSSStyleDeclaration-setProperty-property-name-property-val-property-priority\" class=\"headerlink\" title=\"CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])\"></a>CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])</h3><p>没有返回值。设置属性值。</p>\n<p><em>后面两个方法都只有在 style 方法中获取的对象可以使用</em></p>\n<h3 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h3><p>使用这个方法会导致页面回流。</p>\n<h2 id=\"可以继承的css属性\"><a href=\"#可以继承的css属性\" class=\"headerlink\" title=\"可以继承的css属性\"></a>可以继承的css属性</h2><blockquote>\n<p>这个问题，记不住啊..得想个办法</p>\n</blockquote>\n<p>继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。</p>\n<p>而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。</p>\n<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</p>\n<p>所有元素可继承：visibility 和 cursor。</p>\n<p>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。<br>暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。</p>\n<p>visibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。</p>\n<p>想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"class匹配符\"><a href=\"#class匹配符\" class=\"headerlink\" title=\"class匹配符\"></a>class匹配符</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[class$='xxx']</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-attr\">[class^='xxx']</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两种对类匹配都可以对名称进行帅选。</p>\n<h2 id=\"sticky-布局\"><a href=\"#sticky-布局\" class=\"headerlink\" title=\"sticky 布局\"></a>sticky 布局</h2><p>使用sticky可以轻易的实现固定表头类似的需求。使用方法:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>:sticky;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">200px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在使用position 为 sticky的时候，还需要指定 <code>left</code> <code>right</code> <code>top</code> <code>bottom</code> 四个值中的任意一个。</p>\n<p>指定的这个值，会作为一个阈值，当到达这个值之后，就会被固定在这个位置。</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>sticky 的元素不会脱离其父元素的，就是会一直在父元素内部。如果父元素不在可视范围之内，也是会消失的。</p>\n</li>\n<li><p>sticky 的元素没有脱离文档流，不会导致后面的元素占用其位置。</p>\n</li>\n<li><p>其父元素必须得可以scroll，才可以生效。</p>\n</li>\n<li><p>左边(left)的优先级大于右边(right)，上面(top)的大于下面(bottom)的</p>\n</li>\n</ol>\n<p>其实看上来，sticky 的效果像是 absolute 和 fixed 的结合，在判断阈值的时候，是通过和视窗的距离判断；但是在过阈值之后又变成绝对定位。</p>\n<h2 id=\"window-getComputedStyle-方法\"><a href=\"#window-getComputedStyle-方法\" class=\"headerlink\" title=\"window.getComputedStyle() 方法\"></a>window.getComputedStyle() 方法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> style = <span class=\"built_in\">window</span>.getComputedStyle(ele, [pseudoElement])</span><br></pre></td></tr></table></figure>\n<p>pseudoElement 是伪元素，没有可以不传或者传null。</p>\n<p>返回的值是实时的 <code>CSSStyleDeclaration</code> 对象，该对象会实时更新属性。</p>\n<p><em>这个返回的CSSStyleDeclaration对象是只读的，不能修改。</em></p>\n<h3 id=\"CSSStyleDeclaration-对象\"><a href=\"#CSSStyleDeclaration-对象\" class=\"headerlink\" title=\"CSSStyleDeclaration 对象\"></a>CSSStyleDeclaration 对象</h3><p>除了上面的getComputedStyle 方法会返回 CSSStyleDeclaration 外， style 属性返回的也是一个 CSSStyleDeclaration 对象。</p>\n<p>但是，差别在于，style 只能获取内联的样式（也就是直接写在HTML 标签中的），不过这个对象是<em>可以修改</em>的</p>\n<h4 id=\"CSSStyleDeclaration-getPropertyPriority-property-name\"><a href=\"#CSSStyleDeclaration-getPropertyPriority-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.getPropertyPriority(property_name)\"></a>CSSStyleDeclaration.getPropertyPriority(property_name)</h4><p>返回可选的优先级，”Important”, 例如： priString= styleObj.getPropertyPriority(‘color’)</p>\n<h4 id=\"CSSStyleDeclaration-getPropertyValue-property-name\"><a href=\"#CSSStyleDeclaration-getPropertyValue-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.getPropertyValue(property_name)\"></a>CSSStyleDeclaration.getPropertyValue(property_name)</h4><p>属性名可以使用驼峰命名法。</p>\n<p>返回属性值。例如: valString= styleObj.getPropertyValue(‘color’)</p>\n<h4 id=\"CSSStyleDeclaration-removeProperty-property-name\"><a href=\"#CSSStyleDeclaration-removeProperty-property-name\" class=\"headerlink\" title=\"CSSStyleDeclaration.removeProperty(property_name)\"></a>CSSStyleDeclaration.removeProperty(property_name)</h4><p>返回被删除的属性。</p>\n<h3 id=\"CSSStyleDeclaration-setProperty-property-name-property-val-property-priority\"><a href=\"#CSSStyleDeclaration-setProperty-property-name-property-val-property-priority\" class=\"headerlink\" title=\"CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])\"></a>CSSStyleDeclaration.setProperty(property_name.property_val[, property_priority])</h3><p>没有返回值。设置属性值。</p>\n<p><em>后面两个方法都只有在 style 方法中获取的对象可以使用</em></p>\n<h3 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h3><p>使用这个方法会导致页面回流。</p>\n<h2 id=\"可以继承的css属性\"><a href=\"#可以继承的css属性\" class=\"headerlink\" title=\"可以继承的css属性\"></a>可以继承的css属性</h2><blockquote>\n<p>这个问题，记不住啊..得想个办法</p>\n</blockquote>\n<p>继承属性就是，当一个元素没有设定这个属性的值的时候，则取父元素同属性的计算值。</p>\n<p>而非继承属性就是，属性没有设定值的时候，就设为属性的初始值。</p>\n<p>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</p>\n<p>所有元素可继承：visibility 和 cursor。</p>\n<p>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>可以发现，元素可以继承的属性都是内部样式的属性。例如：颜色，字距，字体，字体顺序。<br>暂时来个总结，一般可以继承的属性，都是元素内容字体的属性，包括颜色，字体，排版，风格。</p>\n<p>visibility 和 cursor 可以继承，也是可以理解的，外部的都不可见了，里面的怎么还能看见呢。</p>\n<p>想来也是，如果子元素的这些元素都与父元素不一致，看上去很不舒畅。</p>\n"},{"title":"一些常见的面试题","url":"94.html","id":"94","date":"2019-01-08T02:33:09.000Z","_content":"\n> 这里记录都是一些很常见的面试题 经常遇到,但是搞得并不是很清楚\n\n1.  \\[\"1\", \"2\", \"3\"\\].map(parseInt); 先看上面这道题,很常见吧.结果是什么呢,反正不是\\[1,2,3\\]就是了 正确的应该是\\[1, NaN, NaN\\]. 刚开始我不知道为什么,只是记到parentInt接受的参数有两个所以.. `js console.log(parseInt.length) // 2` 第二个参数是指定传入参数的进制,默认是10进制的 而返回都是10进制的 我开始以为是因为把 数组中'1','2'一起传过去了.并不是这样滴 看map函数\n```js\n    [\"1\", \"2\", \"3\"].map(console.log)\n    /**\n    1 0 [ '1', '2', '3' ]\n    2 1 [ '1', '2', '3' ]\n    3 2 [ '1', '2', '3' ]\n    */\n```    \n\n可以看到还是因为map本身参数是有三个的,所以上面的题目中传入的值是 '1' 0 '2' 1 '3' 2 2并不是一个1进制的树,3也不是.return NaN 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。","source":"_posts/e4-b8-80-e4-ba-9b-e5-b8-b8-e8-a7-81-e7-9a-84-e9-9d-a2-e8-af-95-e9-a2-98.md","raw":"---\ntitle: 一些常见的面试题\nurl: 94.html\nid: 94\ncategories:\n  - 总结\ndate: 2019-01-08 10:33:09\ntags:\n---\n\n> 这里记录都是一些很常见的面试题 经常遇到,但是搞得并不是很清楚\n\n1.  \\[\"1\", \"2\", \"3\"\\].map(parseInt); 先看上面这道题,很常见吧.结果是什么呢,反正不是\\[1,2,3\\]就是了 正确的应该是\\[1, NaN, NaN\\]. 刚开始我不知道为什么,只是记到parentInt接受的参数有两个所以.. `js console.log(parseInt.length) // 2` 第二个参数是指定传入参数的进制,默认是10进制的 而返回都是10进制的 我开始以为是因为把 数组中'1','2'一起传过去了.并不是这样滴 看map函数\n```js\n    [\"1\", \"2\", \"3\"].map(console.log)\n    /**\n    1 0 [ '1', '2', '3' ]\n    2 1 [ '1', '2', '3' ]\n    3 2 [ '1', '2', '3' ]\n    */\n```    \n\n可以看到还是因为map本身参数是有三个的,所以上面的题目中传入的值是 '1' 0 '2' 1 '3' 2 2并不是一个1进制的树,3也不是.return NaN 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。","slug":"e4-b8-80-e4-ba-9b-e5-b8-b8-e8-a7-81-e7-9a-84-e9-9d-a2-e8-af-95-e9-a2-98","published":1,"updated":"2019-03-07T11:39:38.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fim000o7dxq16lnac5q","content":"<blockquote>\n<p>这里记录都是一些很常见的面试题 经常遇到,但是搞得并不是很清楚</p>\n</blockquote>\n<ol>\n<li>[“1”, “2”, “3”].map(parseInt); 先看上面这道题,很常见吧.结果是什么呢,反正不是[1,2,3]就是了 正确的应该是[1, NaN, NaN]. 刚开始我不知道为什么,只是记到parentInt接受的参数有两个所以.. <code>js console.log(parseInt.length) // 2</code> 第二个参数是指定传入参数的进制,默认是10进制的 而返回都是10进制的 我开始以为是因为把 数组中’1’,’2’一起传过去了.并不是这样滴 看map函数<pre><code class=\"js\">[<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>].map(<span class=\"built_in\">console</span>.log)\n<span class=\"comment\">/**</span>\n<span class=\"comment\">1 0 [ '1', '2', '3' ]</span>\n<span class=\"comment\">2 1 [ '1', '2', '3' ]</span>\n<span class=\"comment\">3 2 [ '1', '2', '3' ]</span>\n<span class=\"comment\">*/</span>\n</code></pre>\n</li>\n</ol>\n<p>可以看到还是因为map本身参数是有三个的,所以上面的题目中传入的值是 ‘1’ 0 ‘2’ 1 ‘3’ 2 2并不是一个1进制的树,3也不是.return NaN 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这里记录都是一些很常见的面试题 经常遇到,但是搞得并不是很清楚</p>\n</blockquote>\n<ol>\n<li>[“1”, “2”, “3”].map(parseInt); 先看上面这道题,很常见吧.结果是什么呢,反正不是[1,2,3]就是了 正确的应该是[1, NaN, NaN]. 刚开始我不知道为什么,只是记到parentInt接受的参数有两个所以.. <code>js console.log(parseInt.length) // 2</code> 第二个参数是指定传入参数的进制,默认是10进制的 而返回都是10进制的 我开始以为是因为把 数组中’1’,’2’一起传过去了.并不是这样滴 看map函数<pre><code class=\"js\">[<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>].map(<span class=\"built_in\">console</span>.log)\n<span class=\"comment\">/**</span>\n<span class=\"comment\">1 0 [ '1', '2', '3' ]</span>\n<span class=\"comment\">2 1 [ '1', '2', '3' ]</span>\n<span class=\"comment\">3 2 [ '1', '2', '3' ]</span>\n<span class=\"comment\">*/</span>\n</code></pre>\n</li>\n</ol>\n<p>可以看到还是因为map本身参数是有三个的,所以上面的题目中传入的值是 ‘1’ 0 ‘2’ 1 ‘3’ 2 2并不是一个1进制的树,3也不是.return NaN 当参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>\n"},{"title":"http缓存","date":"2019-03-27T08:18:20.000Z","_content":"\n> 这篇博客纯粹是搬运，因为这些知识都是看来的，没有实践过。\n\n原先的时候http缓存(强缓存)是直接设定缓存的时间，如果时间过了，就去服务器请求新的数据。\n\n如果时间没有过，就直接从缓存数据中读取数据，**不会发送请求**。\n\n用到的字段有： \n\nExpire： 设置缓存过期时间，使用的是GMT(格林尼治时间)，这个时间是相对于服务器的\n\n而由于时间是对于服务器的，无法统一。 就使用了一个新的字段： **cache-control**\n\ncache-control：设置 max-age=t 直接设置绝对过期时间\n同时，还有其他的属性：\n\n字段名称 | 说明\n----- | -----\nno-cache | 代理服务器不能缓存数据，如果是在请求阶段就是，直接向服务器发送请求\nno-store | 所有的内容都不能被缓存\nprivate [= 'field-name'] | 指定的用户或者缓存服务器才能缓存数据 \npublic | **只出现在响应头中**，任何情况下都需要缓存数据\nmax-age=t | 请求时：告知服务器接收一个在t时间之内的数据; 返回时，告知t时间内，数据不同再请求\n\ncache-control 中的属性可以设置多个，自由组合\n\n上面的字段决定了是否会发出请求，但是请求发出之后，也不是一定会再次发送数据的。还需要进行验证\n\n### 缓存校验字段\n","source":"_posts/http缓存.md","raw":"---\ntitle: http缓存\ndate: 2019-03-27 16:18:20\ntags: http\n---\n\n> 这篇博客纯粹是搬运，因为这些知识都是看来的，没有实践过。\n\n原先的时候http缓存(强缓存)是直接设定缓存的时间，如果时间过了，就去服务器请求新的数据。\n\n如果时间没有过，就直接从缓存数据中读取数据，**不会发送请求**。\n\n用到的字段有： \n\nExpire： 设置缓存过期时间，使用的是GMT(格林尼治时间)，这个时间是相对于服务器的\n\n而由于时间是对于服务器的，无法统一。 就使用了一个新的字段： **cache-control**\n\ncache-control：设置 max-age=t 直接设置绝对过期时间\n同时，还有其他的属性：\n\n字段名称 | 说明\n----- | -----\nno-cache | 代理服务器不能缓存数据，如果是在请求阶段就是，直接向服务器发送请求\nno-store | 所有的内容都不能被缓存\nprivate [= 'field-name'] | 指定的用户或者缓存服务器才能缓存数据 \npublic | **只出现在响应头中**，任何情况下都需要缓存数据\nmax-age=t | 请求时：告知服务器接收一个在t时间之内的数据; 返回时，告知t时间内，数据不同再请求\n\ncache-control 中的属性可以设置多个，自由组合\n\n上面的字段决定了是否会发出请求，但是请求发出之后，也不是一定会再次发送数据的。还需要进行验证\n\n### 缓存校验字段\n","slug":"http缓存","published":1,"updated":"2019-03-31T02:31:52.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fio000q7dxq6tq5pq0i","content":"<blockquote>\n<p>这篇博客纯粹是搬运，因为这些知识都是看来的，没有实践过。</p>\n</blockquote>\n<p>原先的时候http缓存(强缓存)是直接设定缓存的时间，如果时间过了，就去服务器请求新的数据。</p>\n<p>如果时间没有过，就直接从缓存数据中读取数据，<strong>不会发送请求</strong>。</p>\n<p>用到的字段有： </p>\n<p>Expire： 设置缓存过期时间，使用的是GMT(格林尼治时间)，这个时间是相对于服务器的</p>\n<p>而由于时间是对于服务器的，无法统一。 就使用了一个新的字段： <strong>cache-control</strong></p>\n<p>cache-control：设置 max-age=t 直接设置绝对过期时间<br>同时，还有其他的属性：</p>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td>代理服务器不能缓存数据，如果是在请求阶段就是，直接向服务器发送请求</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>所有的内容都不能被缓存</td>\n</tr>\n<tr>\n<td>private [= ‘field-name’]</td>\n<td>指定的用户或者缓存服务器才能缓存数据 </td>\n</tr>\n<tr>\n<td>public</td>\n<td><strong>只出现在响应头中</strong>，任何情况下都需要缓存数据</td>\n</tr>\n<tr>\n<td>max-age=t</td>\n<td>请求时：告知服务器接收一个在t时间之内的数据; 返回时，告知t时间内，数据不同再请求</td>\n</tr>\n</tbody>\n</table>\n<p>cache-control 中的属性可以设置多个，自由组合</p>\n<p>上面的字段决定了是否会发出请求，但是请求发出之后，也不是一定会再次发送数据的。还需要进行验证</p>\n<h3 id=\"缓存校验字段\"><a href=\"#缓存校验字段\" class=\"headerlink\" title=\"缓存校验字段\"></a>缓存校验字段</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这篇博客纯粹是搬运，因为这些知识都是看来的，没有实践过。</p>\n</blockquote>\n<p>原先的时候http缓存(强缓存)是直接设定缓存的时间，如果时间过了，就去服务器请求新的数据。</p>\n<p>如果时间没有过，就直接从缓存数据中读取数据，<strong>不会发送请求</strong>。</p>\n<p>用到的字段有： </p>\n<p>Expire： 设置缓存过期时间，使用的是GMT(格林尼治时间)，这个时间是相对于服务器的</p>\n<p>而由于时间是对于服务器的，无法统一。 就使用了一个新的字段： <strong>cache-control</strong></p>\n<p>cache-control：设置 max-age=t 直接设置绝对过期时间<br>同时，还有其他的属性：</p>\n<table>\n<thead>\n<tr>\n<th>字段名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>no-cache</td>\n<td>代理服务器不能缓存数据，如果是在请求阶段就是，直接向服务器发送请求</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>所有的内容都不能被缓存</td>\n</tr>\n<tr>\n<td>private [= ‘field-name’]</td>\n<td>指定的用户或者缓存服务器才能缓存数据 </td>\n</tr>\n<tr>\n<td>public</td>\n<td><strong>只出现在响应头中</strong>，任何情况下都需要缓存数据</td>\n</tr>\n<tr>\n<td>max-age=t</td>\n<td>请求时：告知服务器接收一个在t时间之内的数据; 返回时，告知t时间内，数据不同再请求</td>\n</tr>\n</tbody>\n</table>\n<p>cache-control 中的属性可以设置多个，自由组合</p>\n<p>上面的字段决定了是否会发出请求，但是请求发出之后，也不是一定会再次发送数据的。还需要进行验证</p>\n<h3 id=\"缓存校验字段\"><a href=\"#缓存校验字段\" class=\"headerlink\" title=\"缓存校验字段\"></a>缓存校验字段</h3>"},{"title":"js 错误捕获总结","date":"2019-04-15T07:01:10.000Z","_content":"\n大纲\n * try...catch\n * window.onerror\n * window.addEventLister('error',function(){}[,Boolean-IsCapture])\n\n 1. try..catch\n\n try...catch是在运行时捕获错误，并用catch处理错误。\n\n 但是不能处理异步的错误，promise的错误也捕获不到。\n\n 如果是任何情况下都要执行的代码，可以用 finally 子句。\n\n ```js\n try {\n     console.log(1)\n } catch(error) {\n     console.log(2)\n } finally {\n     console.log(0)\n }\n ```\n\n 2. window.onerror\n\n 与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。\n\n 使用方法:\n ```js\n window.onerror = function(message, source, lineno, colno, error){ ... return true/false}\n ```\n默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。\n\n**注意** `element.onerror = function(event){}`\n\n这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。\n\n同时，这里的错误是不会冒泡到window的错误处理方法上的。\n\n3. window.addEventLister('error',function(){}[,Boolean])\n\n3-1. 事件流\n\n> 题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法\n\n好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。\n\n首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。\n\n![捕获冒泡](https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png)\n\n使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。\n\n捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。\n\n3-2. stopPropagation()  preventDefault()\n\n上面的两个方法都会讲事件流在使用位置停止。\n\n3-3 e.target  e.currentTarget\n\ncurrentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素\n\n> 回到正题，addEventListener('error',function(){...},...isCapture)\n\n资源加载时候的错误，是不会传到window的 onerror 上面去的。\n\n复习了事件流之后，这个地方的监听资源的报错，得在 **捕获** 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）\n\n<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：\n\n在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`\n\n我的一个猜想，应该是这个错误对象只有 -->\n\n> error 产生的流，是个怎么样的流向啊，还没有找到。。\n\n> 而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。\n\n```js\nwindow.addEventListener('error', (msg, url, row, col, error) => {\n    console.log('我知道错误了');\n    console.log(\n        msg, url, row, col, error\n    );\n    return true; // 貌似没有啥用\n}, true);\n```","source":"_posts/js-错误捕获总结.md","raw":"---\ntitle: js 错误捕获总结\ndate: 2019-04-15 15:01:10\ntags:\n---\n\n大纲\n * try...catch\n * window.onerror\n * window.addEventLister('error',function(){}[,Boolean-IsCapture])\n\n 1. try..catch\n\n try...catch是在运行时捕获错误，并用catch处理错误。\n\n 但是不能处理异步的错误，promise的错误也捕获不到。\n\n 如果是任何情况下都要执行的代码，可以用 finally 子句。\n\n ```js\n try {\n     console.log(1)\n } catch(error) {\n     console.log(2)\n } finally {\n     console.log(0)\n }\n ```\n\n 2. window.onerror\n\n 与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。\n\n 使用方法:\n ```js\n window.onerror = function(message, source, lineno, colno, error){ ... return true/false}\n ```\n默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。\n\n**注意** `element.onerror = function(event){}`\n\n这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。\n\n同时，这里的错误是不会冒泡到window的错误处理方法上的。\n\n3. window.addEventLister('error',function(){}[,Boolean])\n\n3-1. 事件流\n\n> 题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法\n\n好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。\n\n首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。\n\n![捕获冒泡](https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png)\n\n使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。\n\n捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。\n\n3-2. stopPropagation()  preventDefault()\n\n上面的两个方法都会讲事件流在使用位置停止。\n\n3-3 e.target  e.currentTarget\n\ncurrentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素\n\n> 回到正题，addEventListener('error',function(){...},...isCapture)\n\n资源加载时候的错误，是不会传到window的 onerror 上面去的。\n\n复习了事件流之后，这个地方的监听资源的报错，得在 **捕获** 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）\n\n<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：\n\n在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`\n\n我的一个猜想，应该是这个错误对象只有 -->\n\n> error 产生的流，是个怎么样的流向啊，还没有找到。。\n\n> 而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。\n\n```js\nwindow.addEventListener('error', (msg, url, row, col, error) => {\n    console.log('我知道错误了');\n    console.log(\n        msg, url, row, col, error\n    );\n    return true; // 貌似没有啥用\n}, true);\n```","slug":"js-错误捕获总结","published":1,"updated":"2019-04-21T02:21:22.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fir000t7dxq4bmft2o8","content":"<p>大纲</p>\n<ul>\n<li>try…catch</li>\n<li>window.onerror</li>\n<li>window.addEventLister(‘error’,function(){}[,Boolean-IsCapture])</li>\n</ul>\n<ol>\n<li><p>try..catch</p>\n<p>try…catch是在运行时捕获错误，并用catch处理错误。</p>\n<p>但是不能处理异步的错误，promise的错误也捕获不到。</p>\n<p>如果是任何情况下都要执行的代码，可以用 finally 子句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>window.onerror</p>\n<p>与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。</p>\n<p>使用方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message, source, lineno, colno, error</span>)</span>&#123; ... return <span class=\"literal\">true</span>/<span class=\"literal\">false</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。</p>\n<p><strong>注意</strong> <code>element.onerror = function(event){}</code></p>\n<p>这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。</p>\n<p>同时，这里的错误是不会冒泡到window的错误处理方法上的。</p>\n<ol start=\"3\">\n<li>window.addEventLister(‘error’,function(){}[,Boolean])</li>\n</ol>\n<p>3-1. 事件流</p>\n<blockquote>\n<p>题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法</p>\n</blockquote>\n<p>好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。</p>\n<p>首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png\" alt=\"捕获冒泡\"></p>\n<p>使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。</p>\n<p>捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。</p>\n<p>3-2. stopPropagation()  preventDefault()</p>\n<p>上面的两个方法都会讲事件流在使用位置停止。</p>\n<p>3-3 e.target  e.currentTarget</p>\n<p>currentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素</p>\n<blockquote>\n<p>回到正题，addEventListener(‘error’,function(){…},…isCapture)</p>\n</blockquote>\n<p>资源加载时候的错误，是不会传到window的 onerror 上面去的。</p>\n<p>复习了事件流之后，这个地方的监听资源的报错，得在 <strong>捕获</strong> 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）</p>\n<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：\n\n在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`\n\n我的一个猜想，应该是这个错误对象只有 -->\n<blockquote>\n<p>error 产生的流，是个怎么样的流向啊，还没有找到。。</p>\n</blockquote>\n<blockquote>\n<p>而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'error'</span>, (msg, url, row, col, error) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我知道错误了'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        msg, url, row, col, error</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 貌似没有啥用</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>大纲</p>\n<ul>\n<li>try…catch</li>\n<li>window.onerror</li>\n<li>window.addEventLister(‘error’,function(){}[,Boolean-IsCapture])</li>\n</ul>\n<ol>\n<li><p>try..catch</p>\n<p>try…catch是在运行时捕获错误，并用catch处理错误。</p>\n<p>但是不能处理异步的错误，promise的错误也捕获不到。</p>\n<p>如果是任何情况下都要执行的代码，可以用 finally 子句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>window.onerror</p>\n<p>与try catch 的区别，使用try catch错误被捕获了之后，JS会继续进行下去，但是使用window.onerror 虽然会监听到错误，但是JS 会在此处停止运行, 但是try catch 就不会。</p>\n<p>使用方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message, source, lineno, colno, error</span>)</span>&#123; ... return <span class=\"literal\">true</span>/<span class=\"literal\">false</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>默认返回的是false， 如果返回true，就会阻止浏览器上面的报错。</p>\n<p><strong>注意</strong> <code>element.onerror = function(event){}</code></p>\n<p>这里由于某种历史原因，在window 和element 上监听的函数的参数是不一样的。</p>\n<p>同时，这里的错误是不会冒泡到window的错误处理方法上的。</p>\n<ol start=\"3\">\n<li>window.addEventLister(‘error’,function(){}[,Boolean])</li>\n</ol>\n<p>3-1. 事件流</p>\n<blockquote>\n<p>题外话，由于理不清楚，这个事件流到底是怎么个回事，已经转头温习事件流去了。话说，这个error的事件怎么个流动法</p>\n</blockquote>\n<p>好吧，万事都得躬行啊。惭愧，这么久了才把这个搞清楚。</p>\n<p>首先，addEventListener 最后的参数意思为 useCapture ，是否使用捕获模式，默认为false，使用冒泡模式。</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/776370/201608/776370-20160814181725921-250498467.png\" alt=\"捕获冒泡\"></p>\n<p>使用捕获模式就会在捕获阶段触发函数，反之则反。说明一点，目标阶段常被视为冒泡阶段。</p>\n<p>捕获会先比冒泡执行。 事件委托是建立在事件冒泡的基础上的。</p>\n<p>3-2. stopPropagation()  preventDefault()</p>\n<p>上面的两个方法都会讲事件流在使用位置停止。</p>\n<p>3-3 e.target  e.currentTarget</p>\n<p>currentTarget 是事件流到这里(current)触发函数时候的元素， 而 target 才是事件流发出时候真正的元素</p>\n<blockquote>\n<p>回到正题，addEventListener(‘error’,function(){…},…isCapture)</p>\n</blockquote>\n<p>资源加载时候的错误，是不会传到window的 onerror 上面去的。</p>\n<p>复习了事件流之后，这个地方的监听资源的报错，得在 <strong>捕获</strong> 阶段(isCapture 为 true)监听才能监听的到。（不知道为啥）</p>\n<!-- 尝试解释一下为什么只有在捕获的时候才可以捕捉到error：\n\n在错误监听函数中打印错误Error 对象， 可以发现有一个path的对象，值为 `path: (5) [img#ii, body, html, document, Window]`\n\n我的一个猜想，应该是这个错误对象只有 -->\n<blockquote>\n<p>error 产生的流，是个怎么样的流向啊，还没有找到。。</p>\n</blockquote>\n<blockquote>\n<p>而且没哟找到让浏览器不输出这个错误的方法，是不是就没有呢。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'error'</span>, (msg, url, row, col, error) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我知道错误了'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">        msg, url, row, col, error</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 貌似没有啥用</span></span><br><span class=\"line\">&#125;, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>"},{"title":"js函数式编程学习","date":"2019-03-07T07:23:19.000Z","_content":"\n03-08 现在对JS函数式编程最大的印象几个使用的特性,还是高阶函数.闭包,柯里化,组合\n\n什么是高阶函数, 参数或者返回是一个函数的函数就是一个高阶函数. 在JS中,数组中的map,filter...都是高阶函数,在函数式编程中高阶函数的使用是很基本的.\n\n什么是闭包. 似乎在很多面试中看过有人问这个.  我在想,如果是我,我会怎么回答这个问题呢.\n\n闭包就是在函数中暴露出来的时候又引用了这个函数作用域的变量,导致没有被回收,从而导致了闭包.这种思想,似乎在函数话编程,纯函数的情况会经常使用.\n\n柯里化\n\n未完待续~","source":"_posts/js函数式编程学习.md","raw":"---\ntitle: js函数式编程学习\ndate: 2019-03-07 15:23:19\ntags:\n---\n\n03-08 现在对JS函数式编程最大的印象几个使用的特性,还是高阶函数.闭包,柯里化,组合\n\n什么是高阶函数, 参数或者返回是一个函数的函数就是一个高阶函数. 在JS中,数组中的map,filter...都是高阶函数,在函数式编程中高阶函数的使用是很基本的.\n\n什么是闭包. 似乎在很多面试中看过有人问这个.  我在想,如果是我,我会怎么回答这个问题呢.\n\n闭包就是在函数中暴露出来的时候又引用了这个函数作用域的变量,导致没有被回收,从而导致了闭包.这种思想,似乎在函数话编程,纯函数的情况会经常使用.\n\n柯里化\n\n未完待续~","slug":"js函数式编程学习","published":1,"updated":"2019-03-12T14:08:58.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fis000v7dxq2z2tldab","content":"<p>03-08 现在对JS函数式编程最大的印象几个使用的特性,还是高阶函数.闭包,柯里化,组合</p>\n<p>什么是高阶函数, 参数或者返回是一个函数的函数就是一个高阶函数. 在JS中,数组中的map,filter…都是高阶函数,在函数式编程中高阶函数的使用是很基本的.</p>\n<p>什么是闭包. 似乎在很多面试中看过有人问这个.  我在想,如果是我,我会怎么回答这个问题呢.</p>\n<p>闭包就是在函数中暴露出来的时候又引用了这个函数作用域的变量,导致没有被回收,从而导致了闭包.这种思想,似乎在函数话编程,纯函数的情况会经常使用.</p>\n<p>柯里化</p>\n<p>未完待续~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>03-08 现在对JS函数式编程最大的印象几个使用的特性,还是高阶函数.闭包,柯里化,组合</p>\n<p>什么是高阶函数, 参数或者返回是一个函数的函数就是一个高阶函数. 在JS中,数组中的map,filter…都是高阶函数,在函数式编程中高阶函数的使用是很基本的.</p>\n<p>什么是闭包. 似乎在很多面试中看过有人问这个.  我在想,如果是我,我会怎么回答这个问题呢.</p>\n<p>闭包就是在函数中暴露出来的时候又引用了这个函数作用域的变量,导致没有被回收,从而导致了闭包.这种思想,似乎在函数话编程,纯函数的情况会经常使用.</p>\n<p>柯里化</p>\n<p>未完待续~</p>\n"},{"title":"js中的this","date":"2019-03-14T10:19:09.000Z","_content":"### 提纲: \n1. this指向什么? 什么时候 this指向 window? \n2. 箭头函数中的this\n3. bind,apply和 call, 模拟实现一个bind,call,apply\n\n## this指向什么\n\n> 刚开始了解this的时候, 看到过一句话, 谁调用函数, 函数中的this就执行谁.我也把这句话奉为圭臬.\n> 但是,随着深入的了解, 有些时候就更蒙蔽了.到底是谁调用的这个函数呢..\n\n### 直接调用\n\n直接通过函数名调用, 无论在哪个作用域下返回的都是全局对象, 直接声明的函数就是在全局对象上声明的.\nnote: 浏览器下和node下的全局对象是不同的\n\n### 方法中 this 指向全局对象的情况\n\n```js\nvar name = 'Bob'\nvar obj = {\n    name: 'Jack',\n    getName: function () {\n        console.log(this.name)\n    }\n}\nvar getName = obj.getName\ngetName()\n```\n我一开始觉得这个`getName`会输出的是 obj对象里面的 name,因为不是用obj.getName定义的嘛.\n然而, 并不是的, 这都是属于定义的, 这个时候的调用还是window的,所以`log`出来的应该是Bob\n还有一种特殊情况就是数组中的函数在数组中调用的情况,如下题目:\n```js\nvar length = 50\nvar fn = function (){\n    console.log(this.length)\n}\nvar arr = [fn,1,2]\narr[0]()\n```\n一开始以为这块的fn中的this应该会没有特殊指定会指向window,然而并不是的.\n在数组中调用函数的话,this相当于是这个数组,所以返回的length是数组的length,所以返回的是3\n\n### 箭头函数中的this\n\n箭头函数中没有作用域,也就没有this,this使用的是父级的this\n\n## bind,apply和 call, 模拟实现一个bind,call,apply\n\n三者对比:\n> call 接受参数 [thisArg, arg1, arg2, ...]\n> apply 接受参数 [thisArg, [argArr]]\n> bind 接受参数 [thisArg, arg1, arg2, ...]\n> 可以看出前两者的区别在于参数的提供方式 call是一个一个指定, 而apply 是用的数组\n> 最后一个bind 接受的参数于call 相同,但是bind 会返回一个函数, 并不会直接执行函数, 这也是bind 与前两者的区别所在\n\n### call的实现\n\n先看call 到底做了什么.\n```js\nvar a = {name: 'Jack'}\nfunction fn() {console.log(this.name)}\nfn.call(a) // Jack\n```\n那么其实,上面的代码等同于:\n```js\nvar a = {\n    name: 'Jack',\n    fn: fn // 这块的fn的属性名任意都行\n}\na.fn()\n```\n有了这样的思路之后,我们发现实现call,就是将调用的方法增加到参数对象的属性中,然后运行就行了.为了不被污染,执行完成之后,还可以删除该属性\n```js \nFunction.prototype.MyCall = function (thisArg) {\n    thisArg.fn = thisArg\n    thisArg.fn()\n    delete thisArg.fn\n}\n```\n这样的第一版的call就完成了,然后我们再继续优化它\n\n首先,对接受的参数是不是函数要进行判断.\n\n其次,除了接受thisArg参数之外,call 还可以接受函数执行时候的参数,\n\n如果函数有返回值的话,还应该将值返回出去,\n\n还需要保证添加的函数的属性名不会覆盖原有属性\n\n以及, 如果传的 thisArg是 null,应该使用window\n\n```js\n// 考虑到多种环境下的使用\nfunction getWindow () {\n    return this\n}\nfunction generateRandom () {\n    return Date.now()\n}\nFunction.prototype.MyCall = function (thisArg, ...args) {\n    if (typeof this !=== 'function') throw new Error(this+'must be a function')\n    if (thisArg === null) thisArg = getWindow()\n    var random = generateRandom()\n    thisArg[random] = this\n    var result = thisArg[random](...args)\n    delete thisArg[random]\n    return result\n}\n```\n这块使用了...args 来获取传过来的函数的参数,如果不让使用的话,可以使用`eval`来解析参数\n\n### apply的实现\n>实现了call之后 apply就是水到渠成的事情了.\n```js\nFunction.prototype.MyApply = function (thisArg, args) {\n    this.MyCall(thisArg,...args)\n}\n```\n\n### bind的实现\n\nbind的实现需要考虑到一些比较特殊的地方,就是在使用new的时候, 感觉这块的实现有点不懂.等会来补充\n\n待续~\n","source":"_posts/js中的this.md","raw":"---\ntitle: js中的this\ndate: 2019-03-14 18:19:09\ntags: JS\n---\n### 提纲: \n1. this指向什么? 什么时候 this指向 window? \n2. 箭头函数中的this\n3. bind,apply和 call, 模拟实现一个bind,call,apply\n\n## this指向什么\n\n> 刚开始了解this的时候, 看到过一句话, 谁调用函数, 函数中的this就执行谁.我也把这句话奉为圭臬.\n> 但是,随着深入的了解, 有些时候就更蒙蔽了.到底是谁调用的这个函数呢..\n\n### 直接调用\n\n直接通过函数名调用, 无论在哪个作用域下返回的都是全局对象, 直接声明的函数就是在全局对象上声明的.\nnote: 浏览器下和node下的全局对象是不同的\n\n### 方法中 this 指向全局对象的情况\n\n```js\nvar name = 'Bob'\nvar obj = {\n    name: 'Jack',\n    getName: function () {\n        console.log(this.name)\n    }\n}\nvar getName = obj.getName\ngetName()\n```\n我一开始觉得这个`getName`会输出的是 obj对象里面的 name,因为不是用obj.getName定义的嘛.\n然而, 并不是的, 这都是属于定义的, 这个时候的调用还是window的,所以`log`出来的应该是Bob\n还有一种特殊情况就是数组中的函数在数组中调用的情况,如下题目:\n```js\nvar length = 50\nvar fn = function (){\n    console.log(this.length)\n}\nvar arr = [fn,1,2]\narr[0]()\n```\n一开始以为这块的fn中的this应该会没有特殊指定会指向window,然而并不是的.\n在数组中调用函数的话,this相当于是这个数组,所以返回的length是数组的length,所以返回的是3\n\n### 箭头函数中的this\n\n箭头函数中没有作用域,也就没有this,this使用的是父级的this\n\n## bind,apply和 call, 模拟实现一个bind,call,apply\n\n三者对比:\n> call 接受参数 [thisArg, arg1, arg2, ...]\n> apply 接受参数 [thisArg, [argArr]]\n> bind 接受参数 [thisArg, arg1, arg2, ...]\n> 可以看出前两者的区别在于参数的提供方式 call是一个一个指定, 而apply 是用的数组\n> 最后一个bind 接受的参数于call 相同,但是bind 会返回一个函数, 并不会直接执行函数, 这也是bind 与前两者的区别所在\n\n### call的实现\n\n先看call 到底做了什么.\n```js\nvar a = {name: 'Jack'}\nfunction fn() {console.log(this.name)}\nfn.call(a) // Jack\n```\n那么其实,上面的代码等同于:\n```js\nvar a = {\n    name: 'Jack',\n    fn: fn // 这块的fn的属性名任意都行\n}\na.fn()\n```\n有了这样的思路之后,我们发现实现call,就是将调用的方法增加到参数对象的属性中,然后运行就行了.为了不被污染,执行完成之后,还可以删除该属性\n```js \nFunction.prototype.MyCall = function (thisArg) {\n    thisArg.fn = thisArg\n    thisArg.fn()\n    delete thisArg.fn\n}\n```\n这样的第一版的call就完成了,然后我们再继续优化它\n\n首先,对接受的参数是不是函数要进行判断.\n\n其次,除了接受thisArg参数之外,call 还可以接受函数执行时候的参数,\n\n如果函数有返回值的话,还应该将值返回出去,\n\n还需要保证添加的函数的属性名不会覆盖原有属性\n\n以及, 如果传的 thisArg是 null,应该使用window\n\n```js\n// 考虑到多种环境下的使用\nfunction getWindow () {\n    return this\n}\nfunction generateRandom () {\n    return Date.now()\n}\nFunction.prototype.MyCall = function (thisArg, ...args) {\n    if (typeof this !=== 'function') throw new Error(this+'must be a function')\n    if (thisArg === null) thisArg = getWindow()\n    var random = generateRandom()\n    thisArg[random] = this\n    var result = thisArg[random](...args)\n    delete thisArg[random]\n    return result\n}\n```\n这块使用了...args 来获取传过来的函数的参数,如果不让使用的话,可以使用`eval`来解析参数\n\n### apply的实现\n>实现了call之后 apply就是水到渠成的事情了.\n```js\nFunction.prototype.MyApply = function (thisArg, args) {\n    this.MyCall(thisArg,...args)\n}\n```\n\n### bind的实现\n\nbind的实现需要考虑到一些比较特殊的地方,就是在使用new的时候, 感觉这块的实现有点不懂.等会来补充\n\n待续~\n","slug":"js中的this","published":1,"updated":"2019-03-31T02:31:52.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fiu000y7dxq5syzr7ep","content":"<h3 id=\"提纲\"><a href=\"#提纲\" class=\"headerlink\" title=\"提纲:\"></a>提纲:</h3><ol>\n<li>this指向什么? 什么时候 this指向 window? </li>\n<li>箭头函数中的this</li>\n<li>bind,apply和 call, 模拟实现一个bind,call,apply</li>\n</ol>\n<h2 id=\"this指向什么\"><a href=\"#this指向什么\" class=\"headerlink\" title=\"this指向什么\"></a>this指向什么</h2><blockquote>\n<p>刚开始了解this的时候, 看到过一句话, 谁调用函数, 函数中的this就执行谁.我也把这句话奉为圭臬.<br>但是,随着深入的了解, 有些时候就更蒙蔽了.到底是谁调用的这个函数呢..</p>\n</blockquote>\n<h3 id=\"直接调用\"><a href=\"#直接调用\" class=\"headerlink\" title=\"直接调用\"></a>直接调用</h3><p>直接通过函数名调用, 无论在哪个作用域下返回的都是全局对象, 直接声明的函数就是在全局对象上声明的.<br>note: 浏览器下和node下的全局对象是不同的</p>\n<h3 id=\"方法中-this-指向全局对象的情况\"><a href=\"#方法中-this-指向全局对象的情况\" class=\"headerlink\" title=\"方法中 this 指向全局对象的情况\"></a>方法中 this 指向全局对象的情况</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = obj.getName</span><br><span class=\"line\">getName()</span><br></pre></td></tr></table></figure>\n<p>我一开始觉得这个<code>getName</code>会输出的是 obj对象里面的 name,因为不是用obj.getName定义的嘛.<br>然而, 并不是的, 这都是属于定义的, 这个时候的调用还是window的,所以<code>log</code>出来的应该是Bob<br>还有一种特殊情况就是数组中的函数在数组中调用的情况,如下题目:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [fn,<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]()</span><br></pre></td></tr></table></figure></p>\n<p>一开始以为这块的fn中的this应该会没有特殊指定会指向window,然而并不是的.<br>在数组中调用函数的话,this相当于是这个数组,所以返回的length是数组的length,所以返回的是3</p>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>箭头函数中没有作用域,也就没有this,this使用的是父级的this</p>\n<h2 id=\"bind-apply和-call-模拟实现一个bind-call-apply\"><a href=\"#bind-apply和-call-模拟实现一个bind-call-apply\" class=\"headerlink\" title=\"bind,apply和 call, 模拟实现一个bind,call,apply\"></a>bind,apply和 call, 模拟实现一个bind,call,apply</h2><p>三者对比:</p>\n<blockquote>\n<p>call 接受参数 [thisArg, arg1, arg2, …]<br>apply 接受参数 [thisArg, [argArr]]<br>bind 接受参数 [thisArg, arg1, arg2, …]<br>可以看出前两者的区别在于参数的提供方式 call是一个一个指定, 而apply 是用的数组<br>最后一个bind 接受的参数于call 相同,但是bind 会返回一个函数, 并不会直接执行函数, 这也是bind 与前两者的区别所在</p>\n</blockquote>\n<h3 id=\"call的实现\"><a href=\"#call的实现\" class=\"headerlink\" title=\"call的实现\"></a>call的实现</h3><p>先看call 到底做了什么.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Jack'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\">fn.call(a) <span class=\"comment\">// Jack</span></span><br></pre></td></tr></table></figure></p>\n<p>那么其实,上面的代码等同于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    fn: fn <span class=\"comment\">// 这块的fn的属性名任意都行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn()</span><br></pre></td></tr></table></figure></p>\n<p>有了这样的思路之后,我们发现实现call,就是将调用的方法增加到参数对象的属性中,然后运行就行了.为了不被污染,执行完成之后,还可以删除该属性<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg</span>) </span>&#123;</span><br><span class=\"line\">    thisArg.fn = thisArg</span><br><span class=\"line\">    thisArg.fn()</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> thisArg.fn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的第一版的call就完成了,然后我们再继续优化它</p>\n<p>首先,对接受的参数是不是函数要进行判断.</p>\n<p>其次,除了接受thisArg参数之外,call 还可以接受函数执行时候的参数,</p>\n<p>如果函数有返回值的话,还应该将值返回出去,</p>\n<p>还需要保证添加的函数的属性名不会覆盖原有属性</p>\n<p>以及, 如果传的 thisArg是 null,应该使用window</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 考虑到多种环境下的使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getWindow</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateRandom</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !=== <span class=\"string\">'function'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>+<span class=\"string\">'must be a function'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thisArg === <span class=\"literal\">null</span>) thisArg = getWindow()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> random = generateRandom()</span><br><span class=\"line\">    thisArg[random] = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = thisArg[random](...args)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> thisArg[random]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这块使用了…args 来获取传过来的函数的参数,如果不让使用的话,可以使用<code>eval</code>来解析参数</p>\n<h3 id=\"apply的实现\"><a href=\"#apply的实现\" class=\"headerlink\" title=\"apply的实现\"></a>apply的实现</h3><blockquote>\n<p>实现了call之后 apply就是水到渠成的事情了.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyApply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.MyCall(thisArg,...args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"bind的实现\"><a href=\"#bind的实现\" class=\"headerlink\" title=\"bind的实现\"></a>bind的实现</h3><p>bind的实现需要考虑到一些比较特殊的地方,就是在使用new的时候, 感觉这块的实现有点不懂.等会来补充</p>\n<p>待续~</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"提纲\"><a href=\"#提纲\" class=\"headerlink\" title=\"提纲:\"></a>提纲:</h3><ol>\n<li>this指向什么? 什么时候 this指向 window? </li>\n<li>箭头函数中的this</li>\n<li>bind,apply和 call, 模拟实现一个bind,call,apply</li>\n</ol>\n<h2 id=\"this指向什么\"><a href=\"#this指向什么\" class=\"headerlink\" title=\"this指向什么\"></a>this指向什么</h2><blockquote>\n<p>刚开始了解this的时候, 看到过一句话, 谁调用函数, 函数中的this就执行谁.我也把这句话奉为圭臬.<br>但是,随着深入的了解, 有些时候就更蒙蔽了.到底是谁调用的这个函数呢..</p>\n</blockquote>\n<h3 id=\"直接调用\"><a href=\"#直接调用\" class=\"headerlink\" title=\"直接调用\"></a>直接调用</h3><p>直接通过函数名调用, 无论在哪个作用域下返回的都是全局对象, 直接声明的函数就是在全局对象上声明的.<br>note: 浏览器下和node下的全局对象是不同的</p>\n<h3 id=\"方法中-this-指向全局对象的情况\"><a href=\"#方法中-this-指向全局对象的情况\" class=\"headerlink\" title=\"方法中 this 指向全局对象的情况\"></a>方法中 this 指向全局对象的情况</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = obj.getName</span><br><span class=\"line\">getName()</span><br></pre></td></tr></table></figure>\n<p>我一开始觉得这个<code>getName</code>会输出的是 obj对象里面的 name,因为不是用obj.getName定义的嘛.<br>然而, 并不是的, 这都是属于定义的, 这个时候的调用还是window的,所以<code>log</code>出来的应该是Bob<br>还有一种特殊情况就是数组中的函数在数组中调用的情况,如下题目:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [fn,<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]()</span><br></pre></td></tr></table></figure></p>\n<p>一开始以为这块的fn中的this应该会没有特殊指定会指向window,然而并不是的.<br>在数组中调用函数的话,this相当于是这个数组,所以返回的length是数组的length,所以返回的是3</p>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>箭头函数中没有作用域,也就没有this,this使用的是父级的this</p>\n<h2 id=\"bind-apply和-call-模拟实现一个bind-call-apply\"><a href=\"#bind-apply和-call-模拟实现一个bind-call-apply\" class=\"headerlink\" title=\"bind,apply和 call, 模拟实现一个bind,call,apply\"></a>bind,apply和 call, 模拟实现一个bind,call,apply</h2><p>三者对比:</p>\n<blockquote>\n<p>call 接受参数 [thisArg, arg1, arg2, …]<br>apply 接受参数 [thisArg, [argArr]]<br>bind 接受参数 [thisArg, arg1, arg2, …]<br>可以看出前两者的区别在于参数的提供方式 call是一个一个指定, 而apply 是用的数组<br>最后一个bind 接受的参数于call 相同,但是bind 会返回一个函数, 并不会直接执行函数, 这也是bind 与前两者的区别所在</p>\n</blockquote>\n<h3 id=\"call的实现\"><a href=\"#call的实现\" class=\"headerlink\" title=\"call的实现\"></a>call的实现</h3><p>先看call 到底做了什么.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Jack'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)&#125;</span><br><span class=\"line\">fn.call(a) <span class=\"comment\">// Jack</span></span><br></pre></td></tr></table></figure></p>\n<p>那么其实,上面的代码等同于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    fn: fn <span class=\"comment\">// 这块的fn的属性名任意都行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn()</span><br></pre></td></tr></table></figure></p>\n<p>有了这样的思路之后,我们发现实现call,就是将调用的方法增加到参数对象的属性中,然后运行就行了.为了不被污染,执行完成之后,还可以删除该属性<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg</span>) </span>&#123;</span><br><span class=\"line\">    thisArg.fn = thisArg</span><br><span class=\"line\">    thisArg.fn()</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> thisArg.fn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样的第一版的call就完成了,然后我们再继续优化它</p>\n<p>首先,对接受的参数是不是函数要进行判断.</p>\n<p>其次,除了接受thisArg参数之外,call 还可以接受函数执行时候的参数,</p>\n<p>如果函数有返回值的话,还应该将值返回出去,</p>\n<p>还需要保证添加的函数的属性名不会覆盖原有属性</p>\n<p>以及, 如果传的 thisArg是 null,应该使用window</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 考虑到多种环境下的使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getWindow</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateRandom</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyCall = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg, ...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span> !=== <span class=\"string\">'function'</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"keyword\">this</span>+<span class=\"string\">'must be a function'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (thisArg === <span class=\"literal\">null</span>) thisArg = getWindow()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> random = generateRandom()</span><br><span class=\"line\">    thisArg[random] = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = thisArg[random](...args)</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> thisArg[random]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这块使用了…args 来获取传过来的函数的参数,如果不让使用的话,可以使用<code>eval</code>来解析参数</p>\n<h3 id=\"apply的实现\"><a href=\"#apply的实现\" class=\"headerlink\" title=\"apply的实现\"></a>apply的实现</h3><blockquote>\n<p>实现了call之后 apply就是水到渠成的事情了.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.MyApply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">thisArg, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.MyCall(thisArg,...args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"bind的实现\"><a href=\"#bind的实现\" class=\"headerlink\" title=\"bind的实现\"></a>bind的实现</h3><p>bind的实现需要考虑到一些比较特殊的地方,就是在使用new的时候, 感觉这块的实现有点不懂.等会来补充</p>\n<p>待续~</p>\n"},{"title":"TO BE MY HERO","url":"38.html","id":"38","date":"2018-11-20T14:02:16.000Z","_content":"\n愿我可以做我自己的英雄","source":"_posts/to-be-my-hero.md","raw":"---\ntitle: TO BE MY HERO\nurl: 38.html\nid: 38\ncategories:\n  - 杂文\ndate: 2018-11-20 22:02:16\ntags: 杂文\n---\n\n愿我可以做我自己的英雄","slug":"to-be-my-hero","published":1,"updated":"2019-03-31T02:31:52.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fiv00107dxqrt02yj80","content":"<p>愿我可以做我自己的英雄</p>\n","site":{"data":{}},"excerpt":"","more":"<p>愿我可以做我自己的英雄</p>\n"},{"title":"js遗漏知识总结","date":"2019-04-09T06:14:02.000Z","_content":"\n## 不得不加上的分号\n\n现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。\n\n先直接下结论，在使用 `+` `-` `(` `[` `/` 位于行首的时候需要加上分号。\n\n除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。\n\n下列两种情况使用中常出现：\n\n```js\n;[arr[1], arr[2]] = [arr[2], arr[1]]\n```\n```js\n;(function(){\n    // ....\n})()\n```\n这种时候都需要手动加上分号\n\n## defer async 在script 标签中的作用以及差异\n\n首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签\n\n区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，\n\n而async 在脚本下载完成之后就执行，中断文档的渲染\n\n多个defer 会按照顺序加载执行，而 async会依据下载时间\n\n## 解构赋值使用方法总结\n\n解构赋值，让获取变量的值，更加的优雅，代码更加的易读。\n\n> 小提一句原理，是利用的新增的iterator 接口。\n\n### 数据的解构赋值\n\n常规的情况：\n```js\nlet [a,b,c] = [1,2,3]\n```\n如果需要忽略某些值，用,,来忽略\n```js\nlet [a,,,d] = [1,2,3,4] // a=a,d=4\n```\n设定默认值:\n```js\nlet [a=5,b=5] = [2] // a=2,b=5\n```\n剩余参数的赋值；（使用... , 但是注意，... 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）\n```js\nlet [a,b,...rest] = [1,2,3,4,5] // a = 1, b = 2, rest = [3,4,5]\n```\n#### 经常使用的场景\n\n下面记录几种经常在使用中利用的方法：\n\n1. 交换变量\n```js\n[a,b] = [b,a]\n```\n\n2. 正则表达式的exec语句、函数参数argument中某个值的获取\n\nexec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值\n\n### 对象的解构赋值\n\n普通的情况:\n```js\nlet {o, p} = {o:'oVAl',l:'lVAL'} // o = 'oVAl', p = undefined\n```\n使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：\n```js\nlet {o:oo, p} = {o:'oVaL',p:'pVAL'} // oo = 'oVAl', p = 'pVAL'\n```\n注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)\n```js\n;({o, p} = {o:'oVaL',p:'pVAL'});\n```\n...rest 和 默认值的使用方法就和数组的差不多了 \n\n## requestAnimationFrame 理解\n\n这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，**请求动画帧**。\n\n接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。\n\n### 屏幕刷新频率\n\n一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。\n\n### 与setTimeout的对比\n\n在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？\n\n1. 屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。\n\n2. setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。\n\n以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。\n\n同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。\n\n综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout","source":"_posts/js遗漏知识总结.md","raw":"---\ntitle: js遗漏知识总结\ndate: 2019-04-09 14:14:02\ntags:\n---\n\n## 不得不加上的分号\n\n现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。\n\n先直接下结论，在使用 `+` `-` `(` `[` `/` 位于行首的时候需要加上分号。\n\n除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。\n\n下列两种情况使用中常出现：\n\n```js\n;[arr[1], arr[2]] = [arr[2], arr[1]]\n```\n```js\n;(function(){\n    // ....\n})()\n```\n这种时候都需要手动加上分号\n\n## defer async 在script 标签中的作用以及差异\n\n首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签\n\n区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，\n\n而async 在脚本下载完成之后就执行，中断文档的渲染\n\n多个defer 会按照顺序加载执行，而 async会依据下载时间\n\n## 解构赋值使用方法总结\n\n解构赋值，让获取变量的值，更加的优雅，代码更加的易读。\n\n> 小提一句原理，是利用的新增的iterator 接口。\n\n### 数据的解构赋值\n\n常规的情况：\n```js\nlet [a,b,c] = [1,2,3]\n```\n如果需要忽略某些值，用,,来忽略\n```js\nlet [a,,,d] = [1,2,3,4] // a=a,d=4\n```\n设定默认值:\n```js\nlet [a=5,b=5] = [2] // a=2,b=5\n```\n剩余参数的赋值；（使用... , 但是注意，... 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）\n```js\nlet [a,b,...rest] = [1,2,3,4,5] // a = 1, b = 2, rest = [3,4,5]\n```\n#### 经常使用的场景\n\n下面记录几种经常在使用中利用的方法：\n\n1. 交换变量\n```js\n[a,b] = [b,a]\n```\n\n2. 正则表达式的exec语句、函数参数argument中某个值的获取\n\nexec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值\n\n### 对象的解构赋值\n\n普通的情况:\n```js\nlet {o, p} = {o:'oVAl',l:'lVAL'} // o = 'oVAl', p = undefined\n```\n使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：\n```js\nlet {o:oo, p} = {o:'oVaL',p:'pVAL'} // oo = 'oVAl', p = 'pVAL'\n```\n注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)\n```js\n;({o, p} = {o:'oVaL',p:'pVAL'});\n```\n...rest 和 默认值的使用方法就和数组的差不多了 \n\n## requestAnimationFrame 理解\n\n这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，**请求动画帧**。\n\n接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。\n\n### 屏幕刷新频率\n\n一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。\n\n### 与setTimeout的对比\n\n在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？\n\n1. 屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。\n\n2. setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。\n\n以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。\n\n同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。\n\n综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout","slug":"js遗漏知识总结","published":1,"updated":"2019-04-21T02:21:22.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fix00127dxq5jb2137t","content":"<h2 id=\"不得不加上的分号\"><a href=\"#不得不加上的分号\" class=\"headerlink\" title=\"不得不加上的分号\"></a>不得不加上的分号</h2><p>现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。</p>\n<p>先直接下结论，在使用 <code>+</code> <code>-</code> <code>(</code> <code>[</code> <code>/</code> 位于行首的时候需要加上分号。</p>\n<p>除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。</p>\n<p>下列两种情况使用中常出现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[arr[<span class=\"number\">1</span>], arr[<span class=\"number\">2</span>]] = [arr[<span class=\"number\">2</span>], arr[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>这种时候都需要手动加上分号</p>\n<h2 id=\"defer-async-在script-标签中的作用以及差异\"><a href=\"#defer-async-在script-标签中的作用以及差异\" class=\"headerlink\" title=\"defer async 在script 标签中的作用以及差异\"></a>defer async 在script 标签中的作用以及差异</h2><p>首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签</p>\n<p>区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，</p>\n<p>而async 在脚本下载完成之后就执行，中断文档的渲染</p>\n<p>多个defer 会按照顺序加载执行，而 async会依据下载时间</p>\n<h2 id=\"解构赋值使用方法总结\"><a href=\"#解构赋值使用方法总结\" class=\"headerlink\" title=\"解构赋值使用方法总结\"></a>解构赋值使用方法总结</h2><p>解构赋值，让获取变量的值，更加的优雅，代码更加的易读。</p>\n<blockquote>\n<p>小提一句原理，是利用的新增的iterator 接口。</p>\n</blockquote>\n<h3 id=\"数据的解构赋值\"><a href=\"#数据的解构赋值\" class=\"headerlink\" title=\"数据的解构赋值\"></a>数据的解构赋值</h3><p>常规的情况：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,b,c] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure></p>\n<p>如果需要忽略某些值，用,,来忽略<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,,,d] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>] <span class=\"comment\">// a=a,d=4</span></span><br></pre></td></tr></table></figure></p>\n<p>设定默认值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a=<span class=\"number\">5</span>,b=<span class=\"number\">5</span>] = [<span class=\"number\">2</span>] <span class=\"comment\">// a=2,b=5</span></span><br></pre></td></tr></table></figure></p>\n<p>剩余参数的赋值；（使用… , 但是注意，… 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,b,...rest] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>] <span class=\"comment\">// a = 1, b = 2, rest = [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"经常使用的场景\"><a href=\"#经常使用的场景\" class=\"headerlink\" title=\"经常使用的场景\"></a>经常使用的场景</h4><p>下面记录几种经常在使用中利用的方法：</p>\n<ol>\n<li><p>交换变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b] = [b,a]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>正则表达式的exec语句、函数参数argument中某个值的获取</p>\n</li>\n</ol>\n<p>exec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值</p>\n<h3 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h3><p>普通的情况:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;o, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVAl'</span>,<span class=\"attr\">l</span>:<span class=\"string\">'lVAL'</span>&#125; <span class=\"comment\">// o = 'oVAl', p = undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">o</span>:oo, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVaL'</span>,<span class=\"attr\">p</span>:<span class=\"string\">'pVAL'</span>&#125; <span class=\"comment\">// oo = 'oVAl', p = 'pVAL'</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(&#123;o, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVaL'</span>,<span class=\"attr\">p</span>:<span class=\"string\">'pVAL'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>…rest 和 默认值的使用方法就和数组的差不多了 </p>\n<h2 id=\"requestAnimationFrame-理解\"><a href=\"#requestAnimationFrame-理解\" class=\"headerlink\" title=\"requestAnimationFrame 理解\"></a>requestAnimationFrame 理解</h2><p>这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，<strong>请求动画帧</strong>。</p>\n<p>接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。</p>\n<h3 id=\"屏幕刷新频率\"><a href=\"#屏幕刷新频率\" class=\"headerlink\" title=\"屏幕刷新频率\"></a>屏幕刷新频率</h3><p>一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。</p>\n<h3 id=\"与setTimeout的对比\"><a href=\"#与setTimeout的对比\" class=\"headerlink\" title=\"与setTimeout的对比\"></a>与setTimeout的对比</h3><p>在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？</p>\n<ol>\n<li><p>屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。</p>\n</li>\n<li><p>setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。</p>\n</li>\n</ol>\n<p>以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。</p>\n<p>同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。</p>\n<p>综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"不得不加上的分号\"><a href=\"#不得不加上的分号\" class=\"headerlink\" title=\"不得不加上的分号\"></a>不得不加上的分号</h2><p>现在在写js的时候，基本上已经会省略掉分号（;）的使用，但是在有些情况省略掉分号就会导致错误。</p>\n<p>先直接下结论，在使用 <code>+</code> <code>-</code> <code>(</code> <code>[</code> <code>/</code> 位于行首的时候需要加上分号。</p>\n<p>除了这五种情况外，js会在行尾自动加上分号，但是上面五种情况不会，有些时候就会导致错误。</p>\n<p>下列两种情况使用中常出现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[arr[<span class=\"number\">1</span>], arr[<span class=\"number\">2</span>]] = [arr[<span class=\"number\">2</span>], arr[<span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>这种时候都需要手动加上分号</p>\n<h2 id=\"defer-async-在script-标签中的作用以及差异\"><a href=\"#defer-async-在script-标签中的作用以及差异\" class=\"headerlink\" title=\"defer async 在script 标签中的作用以及差异\"></a>defer async 在script 标签中的作用以及差异</h2><p>首先，defer 和 async 都是异步加载脚本文件的语法。都只能作用于有src 属性的script 标签</p>\n<p>区别在于defer 会在文档解析完成之后，也就是DOMContentLoaded 事件前执行，</p>\n<p>而async 在脚本下载完成之后就执行，中断文档的渲染</p>\n<p>多个defer 会按照顺序加载执行，而 async会依据下载时间</p>\n<h2 id=\"解构赋值使用方法总结\"><a href=\"#解构赋值使用方法总结\" class=\"headerlink\" title=\"解构赋值使用方法总结\"></a>解构赋值使用方法总结</h2><p>解构赋值，让获取变量的值，更加的优雅，代码更加的易读。</p>\n<blockquote>\n<p>小提一句原理，是利用的新增的iterator 接口。</p>\n</blockquote>\n<h3 id=\"数据的解构赋值\"><a href=\"#数据的解构赋值\" class=\"headerlink\" title=\"数据的解构赋值\"></a>数据的解构赋值</h3><p>常规的情况：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,b,c] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure></p>\n<p>如果需要忽略某些值，用,,来忽略<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,,,d] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>] <span class=\"comment\">// a=a,d=4</span></span><br></pre></td></tr></table></figure></p>\n<p>设定默认值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a=<span class=\"number\">5</span>,b=<span class=\"number\">5</span>] = [<span class=\"number\">2</span>] <span class=\"comment\">// a=2,b=5</span></span><br></pre></td></tr></table></figure></p>\n<p>剩余参数的赋值；（使用… , 但是注意，… 一定得是最后一个参数; 如果后面还有参数，请使用,,, 的方法）<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a,b,...rest] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>] <span class=\"comment\">// a = 1, b = 2, rest = [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"经常使用的场景\"><a href=\"#经常使用的场景\" class=\"headerlink\" title=\"经常使用的场景\"></a>经常使用的场景</h4><p>下面记录几种经常在使用中利用的方法：</p>\n<ol>\n<li><p>交换变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b] = [b,a]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>正则表达式的exec语句、函数参数argument中某个值的获取</p>\n</li>\n</ol>\n<p>exec会返回一个带有很多值的数组，数组中有些的值，是我们不需要的。就可以直接使用解构获取想要的值</p>\n<h3 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h3><p>普通的情况:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;o, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVAl'</span>,<span class=\"attr\">l</span>:<span class=\"string\">'lVAL'</span>&#125; <span class=\"comment\">// o = 'oVAl', p = undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>使用对象的解构赋值，左边的值必须是对象中的属性名,如果不是将获取不到值(undefined)。如果需要重命名得使用下面的方法：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">o</span>:oo, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVaL'</span>,<span class=\"attr\">p</span>:<span class=\"string\">'pVAL'</span>&#125; <span class=\"comment\">// oo = 'oVAl', p = 'pVAL'</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，如果是没有声明的赋值，需要用()包起来，并且注意使用;(原因上面有讲)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(&#123;o, p&#125; = &#123;<span class=\"attr\">o</span>:<span class=\"string\">'oVaL'</span>,<span class=\"attr\">p</span>:<span class=\"string\">'pVAL'</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>…rest 和 默认值的使用方法就和数组的差不多了 </p>\n<h2 id=\"requestAnimationFrame-理解\"><a href=\"#requestAnimationFrame-理解\" class=\"headerlink\" title=\"requestAnimationFrame 理解\"></a>requestAnimationFrame 理解</h2><p>这是web中专门对优化动画，增加的函数。按照翻译，API的名字应该叫做，<strong>请求动画帧</strong>。</p>\n<p>接受一个callback 回调，在屏幕刷新时调用。一般在callback 中还会继续调用requestAnimationFrame, 直到约定的条件达成后，实现动画的效果。</p>\n<h3 id=\"屏幕刷新频率\"><a href=\"#屏幕刷新频率\" class=\"headerlink\" title=\"屏幕刷新频率\"></a>屏幕刷新频率</h3><p>一般的显示器设置的是60HZ，就是一秒钟刷新60次，16.67ms刷新一次。</p>\n<h3 id=\"与setTimeout的对比\"><a href=\"#与setTimeout的对比\" class=\"headerlink\" title=\"与setTimeout的对比\"></a>与setTimeout的对比</h3><p>在没有requestAnimationFrame之前，我们都是使用setTimeout来实现动画的。那为什么使用setTimeout不好呢？</p>\n<ol>\n<li><p>屏幕刷新的频率只是一般来说是60HZ，但是不是绝对的。这个间隔人为设定，会有误差。</p>\n</li>\n<li><p>setTimeout 是在异步队列中执行的，在主线程任务执行完成之后才回去执行。</p>\n</li>\n</ol>\n<p>以上两点，会导致setTimeout的执行步调和屏幕刷新不一致，会导致动画的丢帧。</p>\n<p>同时requestAnimationFrame对性能也更加的友好，页面处于未激活状态下，requestAnimationFrame 不会调用，不同于setTimeout。</p>\n<p>综上，如果有使用动画的地方，使用requestAnimationFrame 而不是setTImeout</p>\n"},{"title":"What am I thinking?","url":"103.html","id":"103","date":"2019-01-08T02:43:43.000Z","_content":"\n> > 哦? 我在想啥","source":"_posts/what-am-i-thinking.md","raw":"---\ntitle: What am I thinking?\nurl: 103.html\nid: 103\ncategories:\n  - 未分类\ndate: 2019-01-08 10:43:43\ntags:\n---\n\n> > 哦? 我在想啥","slug":"what-am-i-thinking","published":1,"updated":"2019-03-07T11:39:38.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fiy00157dxq6h3evri0","content":"<blockquote>\n<blockquote>\n<p>哦? 我在想啥</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<blockquote>\n<p>哦? 我在想啥</p>\n</blockquote>\n</blockquote>\n"},{"title":"关于跨域","date":"2019-03-19T03:22:47.000Z","_content":"> 记得在18年年中天天临时抱佛脚,在看过很多关于跨域的问题,但是都是在浅尝辄止之后就完事了\n对于现阶段的学习,我不应该是不求甚解啊,对于技术的学习应该得越深入越好啊\n\n### 什么是跨域\n在早期为了防止跨域请求伪造,浏览器引入了同源策略来提高安全.\n首先同源政策是浏览器引入的,再者什么是同域名呢,同域名,同端口,同协议的才算是同源\n#### 同源策略的影响\n不同的域名下,跨域获取另一个域名的脚本,css,图片等资源,但是不可以发起请求,也不可以操作cookie/localStorage\n\n### js解决跨域的方法\n\n#### JSONP\n\njsonp的意思就是JSON + callback,利用script请求资源不受同源策略影响的hack.\n来,手写一个\n```js\nfunction addScript (src) {\n    var script = document.createElement('script')\n    script.src = src\n    document.appendChild(script)\n}\nwindow.onload = function () {\n  addScriptTag('http://example.com/ip?callback=foo');\n}\nfunction foo (fata) {\n    console.log(data)\n}v\n```\n\njsonP的关键就在于两点\n- 动态添加script发起请求\n- 请求的回调callback一定是一个函数\n\n#### document.domain\n\n>这个方法只使用于共享cookie, LocalStorage 和 IndexDB 无法通过这种方法,而且只适用于一级域名/二级域名相同的情况下(因为document.domain的限制)\ndocument.domain只能设置成为当前domain的suffix(后缀)\n\neg:\nA网页是`https://www.zhihu.com`\nB网页是`https://zhihu.com`\n\n在B中设置了cookie, `document.cookie = 'name = tony'`\n只需要在A中设置`document.domain = 'zhihu.com'`\n然后就可以获取B中的cookie\n\n除了这种方法还可以通过服务端设置cookie的时候指定\n`Set-Cookie: key=value; domain=.example.com; path=/`\n\n> 除此之外还有很多关于iframe的解决的办法,我觉得这个ifame实在没有在怎么使用了就不做记录了\n\n### 服务器跨域\n\n#### 跨域资源共享 CORS\n\n跨域资源共享允许浏览器向跨域服务器发出请求,从而克服了AJAX只能同源使用的限制\n\n> 以下信息来自我自己对[阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html)的博客和[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)理解\n\ncors需要服务器和浏览器同时支持,整个CORS通信的过程都是浏览器自动完成的.开发者不需要做什么其他的操作.\n所以关键在于服务器\n\n##### 两种请求\n\n浏览器会将请求分为两种: 简单请求 和 非简单请求\n\n###### 简单请求\n\n满足的条件:\n\n>请求是以下三个之一:\n1. GET\n2. POST\n3. HEAD\n>http的头部信息也不超过以下几种字段:\n- Accept\n- Accept-Language\n- Content-Language\n- Last-Event-ID\n- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n如果是简单请求,浏览器会在头部加上一个`Origin`字段用于说明,本次请求来自哪个源.\n服务器就可以根据这个值,判断是否同意这次请求.\n如果服务器不同意这次请求,在返回头里面就没有`Access-Control-Allow-Origin`,浏览器就会知道请求出错了.\n如果返回头中有`Access-Control-Allow-Origin`,就说明此次请求的源在服务器的origin中.\n返回信息会加上\n1. Access-Control-Allow-Origin\n\n   `Access-Control-Allow-Origin: <origin> | *` \n   origin会指定允许访问的url,还可以设置`*`为通配符\n\n2. Access-Control-Allow-Credentials\n\n    该字段表明是否允许浏览器读取response中的内容.\n    > 这句话实在是看不懂啥意思.有啥内容要去读啊.\n\n    阮一峰的说法: 就是cookie是否可以包含在请求中.\n    默认情况下的cors是不包含cookies的,设置为true的情况才会发送出去\n\n    [stackoverflow](https://stackoverflow.com/questions/24687313/what-exactly-does-the-access-control-allow-credentials-header-do)上也有一篇文章解释的很清楚\n\n    要想在cors中使用cookie同时还需要客户端设置 `withCredentials` 为 `true`\n3. Access-Control-Expose-Headers\n\n    在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\n\n    如果想要获取其他的响应头,就需要这个属性中说明\n4. Content-Type\n\n    说明资源的类型 \n    > Content-Type标头告诉客户端实际返回的内容的内容类型\n\n###### 非简单请求\n\n> 只要不是简单请求那就是非简单请求\n\n在非简单请求的时候,浏览器会先发送一个预探请求, 该请求的method是`OPTIONS`\n关键参数是origin, 说明了请求的源\n其次还会带上两个参数:`Access-Control-Request-Method` 和 `Access-Control-Request-Headers`\n第一个参数用于指明请求的方式,\n第二个参数,`Access-Control-Request-Headers`,首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。\n","source":"_posts/关于跨域.md","raw":"---\ntitle: 关于跨域\ndate: 2019-03-19 11:22:47\ntags:\n---\n> 记得在18年年中天天临时抱佛脚,在看过很多关于跨域的问题,但是都是在浅尝辄止之后就完事了\n对于现阶段的学习,我不应该是不求甚解啊,对于技术的学习应该得越深入越好啊\n\n### 什么是跨域\n在早期为了防止跨域请求伪造,浏览器引入了同源策略来提高安全.\n首先同源政策是浏览器引入的,再者什么是同域名呢,同域名,同端口,同协议的才算是同源\n#### 同源策略的影响\n不同的域名下,跨域获取另一个域名的脚本,css,图片等资源,但是不可以发起请求,也不可以操作cookie/localStorage\n\n### js解决跨域的方法\n\n#### JSONP\n\njsonp的意思就是JSON + callback,利用script请求资源不受同源策略影响的hack.\n来,手写一个\n```js\nfunction addScript (src) {\n    var script = document.createElement('script')\n    script.src = src\n    document.appendChild(script)\n}\nwindow.onload = function () {\n  addScriptTag('http://example.com/ip?callback=foo');\n}\nfunction foo (fata) {\n    console.log(data)\n}v\n```\n\njsonP的关键就在于两点\n- 动态添加script发起请求\n- 请求的回调callback一定是一个函数\n\n#### document.domain\n\n>这个方法只使用于共享cookie, LocalStorage 和 IndexDB 无法通过这种方法,而且只适用于一级域名/二级域名相同的情况下(因为document.domain的限制)\ndocument.domain只能设置成为当前domain的suffix(后缀)\n\neg:\nA网页是`https://www.zhihu.com`\nB网页是`https://zhihu.com`\n\n在B中设置了cookie, `document.cookie = 'name = tony'`\n只需要在A中设置`document.domain = 'zhihu.com'`\n然后就可以获取B中的cookie\n\n除了这种方法还可以通过服务端设置cookie的时候指定\n`Set-Cookie: key=value; domain=.example.com; path=/`\n\n> 除此之外还有很多关于iframe的解决的办法,我觉得这个ifame实在没有在怎么使用了就不做记录了\n\n### 服务器跨域\n\n#### 跨域资源共享 CORS\n\n跨域资源共享允许浏览器向跨域服务器发出请求,从而克服了AJAX只能同源使用的限制\n\n> 以下信息来自我自己对[阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html)的博客和[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)理解\n\ncors需要服务器和浏览器同时支持,整个CORS通信的过程都是浏览器自动完成的.开发者不需要做什么其他的操作.\n所以关键在于服务器\n\n##### 两种请求\n\n浏览器会将请求分为两种: 简单请求 和 非简单请求\n\n###### 简单请求\n\n满足的条件:\n\n>请求是以下三个之一:\n1. GET\n2. POST\n3. HEAD\n>http的头部信息也不超过以下几种字段:\n- Accept\n- Accept-Language\n- Content-Language\n- Last-Event-ID\n- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n如果是简单请求,浏览器会在头部加上一个`Origin`字段用于说明,本次请求来自哪个源.\n服务器就可以根据这个值,判断是否同意这次请求.\n如果服务器不同意这次请求,在返回头里面就没有`Access-Control-Allow-Origin`,浏览器就会知道请求出错了.\n如果返回头中有`Access-Control-Allow-Origin`,就说明此次请求的源在服务器的origin中.\n返回信息会加上\n1. Access-Control-Allow-Origin\n\n   `Access-Control-Allow-Origin: <origin> | *` \n   origin会指定允许访问的url,还可以设置`*`为通配符\n\n2. Access-Control-Allow-Credentials\n\n    该字段表明是否允许浏览器读取response中的内容.\n    > 这句话实在是看不懂啥意思.有啥内容要去读啊.\n\n    阮一峰的说法: 就是cookie是否可以包含在请求中.\n    默认情况下的cors是不包含cookies的,设置为true的情况才会发送出去\n\n    [stackoverflow](https://stackoverflow.com/questions/24687313/what-exactly-does-the-access-control-allow-credentials-header-do)上也有一篇文章解释的很清楚\n\n    要想在cors中使用cookie同时还需要客户端设置 `withCredentials` 为 `true`\n3. Access-Control-Expose-Headers\n\n    在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。\n\n    如果想要获取其他的响应头,就需要这个属性中说明\n4. Content-Type\n\n    说明资源的类型 \n    > Content-Type标头告诉客户端实际返回的内容的内容类型\n\n###### 非简单请求\n\n> 只要不是简单请求那就是非简单请求\n\n在非简单请求的时候,浏览器会先发送一个预探请求, 该请求的method是`OPTIONS`\n关键参数是origin, 说明了请求的源\n其次还会带上两个参数:`Access-Control-Request-Method` 和 `Access-Control-Request-Headers`\n第一个参数用于指明请求的方式,\n第二个参数,`Access-Control-Request-Headers`,首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。\n","slug":"关于跨域","published":1,"updated":"2019-04-05T02:41:52.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fj000177dxqfwlreuma","content":"<blockquote>\n<p>记得在18年年中天天临时抱佛脚,在看过很多关于跨域的问题,但是都是在浅尝辄止之后就完事了<br>对于现阶段的学习,我不应该是不求甚解啊,对于技术的学习应该得越深入越好啊</p>\n</blockquote>\n<h3 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h3><p>在早期为了防止跨域请求伪造,浏览器引入了同源策略来提高安全.<br>首先同源政策是浏览器引入的,再者什么是同域名呢,同域名,同端口,同协议的才算是同源</p>\n<h4 id=\"同源策略的影响\"><a href=\"#同源策略的影响\" class=\"headerlink\" title=\"同源策略的影响\"></a>同源策略的影响</h4><p>不同的域名下,跨域获取另一个域名的脚本,css,图片等资源,但是不可以发起请求,也不可以操作cookie/localStorage</p>\n<h3 id=\"js解决跨域的方法\"><a href=\"#js解决跨域的方法\" class=\"headerlink\" title=\"js解决跨域的方法\"></a>js解决跨域的方法</h3><h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h4><p>jsonp的意思就是JSON + callback,利用script请求资源不受同源策略影响的hack.<br>来,手写一个<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addScript</span> (<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">    script.src = src</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.appendChild(script)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addScriptTag(<span class=\"string\">'http://example.com/ip?callback=foo'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\">fata</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;v</span><br></pre></td></tr></table></figure></p>\n<p>jsonP的关键就在于两点</p>\n<ul>\n<li>动态添加script发起请求</li>\n<li>请求的回调callback一定是一个函数</li>\n</ul>\n<h4 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h4><blockquote>\n<p>这个方法只使用于共享cookie, LocalStorage 和 IndexDB 无法通过这种方法,而且只适用于一级域名/二级域名相同的情况下(因为document.domain的限制)<br>document.domain只能设置成为当前domain的suffix(后缀)</p>\n</blockquote>\n<p>eg:<br>A网页是<code>https://www.zhihu.com</code><br>B网页是<code>https://zhihu.com</code></p>\n<p>在B中设置了cookie, <code>document.cookie = &#39;name = tony&#39;</code><br>只需要在A中设置<code>document.domain = &#39;zhihu.com&#39;</code><br>然后就可以获取B中的cookie</p>\n<p>除了这种方法还可以通过服务端设置cookie的时候指定<br><code>Set-Cookie: key=value; domain=.example.com; path=/</code></p>\n<blockquote>\n<p>除此之外还有很多关于iframe的解决的办法,我觉得这个ifame实在没有在怎么使用了就不做记录了</p>\n</blockquote>\n<h3 id=\"服务器跨域\"><a href=\"#服务器跨域\" class=\"headerlink\" title=\"服务器跨域\"></a>服务器跨域</h3><h4 id=\"跨域资源共享-CORS\"><a href=\"#跨域资源共享-CORS\" class=\"headerlink\" title=\"跨域资源共享 CORS\"></a>跨域资源共享 CORS</h4><p>跨域资源共享允许浏览器向跨域服务器发出请求,从而克服了AJAX只能同源使用的限制</p>\n<blockquote>\n<p>以下信息来自我自己对<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a>的博客和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"noopener\">MDN</a>理解</p>\n</blockquote>\n<p>cors需要服务器和浏览器同时支持,整个CORS通信的过程都是浏览器自动完成的.开发者不需要做什么其他的操作.<br>所以关键在于服务器</p>\n<h5 id=\"两种请求\"><a href=\"#两种请求\" class=\"headerlink\" title=\"两种请求\"></a>两种请求</h5><p>浏览器会将请求分为两种: 简单请求 和 非简单请求</p>\n<h6 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h6><p>满足的条件:</p>\n<blockquote>\n<p>请求是以下三个之一:</p>\n<ol>\n<li>GET</li>\n<li>POST</li>\n<li>HEAD<br>http的头部信息也不超过以下几种字段:</li>\n</ol>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n</ul>\n</blockquote>\n<p>如果是简单请求,浏览器会在头部加上一个<code>Origin</code>字段用于说明,本次请求来自哪个源.<br>服务器就可以根据这个值,判断是否同意这次请求.<br>如果服务器不同意这次请求,在返回头里面就没有<code>Access-Control-Allow-Origin</code>,浏览器就会知道请求出错了.<br>如果返回头中有<code>Access-Control-Allow-Origin</code>,就说明此次请求的源在服务器的origin中.<br>返回信息会加上</p>\n<ol>\n<li><p>Access-Control-Allow-Origin</p>\n<p><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code><br>origin会指定允许访问的url,还可以设置<code>*</code>为通配符</p>\n</li>\n<li><p>Access-Control-Allow-Credentials</p>\n<p> 该字段表明是否允许浏览器读取response中的内容.</p>\n<blockquote>\n<p>这句话实在是看不懂啥意思.有啥内容要去读啊.</p>\n</blockquote>\n<p> 阮一峰的说法: 就是cookie是否可以包含在请求中.<br> 默认情况下的cors是不包含cookies的,设置为true的情况才会发送出去</p>\n<p> <a href=\"https://stackoverflow.com/questions/24687313/what-exactly-does-the-access-control-allow-credentials-header-do\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>上也有一篇文章解释的很清楚</p>\n<p> 要想在cors中使用cookie同时还需要客户端设置 <code>withCredentials</code> 为 <code>true</code></p>\n</li>\n<li><p>Access-Control-Expose-Headers</p>\n<p> 在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p>\n<p> 如果想要获取其他的响应头,就需要这个属性中说明</p>\n</li>\n<li><p>Content-Type</p>\n<p> 说明资源的类型 </p>\n<blockquote>\n<p>Content-Type标头告诉客户端实际返回的内容的内容类型</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h6><blockquote>\n<p>只要不是简单请求那就是非简单请求</p>\n</blockquote>\n<p>在非简单请求的时候,浏览器会先发送一个预探请求, 该请求的method是<code>OPTIONS</code><br>关键参数是origin, 说明了请求的源<br>其次还会带上两个参数:<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code><br>第一个参数用于指明请求的方式,<br>第二个参数,<code>Access-Control-Request-Headers</code>,首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记得在18年年中天天临时抱佛脚,在看过很多关于跨域的问题,但是都是在浅尝辄止之后就完事了<br>对于现阶段的学习,我不应该是不求甚解啊,对于技术的学习应该得越深入越好啊</p>\n</blockquote>\n<h3 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h3><p>在早期为了防止跨域请求伪造,浏览器引入了同源策略来提高安全.<br>首先同源政策是浏览器引入的,再者什么是同域名呢,同域名,同端口,同协议的才算是同源</p>\n<h4 id=\"同源策略的影响\"><a href=\"#同源策略的影响\" class=\"headerlink\" title=\"同源策略的影响\"></a>同源策略的影响</h4><p>不同的域名下,跨域获取另一个域名的脚本,css,图片等资源,但是不可以发起请求,也不可以操作cookie/localStorage</p>\n<h3 id=\"js解决跨域的方法\"><a href=\"#js解决跨域的方法\" class=\"headerlink\" title=\"js解决跨域的方法\"></a>js解决跨域的方法</h3><h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h4><p>jsonp的意思就是JSON + callback,利用script请求资源不受同源策略影响的hack.<br>来,手写一个<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addScript</span> (<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">    script.src = src</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.appendChild(script)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  addScriptTag(<span class=\"string\">'http://example.com/ip?callback=foo'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\">fata</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;v</span><br></pre></td></tr></table></figure></p>\n<p>jsonP的关键就在于两点</p>\n<ul>\n<li>动态添加script发起请求</li>\n<li>请求的回调callback一定是一个函数</li>\n</ul>\n<h4 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h4><blockquote>\n<p>这个方法只使用于共享cookie, LocalStorage 和 IndexDB 无法通过这种方法,而且只适用于一级域名/二级域名相同的情况下(因为document.domain的限制)<br>document.domain只能设置成为当前domain的suffix(后缀)</p>\n</blockquote>\n<p>eg:<br>A网页是<code>https://www.zhihu.com</code><br>B网页是<code>https://zhihu.com</code></p>\n<p>在B中设置了cookie, <code>document.cookie = &#39;name = tony&#39;</code><br>只需要在A中设置<code>document.domain = &#39;zhihu.com&#39;</code><br>然后就可以获取B中的cookie</p>\n<p>除了这种方法还可以通过服务端设置cookie的时候指定<br><code>Set-Cookie: key=value; domain=.example.com; path=/</code></p>\n<blockquote>\n<p>除此之外还有很多关于iframe的解决的办法,我觉得这个ifame实在没有在怎么使用了就不做记录了</p>\n</blockquote>\n<h3 id=\"服务器跨域\"><a href=\"#服务器跨域\" class=\"headerlink\" title=\"服务器跨域\"></a>服务器跨域</h3><h4 id=\"跨域资源共享-CORS\"><a href=\"#跨域资源共享-CORS\" class=\"headerlink\" title=\"跨域资源共享 CORS\"></a>跨域资源共享 CORS</h4><p>跨域资源共享允许浏览器向跨域服务器发出请求,从而克服了AJAX只能同源使用的限制</p>\n<blockquote>\n<p>以下信息来自我自己对<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">阮一峰</a>的博客和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"noopener\">MDN</a>理解</p>\n</blockquote>\n<p>cors需要服务器和浏览器同时支持,整个CORS通信的过程都是浏览器自动完成的.开发者不需要做什么其他的操作.<br>所以关键在于服务器</p>\n<h5 id=\"两种请求\"><a href=\"#两种请求\" class=\"headerlink\" title=\"两种请求\"></a>两种请求</h5><p>浏览器会将请求分为两种: 简单请求 和 非简单请求</p>\n<h6 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h6><p>满足的条件:</p>\n<blockquote>\n<p>请求是以下三个之一:</p>\n<ol>\n<li>GET</li>\n<li>POST</li>\n<li>HEAD<br>http的头部信息也不超过以下几种字段:</li>\n</ol>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n</ul>\n</blockquote>\n<p>如果是简单请求,浏览器会在头部加上一个<code>Origin</code>字段用于说明,本次请求来自哪个源.<br>服务器就可以根据这个值,判断是否同意这次请求.<br>如果服务器不同意这次请求,在返回头里面就没有<code>Access-Control-Allow-Origin</code>,浏览器就会知道请求出错了.<br>如果返回头中有<code>Access-Control-Allow-Origin</code>,就说明此次请求的源在服务器的origin中.<br>返回信息会加上</p>\n<ol>\n<li><p>Access-Control-Allow-Origin</p>\n<p><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code><br>origin会指定允许访问的url,还可以设置<code>*</code>为通配符</p>\n</li>\n<li><p>Access-Control-Allow-Credentials</p>\n<p> 该字段表明是否允许浏览器读取response中的内容.</p>\n<blockquote>\n<p>这句话实在是看不懂啥意思.有啥内容要去读啊.</p>\n</blockquote>\n<p> 阮一峰的说法: 就是cookie是否可以包含在请求中.<br> 默认情况下的cors是不包含cookies的,设置为true的情况才会发送出去</p>\n<p> <a href=\"https://stackoverflow.com/questions/24687313/what-exactly-does-the-access-control-allow-credentials-header-do\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>上也有一篇文章解释的很清楚</p>\n<p> 要想在cors中使用cookie同时还需要客户端设置 <code>withCredentials</code> 为 <code>true</code></p>\n</li>\n<li><p>Access-Control-Expose-Headers</p>\n<p> 在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p>\n<p> 如果想要获取其他的响应头,就需要这个属性中说明</p>\n</li>\n<li><p>Content-Type</p>\n<p> 说明资源的类型 </p>\n<blockquote>\n<p>Content-Type标头告诉客户端实际返回的内容的内容类型</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h6><blockquote>\n<p>只要不是简单请求那就是非简单请求</p>\n</blockquote>\n<p>在非简单请求的时候,浏览器会先发送一个预探请求, 该请求的method是<code>OPTIONS</code><br>关键参数是origin, 说明了请求的源<br>其次还会带上两个参数:<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code><br>第一个参数用于指明请求的方式,<br>第二个参数,<code>Access-Control-Request-Headers</code>,首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p>\n"},{"title":"几道面试题的知识总结","date":"2019-03-06T02:03:58.000Z","_content":"> 突然看到几道面试题,之前都有看到但是就是感觉似曾相识但是却有点恍惚.决定还是记录一遍加深印象\n\n### 逻辑运算 && || 的作用以及返回值\n\n\n> 目前我存在的一个疑问,js中的| 和 || 的差异在哪里, 或者就是同一个东西.困扰中...\n一个是逻辑运算,一个是位操作..\n\n#### 逻辑运算的特性\n\n短路运算 \n\n在&&中,如果运算符前面的是 false 的值,那么后面的语句就会被忽略掉.\n同理,在|| 中, 如果运算符前面是 true 的值,那么后面的语句也不会去运行的\n\n多个的情况,从左到右计算就好了\n\n运算的逻辑 \n\n逻辑运算的时候,比较的的确是布尔值, 但是返回却不都是布尔值的.下面就是非布尔值进行逻辑运算的几种情况\n例如:\n'dog' || anything = 'dog'\n'dog' && anything = anything\n\n也就是说虽然是用的布尔值在进行的判断,但是最后的返回的时候,是返回的本身的值而不一定是布尔值\n\n同时,被认定为false的情况只有: undefined,'',null,NaN,0\n**注意**  []空数组不会被认为是false\n\n同时上面的 | & 是位运算,根本就不是逻辑运算,别搞混了.\n13 | 5 返回的是13而不是true之类的布尔值,同时13 & 5返回的是5\n\n### 数组的拍平\n[1,2,[3,4,[5]]] -> [1,2,3,4,5]\n一直看到过这个题,看了蛮多的方法.在这里记录一下\n\n#### 方法一:递归\n```js\nfunction flatten (arr){\n    return arr.reduce((all, cur) =>{\n        return all.concat(Array.isArray(cur) ? flatten(cur) : cur)\n    },[])\n}\n```\n\n#### 方法二: 利用toString()}\n```js \nfunction flatten (arr) {\n    return arr.toString().split(',')\n}\n// 存在一个小小的问题,所有的 number 类型都会被转成string类型\n    return arr.toString().split(',').map(Number)\n// 然后再去个重,排个序\n    return Array.from(new Set(arr.toString().split(',').map(Number).sort((a,b) => a-b)))\n```\n> 当时看到这个toString()方法的时候,只觉得自己对JS的了解太不够了,得继续学习啊.这里我就总结一下toString()的各种用法\n\n原型链的最底层toString()是定义在Object上面的.看下在 Object 情况下的值\n\n\n```js\n    var toString = Object.prototype.toString;\n    toString.call(new Date); // [object Date]\n    toString.call(new String); // [object String]\n    toString.call(Math); // [object Math]\n    toString.call(undefined); // [object Undefined]\n    toString.call(null); // [object Null]\n```\n这是用的 Object 上面的toString方法, 同时在其他类型还直接重写toString方法\n有: Boolean, Array, Function, RegExp, Number, String, Date\n\nBoolean中,直接使用重写的toString 方法, 会直接转化成 'true','false' 的字符串类型\n\nfunction中,也直接会把整个函数体转化成 String, 注意一点如果是匿名函数, 转化的函数体的名称会是 anonymous \n```js\nvar sum = new Function('a', 'b', 'return a + b');\nvar c =function () {console.log('a')}\nc.toString() \n// \"function () {console.log('a')}\"\nsum.toString()\n// \"function anonymous(a,b\n// ) {\n// return a + b\n}\"\n```\n\nArray中,也就是直接转成string,同时里面如果还有数组的话, 也会递归的转化成 string,就完成了数组的拍平\n\nRegExp 正则对象的使用方法和function 看起来其实是一个意思,会返回一个标准的 // 的string\n而 date 对象会返回一个标准的一个美式英语日期格式的字符串在当地时区的string\n\n### 学习BFC\n\n> 什么是BFC,全称 Block Formatting Context,中文就是块级格式化上下文.\n\n#### 产生BFC的条件\n\n1. 根元素或者包含它的子元素\n2. 浮动 (元素的 float 不为 none 的情况)\n3. 绝对定位元素 ( position为 fixed 或者 absolute )\n4. 行内快 ( display 为 inline-block )\n5. 表格单元格 ( display 为 table-cell )\n6. overflow 不为 visible 的元素\n7. 弹性盒 flex 布局\n\n#### BFC特性\n\nBFC中会形成一个隔离空间,其中会有一个常规流\n计算BFC的高度的时候,考虑包含BFC的所有元素,浮动元素也计算其中\n但是,浮动盒区域不会叠加到BFC上面\n> \n    内部的Box会在垂直方向，从顶部开始一个接一个地放置。\n    Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加\n    每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    BFC的区域不会与float box叠加。\n    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n    计算BFC的高度时，浮动元素也参与计算。\n\n\n利用这些特性可以解决的问题:\n\nmargin 合并的问题  -  特性: BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n\n使用浮动元素之后,高度塌陷 - 特性: 就是BFC不会与浮动盒子叠加, 就不会产生任何的塌陷了\n\n清除浮动, 这个与上面的问题相似, 是让浮动元素也参与高度计算的方法 - 特性: 计算BFC的高度时，浮动元素也参与计算。\n\n\n### 异步知识补充\n\n其实关于JS的事件循环的宏任务,微任务基本上了解的差不多. (仅仅是了解,实现了解的还不够深入)\n但是关于async 和 await 的知识却忽略了.\n补充知识:(console.log()的执行顺序)\n```js\n    async function async1() {\n        console.log('async1 start');\n        await async2();\n        console.log('async1 end');\n    }\n    async function async2() {\n        console.log('async2');\n    }\n\n    console.log('script start');\n\n    setTimeout(function() {\n        console.log('setTimeout');\n    }, 0)\n\n    async1();\n\n    new Promise(function(resolve) {\n        console.log('promise1');\n        resolve();\n    }).then(function() {\n        console.log('promise2');\n    });\n    console.log('script end');\n````\n看上面的await async2();console.log('async1 end')\n其实await 只是 promise的语法糖而已,\n\n等同于:\nPromise.resolve(async2().then( () =>{\n    console.log(async1 end)\n}))","source":"_posts/几道面试题的知识总结.md","raw":"---\ntitle: 几道面试题的知识总结\ndate: 2019-03-06 10:03:58\ntags: \n  - 总结\n---\n> 突然看到几道面试题,之前都有看到但是就是感觉似曾相识但是却有点恍惚.决定还是记录一遍加深印象\n\n### 逻辑运算 && || 的作用以及返回值\n\n\n> 目前我存在的一个疑问,js中的| 和 || 的差异在哪里, 或者就是同一个东西.困扰中...\n一个是逻辑运算,一个是位操作..\n\n#### 逻辑运算的特性\n\n短路运算 \n\n在&&中,如果运算符前面的是 false 的值,那么后面的语句就会被忽略掉.\n同理,在|| 中, 如果运算符前面是 true 的值,那么后面的语句也不会去运行的\n\n多个的情况,从左到右计算就好了\n\n运算的逻辑 \n\n逻辑运算的时候,比较的的确是布尔值, 但是返回却不都是布尔值的.下面就是非布尔值进行逻辑运算的几种情况\n例如:\n'dog' || anything = 'dog'\n'dog' && anything = anything\n\n也就是说虽然是用的布尔值在进行的判断,但是最后的返回的时候,是返回的本身的值而不一定是布尔值\n\n同时,被认定为false的情况只有: undefined,'',null,NaN,0\n**注意**  []空数组不会被认为是false\n\n同时上面的 | & 是位运算,根本就不是逻辑运算,别搞混了.\n13 | 5 返回的是13而不是true之类的布尔值,同时13 & 5返回的是5\n\n### 数组的拍平\n[1,2,[3,4,[5]]] -> [1,2,3,4,5]\n一直看到过这个题,看了蛮多的方法.在这里记录一下\n\n#### 方法一:递归\n```js\nfunction flatten (arr){\n    return arr.reduce((all, cur) =>{\n        return all.concat(Array.isArray(cur) ? flatten(cur) : cur)\n    },[])\n}\n```\n\n#### 方法二: 利用toString()}\n```js \nfunction flatten (arr) {\n    return arr.toString().split(',')\n}\n// 存在一个小小的问题,所有的 number 类型都会被转成string类型\n    return arr.toString().split(',').map(Number)\n// 然后再去个重,排个序\n    return Array.from(new Set(arr.toString().split(',').map(Number).sort((a,b) => a-b)))\n```\n> 当时看到这个toString()方法的时候,只觉得自己对JS的了解太不够了,得继续学习啊.这里我就总结一下toString()的各种用法\n\n原型链的最底层toString()是定义在Object上面的.看下在 Object 情况下的值\n\n\n```js\n    var toString = Object.prototype.toString;\n    toString.call(new Date); // [object Date]\n    toString.call(new String); // [object String]\n    toString.call(Math); // [object Math]\n    toString.call(undefined); // [object Undefined]\n    toString.call(null); // [object Null]\n```\n这是用的 Object 上面的toString方法, 同时在其他类型还直接重写toString方法\n有: Boolean, Array, Function, RegExp, Number, String, Date\n\nBoolean中,直接使用重写的toString 方法, 会直接转化成 'true','false' 的字符串类型\n\nfunction中,也直接会把整个函数体转化成 String, 注意一点如果是匿名函数, 转化的函数体的名称会是 anonymous \n```js\nvar sum = new Function('a', 'b', 'return a + b');\nvar c =function () {console.log('a')}\nc.toString() \n// \"function () {console.log('a')}\"\nsum.toString()\n// \"function anonymous(a,b\n// ) {\n// return a + b\n}\"\n```\n\nArray中,也就是直接转成string,同时里面如果还有数组的话, 也会递归的转化成 string,就完成了数组的拍平\n\nRegExp 正则对象的使用方法和function 看起来其实是一个意思,会返回一个标准的 // 的string\n而 date 对象会返回一个标准的一个美式英语日期格式的字符串在当地时区的string\n\n### 学习BFC\n\n> 什么是BFC,全称 Block Formatting Context,中文就是块级格式化上下文.\n\n#### 产生BFC的条件\n\n1. 根元素或者包含它的子元素\n2. 浮动 (元素的 float 不为 none 的情况)\n3. 绝对定位元素 ( position为 fixed 或者 absolute )\n4. 行内快 ( display 为 inline-block )\n5. 表格单元格 ( display 为 table-cell )\n6. overflow 不为 visible 的元素\n7. 弹性盒 flex 布局\n\n#### BFC特性\n\nBFC中会形成一个隔离空间,其中会有一个常规流\n计算BFC的高度的时候,考虑包含BFC的所有元素,浮动元素也计算其中\n但是,浮动盒区域不会叠加到BFC上面\n> \n    内部的Box会在垂直方向，从顶部开始一个接一个地放置。\n    Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加\n    每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n    BFC的区域不会与float box叠加。\n    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n    计算BFC的高度时，浮动元素也参与计算。\n\n\n利用这些特性可以解决的问题:\n\nmargin 合并的问题  -  特性: BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n\n使用浮动元素之后,高度塌陷 - 特性: 就是BFC不会与浮动盒子叠加, 就不会产生任何的塌陷了\n\n清除浮动, 这个与上面的问题相似, 是让浮动元素也参与高度计算的方法 - 特性: 计算BFC的高度时，浮动元素也参与计算。\n\n\n### 异步知识补充\n\n其实关于JS的事件循环的宏任务,微任务基本上了解的差不多. (仅仅是了解,实现了解的还不够深入)\n但是关于async 和 await 的知识却忽略了.\n补充知识:(console.log()的执行顺序)\n```js\n    async function async1() {\n        console.log('async1 start');\n        await async2();\n        console.log('async1 end');\n    }\n    async function async2() {\n        console.log('async2');\n    }\n\n    console.log('script start');\n\n    setTimeout(function() {\n        console.log('setTimeout');\n    }, 0)\n\n    async1();\n\n    new Promise(function(resolve) {\n        console.log('promise1');\n        resolve();\n    }).then(function() {\n        console.log('promise2');\n    });\n    console.log('script end');\n````\n看上面的await async2();console.log('async1 end')\n其实await 只是 promise的语法糖而已,\n\n等同于:\nPromise.resolve(async2().then( () =>{\n    console.log(async1 end)\n}))","slug":"几道面试题的知识总结","published":1,"updated":"2019-03-19T11:56:49.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fj300197dxq3y28djlf","content":"<blockquote>\n<p>突然看到几道面试题,之前都有看到但是就是感觉似曾相识但是却有点恍惚.决定还是记录一遍加深印象</p>\n</blockquote>\n<h3 id=\"逻辑运算-amp-amp-的作用以及返回值\"><a href=\"#逻辑运算-amp-amp-的作用以及返回值\" class=\"headerlink\" title=\"逻辑运算 &amp;&amp; || 的作用以及返回值\"></a>逻辑运算 &amp;&amp; || 的作用以及返回值</h3><blockquote>\n<p>目前我存在的一个疑问,js中的| 和 || 的差异在哪里, 或者就是同一个东西.困扰中…<br>一个是逻辑运算,一个是位操作..</p>\n</blockquote>\n<h4 id=\"逻辑运算的特性\"><a href=\"#逻辑运算的特性\" class=\"headerlink\" title=\"逻辑运算的特性\"></a>逻辑运算的特性</h4><p>短路运算 </p>\n<p>在&amp;&amp;中,如果运算符前面的是 false 的值,那么后面的语句就会被忽略掉.<br>同理,在|| 中, 如果运算符前面是 true 的值,那么后面的语句也不会去运行的</p>\n<p>多个的情况,从左到右计算就好了</p>\n<p>运算的逻辑 </p>\n<p>逻辑运算的时候,比较的的确是布尔值, 但是返回却不都是布尔值的.下面就是非布尔值进行逻辑运算的几种情况<br>例如:<br>‘dog’ || anything = ‘dog’<br>‘dog’ &amp;&amp; anything = anything</p>\n<p>也就是说虽然是用的布尔值在进行的判断,但是最后的返回的时候,是返回的本身的值而不一定是布尔值</p>\n<p>同时,被认定为false的情况只有: undefined,’’,null,NaN,0<br><strong>注意</strong>  []空数组不会被认为是false</p>\n<p>同时上面的 | &amp; 是位运算,根本就不是逻辑运算,别搞混了.<br>13 | 5 返回的是13而不是true之类的布尔值,同时13 &amp; 5返回的是5</p>\n<h3 id=\"数组的拍平\"><a href=\"#数组的拍平\" class=\"headerlink\" title=\"数组的拍平\"></a>数组的拍平</h3><p>[1,2,[3,4,[5]]] -&gt; [1,2,3,4,5]<br>一直看到过这个题,看了蛮多的方法.在这里记录一下</p>\n<h4 id=\"方法一-递归\"><a href=\"#方法一-递归\" class=\"headerlink\" title=\"方法一:递归\"></a>方法一:递归</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span> (<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">all, cur</span>) =&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> all.concat(<span class=\"built_in\">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-利用toString\"><a href=\"#方法二-利用toString\" class=\"headerlink\" title=\"方法二: 利用toString()}\"></a>方法二: 利用toString()}</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存在一个小小的问题,所有的 number 类型都会被转成string类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\"><span class=\"comment\">// 然后再去个重,排个序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"built_in\">Number</span>).sort(<span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> a-b)))</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当时看到这个toString()方法的时候,只觉得自己对JS的了解太不够了,得继续学习啊.这里我就总结一下toString()的各种用法</p>\n</blockquote>\n<p>原型链的最底层toString()是定义在Object上面的.看下在 Object 情况下的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toString = <span class=\"built_in\">Object</span>.prototype.toString;</span><br><span class=\"line\">toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>); <span class=\"comment\">// [object Date]</span></span><br><span class=\"line\">toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>); <span class=\"comment\">// [object String]</span></span><br><span class=\"line\">toString.call(<span class=\"built_in\">Math</span>); <span class=\"comment\">// [object Math]</span></span><br><span class=\"line\">toString.call(<span class=\"literal\">undefined</span>); <span class=\"comment\">// [object Undefined]</span></span><br><span class=\"line\">toString.call(<span class=\"literal\">null</span>); <span class=\"comment\">// [object Null]</span></span><br></pre></td></tr></table></figure>\n<p>这是用的 Object 上面的toString方法, 同时在其他类型还直接重写toString方法<br>有: Boolean, Array, Function, RegExp, Number, String, Date</p>\n<p>Boolean中,直接使用重写的toString 方法, 会直接转化成 ‘true’,’false’ 的字符串类型</p>\n<p>function中,也直接会把整个函数体转化成 String, 注意一点如果是匿名函数, 转化的函数体的名称会是 anonymous<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'return a + b'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)&#125;</span><br><span class=\"line\">c.toString() </span><br><span class=\"line\"><span class=\"comment\">// \"function () &#123;console.log('a')&#125;\"</span></span><br><span class=\"line\">sum.toString()</span><br><span class=\"line\"><span class=\"comment\">// \"function anonymous(a,b</span></span><br><span class=\"line\"><span class=\"comment\">// ) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// return a + b</span></span><br><span class=\"line\">&#125;<span class=\"string\">\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Array中,也就是直接转成string,同时里面如果还有数组的话, 也会递归的转化成 string,就完成了数组的拍平</p>\n<p>RegExp 正则对象的使用方法和function 看起来其实是一个意思,会返回一个标准的 // 的string<br>而 date 对象会返回一个标准的一个美式英语日期格式的字符串在当地时区的string</p>\n<h3 id=\"学习BFC\"><a href=\"#学习BFC\" class=\"headerlink\" title=\"学习BFC\"></a>学习BFC</h3><blockquote>\n<p>什么是BFC,全称 Block Formatting Context,中文就是块级格式化上下文.</p>\n</blockquote>\n<h4 id=\"产生BFC的条件\"><a href=\"#产生BFC的条件\" class=\"headerlink\" title=\"产生BFC的条件\"></a>产生BFC的条件</h4><ol>\n<li>根元素或者包含它的子元素</li>\n<li>浮动 (元素的 float 不为 none 的情况)</li>\n<li>绝对定位元素 ( position为 fixed 或者 absolute )</li>\n<li>行内快 ( display 为 inline-block )</li>\n<li>表格单元格 ( display 为 table-cell )</li>\n<li>overflow 不为 visible 的元素</li>\n<li>弹性盒 flex 布局</li>\n</ol>\n<h4 id=\"BFC特性\"><a href=\"#BFC特性\" class=\"headerlink\" title=\"BFC特性\"></a>BFC特性</h4><p>BFC中会形成一个隔离空间,其中会有一个常规流<br>计算BFC的高度的时候,考虑包含BFC的所有元素,浮动元素也计算其中<br>但是,浮动盒区域不会叠加到BFC上面</p>\n<blockquote>\n</blockquote>\n<pre><code>内部的Box会在垂直方向，从顶部开始一个接一个地放置。\nBox垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加\n每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\nBFC的区域不会与float box叠加。\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n计算BFC的高度时，浮动元素也参与计算。\n</code></pre><p>利用这些特性可以解决的问题:</p>\n<p>margin 合并的问题  -  特性: BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</p>\n<p>使用浮动元素之后,高度塌陷 - 特性: 就是BFC不会与浮动盒子叠加, 就不会产生任何的塌陷了</p>\n<p>清除浮动, 这个与上面的问题相似, 是让浮动元素也参与高度计算的方法 - 特性: 计算BFC的高度时，浮动元素也参与计算。</p>\n<h3 id=\"异步知识补充\"><a href=\"#异步知识补充\" class=\"headerlink\" title=\"异步知识补充\"></a>异步知识补充</h3><p>其实关于JS的事件循环的宏任务,微任务基本上了解的差不多. (仅仅是了解,实现了解的还不够深入)<br>但是关于async 和 await 的知识却忽略了.<br>补充知识:(console.log()的执行顺序)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 start'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    async1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure></p>\n<p>看上面的await async2();console.log(‘async1 end’)<br>其实await 只是 promise的语法糖而已,</p>\n<p>等同于:<br>Promise.resolve(async2().then( () =&gt;{<br>    console.log(async1 end)<br>}))</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>突然看到几道面试题,之前都有看到但是就是感觉似曾相识但是却有点恍惚.决定还是记录一遍加深印象</p>\n</blockquote>\n<h3 id=\"逻辑运算-amp-amp-的作用以及返回值\"><a href=\"#逻辑运算-amp-amp-的作用以及返回值\" class=\"headerlink\" title=\"逻辑运算 &amp;&amp; || 的作用以及返回值\"></a>逻辑运算 &amp;&amp; || 的作用以及返回值</h3><blockquote>\n<p>目前我存在的一个疑问,js中的| 和 || 的差异在哪里, 或者就是同一个东西.困扰中…<br>一个是逻辑运算,一个是位操作..</p>\n</blockquote>\n<h4 id=\"逻辑运算的特性\"><a href=\"#逻辑运算的特性\" class=\"headerlink\" title=\"逻辑运算的特性\"></a>逻辑运算的特性</h4><p>短路运算 </p>\n<p>在&amp;&amp;中,如果运算符前面的是 false 的值,那么后面的语句就会被忽略掉.<br>同理,在|| 中, 如果运算符前面是 true 的值,那么后面的语句也不会去运行的</p>\n<p>多个的情况,从左到右计算就好了</p>\n<p>运算的逻辑 </p>\n<p>逻辑运算的时候,比较的的确是布尔值, 但是返回却不都是布尔值的.下面就是非布尔值进行逻辑运算的几种情况<br>例如:<br>‘dog’ || anything = ‘dog’<br>‘dog’ &amp;&amp; anything = anything</p>\n<p>也就是说虽然是用的布尔值在进行的判断,但是最后的返回的时候,是返回的本身的值而不一定是布尔值</p>\n<p>同时,被认定为false的情况只有: undefined,’’,null,NaN,0<br><strong>注意</strong>  []空数组不会被认为是false</p>\n<p>同时上面的 | &amp; 是位运算,根本就不是逻辑运算,别搞混了.<br>13 | 5 返回的是13而不是true之类的布尔值,同时13 &amp; 5返回的是5</p>\n<h3 id=\"数组的拍平\"><a href=\"#数组的拍平\" class=\"headerlink\" title=\"数组的拍平\"></a>数组的拍平</h3><p>[1,2,[3,4,[5]]] -&gt; [1,2,3,4,5]<br>一直看到过这个题,看了蛮多的方法.在这里记录一下</p>\n<h4 id=\"方法一-递归\"><a href=\"#方法一-递归\" class=\"headerlink\" title=\"方法一:递归\"></a>方法一:递归</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span> (<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">all, cur</span>) =&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> all.concat(<span class=\"built_in\">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class=\"line\">    &#125;,[])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二-利用toString\"><a href=\"#方法二-利用toString\" class=\"headerlink\" title=\"方法二: 利用toString()}\"></a>方法二: 利用toString()}</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 存在一个小小的问题,所有的 number 类型都会被转成string类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\"><span class=\"comment\">// 然后再去个重,排个序</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"built_in\">Number</span>).sort(<span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> a-b)))</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当时看到这个toString()方法的时候,只觉得自己对JS的了解太不够了,得继续学习啊.这里我就总结一下toString()的各种用法</p>\n</blockquote>\n<p>原型链的最底层toString()是定义在Object上面的.看下在 Object 情况下的值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toString = <span class=\"built_in\">Object</span>.prototype.toString;</span><br><span class=\"line\">toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>); <span class=\"comment\">// [object Date]</span></span><br><span class=\"line\">toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>); <span class=\"comment\">// [object String]</span></span><br><span class=\"line\">toString.call(<span class=\"built_in\">Math</span>); <span class=\"comment\">// [object Math]</span></span><br><span class=\"line\">toString.call(<span class=\"literal\">undefined</span>); <span class=\"comment\">// [object Undefined]</span></span><br><span class=\"line\">toString.call(<span class=\"literal\">null</span>); <span class=\"comment\">// [object Null]</span></span><br></pre></td></tr></table></figure>\n<p>这是用的 Object 上面的toString方法, 同时在其他类型还直接重写toString方法<br>有: Boolean, Array, Function, RegExp, Number, String, Date</p>\n<p>Boolean中,直接使用重写的toString 方法, 会直接转化成 ‘true’,’false’ 的字符串类型</p>\n<p>function中,也直接会把整个函数体转化成 String, 注意一点如果是匿名函数, 转化的函数体的名称会是 anonymous<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'return a + b'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> c =<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>)&#125;</span><br><span class=\"line\">c.toString() </span><br><span class=\"line\"><span class=\"comment\">// \"function () &#123;console.log('a')&#125;\"</span></span><br><span class=\"line\">sum.toString()</span><br><span class=\"line\"><span class=\"comment\">// \"function anonymous(a,b</span></span><br><span class=\"line\"><span class=\"comment\">// ) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// return a + b</span></span><br><span class=\"line\">&#125;<span class=\"string\">\"</span></span><br></pre></td></tr></table></figure></p>\n<p>Array中,也就是直接转成string,同时里面如果还有数组的话, 也会递归的转化成 string,就完成了数组的拍平</p>\n<p>RegExp 正则对象的使用方法和function 看起来其实是一个意思,会返回一个标准的 // 的string<br>而 date 对象会返回一个标准的一个美式英语日期格式的字符串在当地时区的string</p>\n<h3 id=\"学习BFC\"><a href=\"#学习BFC\" class=\"headerlink\" title=\"学习BFC\"></a>学习BFC</h3><blockquote>\n<p>什么是BFC,全称 Block Formatting Context,中文就是块级格式化上下文.</p>\n</blockquote>\n<h4 id=\"产生BFC的条件\"><a href=\"#产生BFC的条件\" class=\"headerlink\" title=\"产生BFC的条件\"></a>产生BFC的条件</h4><ol>\n<li>根元素或者包含它的子元素</li>\n<li>浮动 (元素的 float 不为 none 的情况)</li>\n<li>绝对定位元素 ( position为 fixed 或者 absolute )</li>\n<li>行内快 ( display 为 inline-block )</li>\n<li>表格单元格 ( display 为 table-cell )</li>\n<li>overflow 不为 visible 的元素</li>\n<li>弹性盒 flex 布局</li>\n</ol>\n<h4 id=\"BFC特性\"><a href=\"#BFC特性\" class=\"headerlink\" title=\"BFC特性\"></a>BFC特性</h4><p>BFC中会形成一个隔离空间,其中会有一个常规流<br>计算BFC的高度的时候,考虑包含BFC的所有元素,浮动元素也计算其中<br>但是,浮动盒区域不会叠加到BFC上面</p>\n<blockquote>\n</blockquote>\n<pre><code>内部的Box会在垂直方向，从顶部开始一个接一个地放置。\nBox垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加\n每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\nBFC的区域不会与float box叠加。\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。\n计算BFC的高度时，浮动元素也参与计算。\n</code></pre><p>利用这些特性可以解决的问题:</p>\n<p>margin 合并的问题  -  特性: BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</p>\n<p>使用浮动元素之后,高度塌陷 - 特性: 就是BFC不会与浮动盒子叠加, 就不会产生任何的塌陷了</p>\n<p>清除浮动, 这个与上面的问题相似, 是让浮动元素也参与高度计算的方法 - 特性: 计算BFC的高度时，浮动元素也参与计算。</p>\n<h3 id=\"异步知识补充\"><a href=\"#异步知识补充\" class=\"headerlink\" title=\"异步知识补充\"></a>异步知识补充</h3><p>其实关于JS的事件循环的宏任务,微任务基本上了解的差不多. (仅仅是了解,实现了解的还不够深入)<br>但是关于async 和 await 的知识却忽略了.<br>补充知识:(console.log()的执行顺序)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 start'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    async1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure></p>\n<p>看上面的await async2();console.log(‘async1 end’)<br>其实await 只是 promise的语法糖而已,</p>\n<p>等同于:<br>Promise.resolve(async2().then( () =&gt;{<br>    console.log(async1 end)<br>}))</p>\n"},{"title":"几种常见的递归函数","date":"2019-03-25T07:53:22.000Z","_content":"> 本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现\n\n## 树形结构对象的遍历\n\n完成一个函数，作用是返回对象的最大深度（其实就是树的深度）\n\n首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1\n\n一个递归的原型就形成了\n\n1. 相连项目之间的关系\n2. 递归退出的条件\n\n所以递归的套路模板一般形如：\n```js\nif (基本情况) {\n    直接返回，退出函数\n} else {\n    继续调用(新的参数)\n}\n```\n\n那么，按照上面的描述，写出这个函数\n\n```js\nfunction traverse(obj) {\n    if (obj === null) return 0\n    // 判断是不是单层对象\n    const getSons = (obj) => {\n        return getObjChildren(obj).every((item) => {\n            return Object.prototype.toString.call(item) !== '[object Object]' // 对象类型判断\n        })\n    }\n    if (getSons(obj)) return 1\n    let max = 0\n    getObjChildren(obj).forEach(item => {\n        max = traverse(item) > max ? traverse(item) : max\n    })\n    return max + 1\n}\n// 获取对象的直接儿子元素，返回数组\nfunction getObjChildren(obj) {\n    let result = []\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const element = obj[key];\n            result.push(element)\n        }\n    }\n    return result\n}\n```\n\n使用递归就是这么做的，如果不能使用递归呢。\n\n我们将思维转化一下，不要江化。\n\n这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。\n\n```js\nfunction layerTraverse(obj) {\n    if (obj === null) return 0\n    let layer = 1\n    let queues = [] // 用于存放一层的所有数据\n    queues = getObjChildren(obj)\n    // 如何通过两个while 完成对所有节点的遍历\n    // 第一个while 作为外圈， 判断下一层是否还有数据\n    // 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue\n    while (queues.length > 0) {\n        layer++\n        let length = queues.length\n        while (length > 0) {\n            let item = queues.shift()\n            queues.push(...getObjChildren(item))\n            length--\n        }\n    }\n    return layer\n}\n```\n同时这还利用了堆的思想。  \n\n## 阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)\n\n明确这三个的定义：\n\n阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1\n\nFibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1\n\nHanoiTower(汉诺塔)：\n有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：\n\n1.  每次只能移动一个圆盘；\n2.  大盘不能叠在小盘上面。\n\n提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。\n\n问：如何移？最少要移动多少次？\n\n### Fibonacci函数\n\n```js\nfunction Fibonacci(n){\n    if (n === 1 || n === 2) return 1\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n\n```\n这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。\n\n这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。\n\n我们不适用这些办法，我这里想做的是用循环代替递归。\n\n也就是适用DP的思想，只保存当前运算时需要的数据。\n\n```js\nfunction Fibonacci2(n) {\n    if (n === 1 || n === 2) return 1\n    let result = 1, \n    a1 = 1\n    for (let i = 3; i <= n; i++){\n        result = result + a1\n        a1 = result - a1\n    }    \n}\n```\n上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。\n\n> update: 2019-03-29\n\n发现了一种更优雅的实现\n```js\nfunction Fibonacci3(n){\n    let [prev, curr] = [0, 1]\n    while(n-- > 1) {\n        [prev, curr] = [curr, curr + prev]\n    }\n    return curr\n}\n```\n代码量更少，更容易阅读。思路来自于MDN迭代器中的实现。\n\n### 阶乘\n\n```js\nfunction factorial(n) {\n    if (n == 1) return 1\n    return factorial(n - 1) * n\n}\n```\n\n```js\nfunction factorial2(n){\n    if (n===1) return 1\n    let result = 1\n    for (let i = 2; i <= n; i++){\n        result = i * result\n    }\n    return result\n}\n```\n\n### HanoiTower(汉诺塔)\n\n![汉诺塔](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)\n\n思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去\n\n```js\nfunction HanoiTower(n, from, by, to) {\n    if (n === 1) {\n        move(1, from, to)\n    } else {\n        HanoiTower(n - 1, from, by, to)\n        move(n, from, to)\n        HanoiTower(n - 1, to, by, from)\n    }\n}\nfunction move(n, from, to, index) {\n    console.log(`移动第${n}个从${from} ----> ${to}`)\n}\n```\n\n## 尾调用\n\n> 除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。\n\n尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。\n\n只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。\n\n这是对Fibonacci函数的尾递归改造：\n```js\nfunction Fibonacci3(n, val1, val2) {\n    if (n === 1) return val2\n    return Fibonacci3(n - 1, val1 + val2, val1)\n}\n```\n\n再对阶乘函数进行改造：\n```js\nfunction factorial(n, total){\n    if (n === 1) return total\n    return factorial(n - 1, n * total)\n}\n```\n\n看以上两个尾递归的函数，我们在使用的时候，都得显视的传入 val1 或者 total 这种开始的值。\n\n会让函数的意义不容易懂。\n\n这里有两种办法，一种是**柯里化**，另一种是**参数默认值**\n\n### 柯里化\n\n需要在外圈再包一个函数，如果是Fibonacci 函数的话。\n\n```js\nfunction currying(fn, n){\n    return function(val) {\n        fn.call(this, val, n)\n    }\n}\n\nconst Fibonacci3_1 = currying(Fibonacci3, 1)\n```\n\n### 函数默认值\n\n```js\nfunction Fibonacci3(n, val1 = 1, val2 = 1) {\n    if (n === 1) return val2\n    return Fibonacci3(n - 1, val1 + val2, val1)\n}\n```","source":"_posts/几种常见的递归函数.md","raw":"---\ntitle: 几种常见的递归函数\ndate: 2019-03-25 15:53:22\ntags: 算法\n---\n> 本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现\n\n## 树形结构对象的遍历\n\n完成一个函数，作用是返回对象的最大深度（其实就是树的深度）\n\n首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1\n\n一个递归的原型就形成了\n\n1. 相连项目之间的关系\n2. 递归退出的条件\n\n所以递归的套路模板一般形如：\n```js\nif (基本情况) {\n    直接返回，退出函数\n} else {\n    继续调用(新的参数)\n}\n```\n\n那么，按照上面的描述，写出这个函数\n\n```js\nfunction traverse(obj) {\n    if (obj === null) return 0\n    // 判断是不是单层对象\n    const getSons = (obj) => {\n        return getObjChildren(obj).every((item) => {\n            return Object.prototype.toString.call(item) !== '[object Object]' // 对象类型判断\n        })\n    }\n    if (getSons(obj)) return 1\n    let max = 0\n    getObjChildren(obj).forEach(item => {\n        max = traverse(item) > max ? traverse(item) : max\n    })\n    return max + 1\n}\n// 获取对象的直接儿子元素，返回数组\nfunction getObjChildren(obj) {\n    let result = []\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const element = obj[key];\n            result.push(element)\n        }\n    }\n    return result\n}\n```\n\n使用递归就是这么做的，如果不能使用递归呢。\n\n我们将思维转化一下，不要江化。\n\n这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。\n\n```js\nfunction layerTraverse(obj) {\n    if (obj === null) return 0\n    let layer = 1\n    let queues = [] // 用于存放一层的所有数据\n    queues = getObjChildren(obj)\n    // 如何通过两个while 完成对所有节点的遍历\n    // 第一个while 作为外圈， 判断下一层是否还有数据\n    // 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue\n    while (queues.length > 0) {\n        layer++\n        let length = queues.length\n        while (length > 0) {\n            let item = queues.shift()\n            queues.push(...getObjChildren(item))\n            length--\n        }\n    }\n    return layer\n}\n```\n同时这还利用了堆的思想。  \n\n## 阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)\n\n明确这三个的定义：\n\n阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1\n\nFibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1\n\nHanoiTower(汉诺塔)：\n有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：\n\n1.  每次只能移动一个圆盘；\n2.  大盘不能叠在小盘上面。\n\n提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。\n\n问：如何移？最少要移动多少次？\n\n### Fibonacci函数\n\n```js\nfunction Fibonacci(n){\n    if (n === 1 || n === 2) return 1\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n\n```\n这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。\n\n这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。\n\n我们不适用这些办法，我这里想做的是用循环代替递归。\n\n也就是适用DP的思想，只保存当前运算时需要的数据。\n\n```js\nfunction Fibonacci2(n) {\n    if (n === 1 || n === 2) return 1\n    let result = 1, \n    a1 = 1\n    for (let i = 3; i <= n; i++){\n        result = result + a1\n        a1 = result - a1\n    }    \n}\n```\n上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。\n\n> update: 2019-03-29\n\n发现了一种更优雅的实现\n```js\nfunction Fibonacci3(n){\n    let [prev, curr] = [0, 1]\n    while(n-- > 1) {\n        [prev, curr] = [curr, curr + prev]\n    }\n    return curr\n}\n```\n代码量更少，更容易阅读。思路来自于MDN迭代器中的实现。\n\n### 阶乘\n\n```js\nfunction factorial(n) {\n    if (n == 1) return 1\n    return factorial(n - 1) * n\n}\n```\n\n```js\nfunction factorial2(n){\n    if (n===1) return 1\n    let result = 1\n    for (let i = 2; i <= n; i++){\n        result = i * result\n    }\n    return result\n}\n```\n\n### HanoiTower(汉诺塔)\n\n![汉诺塔](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)\n\n思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去\n\n```js\nfunction HanoiTower(n, from, by, to) {\n    if (n === 1) {\n        move(1, from, to)\n    } else {\n        HanoiTower(n - 1, from, by, to)\n        move(n, from, to)\n        HanoiTower(n - 1, to, by, from)\n    }\n}\nfunction move(n, from, to, index) {\n    console.log(`移动第${n}个从${from} ----> ${to}`)\n}\n```\n\n## 尾调用\n\n> 除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。\n\n尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。\n\n只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。\n\n这是对Fibonacci函数的尾递归改造：\n```js\nfunction Fibonacci3(n, val1, val2) {\n    if (n === 1) return val2\n    return Fibonacci3(n - 1, val1 + val2, val1)\n}\n```\n\n再对阶乘函数进行改造：\n```js\nfunction factorial(n, total){\n    if (n === 1) return total\n    return factorial(n - 1, n * total)\n}\n```\n\n看以上两个尾递归的函数，我们在使用的时候，都得显视的传入 val1 或者 total 这种开始的值。\n\n会让函数的意义不容易懂。\n\n这里有两种办法，一种是**柯里化**，另一种是**参数默认值**\n\n### 柯里化\n\n需要在外圈再包一个函数，如果是Fibonacci 函数的话。\n\n```js\nfunction currying(fn, n){\n    return function(val) {\n        fn.call(this, val, n)\n    }\n}\n\nconst Fibonacci3_1 = currying(Fibonacci3, 1)\n```\n\n### 函数默认值\n\n```js\nfunction Fibonacci3(n, val1 = 1, val2 = 1) {\n    if (n === 1) return val2\n    return Fibonacci3(n - 1, val1 + val2, val1)\n}\n```","slug":"几种常见的递归函数","published":1,"updated":"2019-03-31T02:31:52.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fj6001a7dxq8qrls9sp","content":"<blockquote>\n<p>本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现</p>\n</blockquote>\n<h2 id=\"树形结构对象的遍历\"><a href=\"#树形结构对象的遍历\" class=\"headerlink\" title=\"树形结构对象的遍历\"></a>树形结构对象的遍历</h2><p>完成一个函数，作用是返回对象的最大深度（其实就是树的深度）</p>\n<p>首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1</p>\n<p>一个递归的原型就形成了</p>\n<ol>\n<li>相连项目之间的关系</li>\n<li>递归退出的条件</li>\n</ol>\n<p>所以递归的套路模板一般形如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (基本情况) &#123;</span><br><span class=\"line\">    直接返回，退出函数</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    继续调用(新的参数)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么，按照上面的描述，写出这个函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 判断是不是单层对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> getSons = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getObjChildren(obj).every(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(item) !== <span class=\"string\">'[object Object]'</span> <span class=\"comment\">// 对象类型判断</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getSons(obj)) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> max = <span class=\"number\">0</span></span><br><span class=\"line\">    getObjChildren(obj).forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        max = traverse(item) &gt; max ? traverse(item) : max</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取对象的直接儿子元素，返回数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getObjChildren</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> element = obj[key];</span><br><span class=\"line\">            result.push(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用递归就是这么做的，如果不能使用递归呢。</p>\n<p>我们将思维转化一下，不要江化。</p>\n<p>这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">layerTraverse</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> layer = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> queues = [] <span class=\"comment\">// 用于存放一层的所有数据</span></span><br><span class=\"line\">    queues = getObjChildren(obj)</span><br><span class=\"line\">    <span class=\"comment\">// 如何通过两个while 完成对所有节点的遍历</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一个while 作为外圈， 判断下一层是否还有数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queues.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        layer++</span><br><span class=\"line\">        <span class=\"keyword\">let</span> length = queues.length</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> item = queues.shift()</span><br><span class=\"line\">            queues.push(...getObjChildren(item))</span><br><span class=\"line\">            length--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> layer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时这还利用了堆的思想。  </p>\n<h2 id=\"阶乘、Fibonacci函数以及-HanoiTower-汉诺塔\"><a href=\"#阶乘、Fibonacci函数以及-HanoiTower-汉诺塔\" class=\"headerlink\" title=\"阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)\"></a>阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)</h2><p>明确这三个的定义：</p>\n<p>阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1</p>\n<p>Fibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1</p>\n<p>HanoiTower(汉诺塔)：<br>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>\n<ol>\n<li>每次只能移动一个圆盘；</li>\n<li>大盘不能叠在小盘上面。</li>\n</ol>\n<p>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>\n<p>问：如何移？最少要移动多少次？</p>\n<h3 id=\"Fibonacci函数\"><a href=\"#Fibonacci函数\" class=\"headerlink\" title=\"Fibonacci函数\"></a>Fibonacci函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci(n - <span class=\"number\">1</span>) + Fibonacci(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。</p>\n<p>这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。</p>\n<p>我们不适用这些办法，我这里想做的是用循环代替递归。</p>\n<p>也就是适用DP的思想，只保存当前运算时需要的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">1</span>, </span><br><span class=\"line\">    a1 = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        result = result + a1</span><br><span class=\"line\">        a1 = result - a1</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。</p>\n<blockquote>\n<p>update: 2019-03-29</p>\n</blockquote>\n<p>发现了一种更优雅的实现<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> [prev, curr] = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n-- &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        [prev, curr] = [curr, curr + prev]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> curr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码量更少，更容易阅读。思路来自于MDN迭代器中的实现。</p>\n<h3 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>) * n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial2</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        result = i * result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HanoiTower-汉诺塔\"><a href=\"#HanoiTower-汉诺塔\" class=\"headerlink\" title=\"HanoiTower(汉诺塔)\"></a>HanoiTower(汉诺塔)</h3><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg\" alt=\"汉诺塔\"></p>\n<p>思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HanoiTower</span>(<span class=\"params\">n, from, by, to</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        move(<span class=\"number\">1</span>, <span class=\"keyword\">from</span>, to)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        HanoiTower(n - <span class=\"number\">1</span>, <span class=\"keyword\">from</span>, by, to)</span><br><span class=\"line\">        move(n, <span class=\"keyword\">from</span>, to)</span><br><span class=\"line\">        HanoiTower(n - <span class=\"number\">1</span>, to, by, <span class=\"keyword\">from</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">n, from, to, index</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`移动第<span class=\"subst\">$&#123;n&#125;</span>个从<span class=\"subst\">$&#123;<span class=\"keyword\">from</span>&#125;</span> ----&gt; <span class=\"subst\">$&#123;to&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h2><blockquote>\n<p>除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。</p>\n</blockquote>\n<p>尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。</p>\n<p>只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。</p>\n<p>这是对Fibonacci函数的尾递归改造：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n, val1, val2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> val2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci3(n - <span class=\"number\">1</span>, val1 + val2, val1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再对阶乘函数进行改造：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看以上两个尾递归的函数，我们在使用的时候，都得显视的传入 val1 或者 total 这种开始的值。</p>\n<p>会让函数的意义不容易懂。</p>\n<p>这里有两种办法，一种是<strong>柯里化</strong>，另一种是<strong>参数默认值</strong></p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>需要在外圈再包一个函数，如果是Fibonacci 函数的话。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        fn.call(<span class=\"keyword\">this</span>, val, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Fibonacci3_1 = currying(Fibonacci3, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数默认值\"><a href=\"#函数默认值\" class=\"headerlink\" title=\"函数默认值\"></a>函数默认值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n, val1 = <span class=\"number\">1</span>, val2 = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> val2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci3(n - <span class=\"number\">1</span>, val1 + val2, val1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现</p>\n</blockquote>\n<h2 id=\"树形结构对象的遍历\"><a href=\"#树形结构对象的遍历\" class=\"headerlink\" title=\"树形结构对象的遍历\"></a>树形结构对象的遍历</h2><p>完成一个函数，作用是返回对象的最大深度（其实就是树的深度）</p>\n<p>首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1</p>\n<p>一个递归的原型就形成了</p>\n<ol>\n<li>相连项目之间的关系</li>\n<li>递归退出的条件</li>\n</ol>\n<p>所以递归的套路模板一般形如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (基本情况) &#123;</span><br><span class=\"line\">    直接返回，退出函数</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    继续调用(新的参数)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么，按照上面的描述，写出这个函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">traverse</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 判断是不是单层对象</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> getSons = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getObjChildren(obj).every(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(item) !== <span class=\"string\">'[object Object]'</span> <span class=\"comment\">// 对象类型判断</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getSons(obj)) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> max = <span class=\"number\">0</span></span><br><span class=\"line\">    getObjChildren(obj).forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">        max = traverse(item) &gt; max ? traverse(item) : max</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取对象的直接儿子元素，返回数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getObjChildren</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> element = obj[key];</span><br><span class=\"line\">            result.push(element)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用递归就是这么做的，如果不能使用递归呢。</p>\n<p>我们将思维转化一下，不要江化。</p>\n<p>这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">layerTraverse</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> layer = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> queues = [] <span class=\"comment\">// 用于存放一层的所有数据</span></span><br><span class=\"line\">    queues = getObjChildren(obj)</span><br><span class=\"line\">    <span class=\"comment\">// 如何通过两个while 完成对所有节点的遍历</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一个while 作为外圈， 判断下一层是否还有数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queues.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        layer++</span><br><span class=\"line\">        <span class=\"keyword\">let</span> length = queues.length</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> item = queues.shift()</span><br><span class=\"line\">            queues.push(...getObjChildren(item))</span><br><span class=\"line\">            length--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> layer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时这还利用了堆的思想。  </p>\n<h2 id=\"阶乘、Fibonacci函数以及-HanoiTower-汉诺塔\"><a href=\"#阶乘、Fibonacci函数以及-HanoiTower-汉诺塔\" class=\"headerlink\" title=\"阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)\"></a>阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)</h2><p>明确这三个的定义：</p>\n<p>阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1</p>\n<p>Fibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1</p>\n<p>HanoiTower(汉诺塔)：<br>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>\n<ol>\n<li>每次只能移动一个圆盘；</li>\n<li>大盘不能叠在小盘上面。</li>\n</ol>\n<p>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>\n<p>问：如何移？最少要移动多少次？</p>\n<h3 id=\"Fibonacci函数\"><a href=\"#Fibonacci函数\" class=\"headerlink\" title=\"Fibonacci函数\"></a>Fibonacci函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci(n - <span class=\"number\">1</span>) + Fibonacci(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。</p>\n<p>这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。</p>\n<p>我们不适用这些办法，我这里想做的是用循环代替递归。</p>\n<p>也就是适用DP的思想，只保存当前运算时需要的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci2</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">1</span>, </span><br><span class=\"line\">    a1 = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        result = result + a1</span><br><span class=\"line\">        a1 = result - a1</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。</p>\n<blockquote>\n<p>update: 2019-03-29</p>\n</blockquote>\n<p>发现了一种更优雅的实现<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> [prev, curr] = [<span class=\"number\">0</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n-- &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        [prev, curr] = [curr, curr + prev]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> curr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码量更少，更容易阅读。思路来自于MDN迭代器中的实现。</p>\n<h3 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>) * n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial2</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n===<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        result = i * result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"HanoiTower-汉诺塔\"><a href=\"#HanoiTower-汉诺塔\" class=\"headerlink\" title=\"HanoiTower(汉诺塔)\"></a>HanoiTower(汉诺塔)</h3><p><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg\" alt=\"汉诺塔\"></p>\n<p>思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HanoiTower</span>(<span class=\"params\">n, from, by, to</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        move(<span class=\"number\">1</span>, <span class=\"keyword\">from</span>, to)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        HanoiTower(n - <span class=\"number\">1</span>, <span class=\"keyword\">from</span>, by, to)</span><br><span class=\"line\">        move(n, <span class=\"keyword\">from</span>, to)</span><br><span class=\"line\">        HanoiTower(n - <span class=\"number\">1</span>, to, by, <span class=\"keyword\">from</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">n, from, to, index</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`移动第<span class=\"subst\">$&#123;n&#125;</span>个从<span class=\"subst\">$&#123;<span class=\"keyword\">from</span>&#125;</span> ----&gt; <span class=\"subst\">$&#123;to&#125;</span>`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h2><blockquote>\n<p>除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。</p>\n</blockquote>\n<p>尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。</p>\n<p>只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。</p>\n<p>这是对Fibonacci函数的尾递归改造：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n, val1, val2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> val2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci3(n - <span class=\"number\">1</span>, val1 + val2, val1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再对阶乘函数进行改造：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看以上两个尾递归的函数，我们在使用的时候，都得显视的传入 val1 或者 total 这种开始的值。</p>\n<p>会让函数的意义不容易懂。</p>\n<p>这里有两种办法，一种是<strong>柯里化</strong>，另一种是<strong>参数默认值</strong></p>\n<h3 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h3><p>需要在外圈再包一个函数，如果是Fibonacci 函数的话。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        fn.call(<span class=\"keyword\">this</span>, val, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Fibonacci3_1 = currying(Fibonacci3, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数默认值\"><a href=\"#函数默认值\" class=\"headerlink\" title=\"函数默认值\"></a>函数默认值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci3</span>(<span class=\"params\">n, val1 = <span class=\"number\">1</span>, val2 = <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> val2</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Fibonacci3(n - <span class=\"number\">1</span>, val1 + val2, val1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"如何使用hexo(新手向)","date":"2019-01-09T01:45:04.000Z","_content":"> 大误  这是一篇通用文档\n这是一篇告诉女朋友怎么使用我给她搭建的博客的说明\n\nhexo的搭建过程就不说明了, 关键是现在怎么使用.\n\n### 拉取源码\n> 建议使用SSH\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fz03zrlcpjj30o80diwgj.jpg)\n\n` git clone git@github.com:pumpkinnan97/pumpkinnan97.github.io.git `\n拉取下来了了之后, 切换到blog分支\n` git checkout blog `\n安装依赖\n` npm i `\n\n#### 添加SSH\n> 要是我没有记错的话,你电脑之前肯定是配过SSH钥匙的.\n\n那么\n` cat ~/.ssh/id_rsa.pub `\n**command + c**  \n点击GitHub右上角进入 **Setting**  \n然后点击 左方的SSH \n` New SSH key `\n**command + v**\n完毕即可\n\n### hexo博客管理\n\nhexo g : Generate static files. 就是生成静态资源,在发布之前需要进行\nhexo s : Start the server.  这个的作用是在本地可以查看现在博客\nhexo d : Deploy your website. 发布\n\n使用` hexo new [your blog name]`\n然后进入`source`中的`_posts`就可以看到新建的博客,在已经存在的内容下面加上你的博客内容就可以了\n最后使用上面的`hexo g` `hexo d` 就完成了发布\n\n### hexo 主题以及配置\n\n>这一块都在**_config.yml**文件中,\n`theme: next`选择主题,前提是先需要把主题下载到博客根目录的 themes 文件中\n\n[主题](https://hexo.io/themes/)\n[插件](https://hexo.io/plugins/)\n\n就可以像QQ空间一样的愉快的玩耍了","source":"_posts/如何使用hexo-新手向.md","raw":"---\ntitle: 如何使用hexo(新手向)\ndate: 2019-01-09 09:45:04\ntags:\n---\n> 大误  这是一篇通用文档\n这是一篇告诉女朋友怎么使用我给她搭建的博客的说明\n\nhexo的搭建过程就不说明了, 关键是现在怎么使用.\n\n### 拉取源码\n> 建议使用SSH\n\n![](https://ws2.sinaimg.cn/large/006tNc79gy1fz03zrlcpjj30o80diwgj.jpg)\n\n` git clone git@github.com:pumpkinnan97/pumpkinnan97.github.io.git `\n拉取下来了了之后, 切换到blog分支\n` git checkout blog `\n安装依赖\n` npm i `\n\n#### 添加SSH\n> 要是我没有记错的话,你电脑之前肯定是配过SSH钥匙的.\n\n那么\n` cat ~/.ssh/id_rsa.pub `\n**command + c**  \n点击GitHub右上角进入 **Setting**  \n然后点击 左方的SSH \n` New SSH key `\n**command + v**\n完毕即可\n\n### hexo博客管理\n\nhexo g : Generate static files. 就是生成静态资源,在发布之前需要进行\nhexo s : Start the server.  这个的作用是在本地可以查看现在博客\nhexo d : Deploy your website. 发布\n\n使用` hexo new [your blog name]`\n然后进入`source`中的`_posts`就可以看到新建的博客,在已经存在的内容下面加上你的博客内容就可以了\n最后使用上面的`hexo g` `hexo d` 就完成了发布\n\n### hexo 主题以及配置\n\n>这一块都在**_config.yml**文件中,\n`theme: next`选择主题,前提是先需要把主题下载到博客根目录的 themes 文件中\n\n[主题](https://hexo.io/themes/)\n[插件](https://hexo.io/plugins/)\n\n就可以像QQ空间一样的愉快的玩耍了","slug":"如何使用hexo-新手向","published":1,"updated":"2019-03-07T11:39:38.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fj7001e7dxqlmtr57di","content":"<blockquote>\n<p>大误  这是一篇通用文档<br>这是一篇告诉女朋友怎么使用我给她搭建的博客的说明</p>\n</blockquote>\n<p>hexo的搭建过程就不说明了, 关键是现在怎么使用.</p>\n<h3 id=\"拉取源码\"><a href=\"#拉取源码\" class=\"headerlink\" title=\"拉取源码\"></a>拉取源码</h3><blockquote>\n<p>建议使用SSH</p>\n</blockquote>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fz03zrlcpjj30o80diwgj.jpg\" alt=\"\"></p>\n<p><code>git clone git@github.com:pumpkinnan97/pumpkinnan97.github.io.git</code><br>拉取下来了了之后, 切换到blog分支<br><code>git checkout blog</code><br>安装依赖<br><code>npm i</code></p>\n<h4 id=\"添加SSH\"><a href=\"#添加SSH\" class=\"headerlink\" title=\"添加SSH\"></a>添加SSH</h4><blockquote>\n<p>要是我没有记错的话,你电脑之前肯定是配过SSH钥匙的.</p>\n</blockquote>\n<p>那么<br><code>cat ~/.ssh/id_rsa.pub</code><br><strong>command + c</strong><br>点击GitHub右上角进入 <strong>Setting</strong><br>然后点击 左方的SSH<br><code>New SSH key</code><br><strong>command + v</strong><br>完毕即可</p>\n<h3 id=\"hexo博客管理\"><a href=\"#hexo博客管理\" class=\"headerlink\" title=\"hexo博客管理\"></a>hexo博客管理</h3><p>hexo g : Generate static files. 就是生成静态资源,在发布之前需要进行<br>hexo s : Start the server.  这个的作用是在本地可以查看现在博客<br>hexo d : Deploy your website. 发布</p>\n<p>使用<code>hexo new [your blog name]</code><br>然后进入<code>source</code>中的<code>_posts</code>就可以看到新建的博客,在已经存在的内容下面加上你的博客内容就可以了<br>最后使用上面的<code>hexo g</code> <code>hexo d</code> 就完成了发布</p>\n<h3 id=\"hexo-主题以及配置\"><a href=\"#hexo-主题以及配置\" class=\"headerlink\" title=\"hexo 主题以及配置\"></a>hexo 主题以及配置</h3><blockquote>\n<p>这一块都在<strong>_config.yml</strong>文件中,<br><code>theme: next</code>选择主题,前提是先需要把主题下载到博客根目录的 themes 文件中</p>\n</blockquote>\n<p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题</a><br><a href=\"https://hexo.io/plugins/\" target=\"_blank\" rel=\"noopener\">插件</a></p>\n<p>就可以像QQ空间一样的愉快的玩耍了</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大误  这是一篇通用文档<br>这是一篇告诉女朋友怎么使用我给她搭建的博客的说明</p>\n</blockquote>\n<p>hexo的搭建过程就不说明了, 关键是现在怎么使用.</p>\n<h3 id=\"拉取源码\"><a href=\"#拉取源码\" class=\"headerlink\" title=\"拉取源码\"></a>拉取源码</h3><blockquote>\n<p>建议使用SSH</p>\n</blockquote>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1fz03zrlcpjj30o80diwgj.jpg\" alt=\"\"></p>\n<p><code>git clone git@github.com:pumpkinnan97/pumpkinnan97.github.io.git</code><br>拉取下来了了之后, 切换到blog分支<br><code>git checkout blog</code><br>安装依赖<br><code>npm i</code></p>\n<h4 id=\"添加SSH\"><a href=\"#添加SSH\" class=\"headerlink\" title=\"添加SSH\"></a>添加SSH</h4><blockquote>\n<p>要是我没有记错的话,你电脑之前肯定是配过SSH钥匙的.</p>\n</blockquote>\n<p>那么<br><code>cat ~/.ssh/id_rsa.pub</code><br><strong>command + c</strong><br>点击GitHub右上角进入 <strong>Setting</strong><br>然后点击 左方的SSH<br><code>New SSH key</code><br><strong>command + v</strong><br>完毕即可</p>\n<h3 id=\"hexo博客管理\"><a href=\"#hexo博客管理\" class=\"headerlink\" title=\"hexo博客管理\"></a>hexo博客管理</h3><p>hexo g : Generate static files. 就是生成静态资源,在发布之前需要进行<br>hexo s : Start the server.  这个的作用是在本地可以查看现在博客<br>hexo d : Deploy your website. 发布</p>\n<p>使用<code>hexo new [your blog name]</code><br>然后进入<code>source</code>中的<code>_posts</code>就可以看到新建的博客,在已经存在的内容下面加上你的博客内容就可以了<br>最后使用上面的<code>hexo g</code> <code>hexo d</code> 就完成了发布</p>\n<h3 id=\"hexo-主题以及配置\"><a href=\"#hexo-主题以及配置\" class=\"headerlink\" title=\"hexo 主题以及配置\"></a>hexo 主题以及配置</h3><blockquote>\n<p>这一块都在<strong>_config.yml</strong>文件中,<br><code>theme: next</code>选择主题,前提是先需要把主题下载到博客根目录的 themes 文件中</p>\n</blockquote>\n<p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">主题</a><br><a href=\"https://hexo.io/plugins/\" target=\"_blank\" rel=\"noopener\">插件</a></p>\n<p>就可以像QQ空间一样的愉快的玩耍了</p>\n"},{"title":"普通图层和复合图层","date":"2019-03-29T02:36:23.000Z","_content":"\n> 理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。\n> 由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结\n\n浏览器渲染的图层一般包含两大类：普通图层以及复合图层\n\n首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。\n\n无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。\n\n当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。\n\n不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。\n\n### 如何开启硬件加速\n\n在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。\n最常用的方式：`translate3d`、`translateZ`。\n\n很多时候在本身没有使用3D变化的时候，可以用`transform: translateZ(0)`来使用。\n\n还有就是`opacity属性/过渡动画`\n\n### 注意事项\n\n在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。\n\n因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现\n\n### 作用\n\n开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。\n\n同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流\n\n### 总结\n\n图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。","source":"_posts/普通图层和复合图层.md","raw":"---\ntitle: 普通图层和复合图层\ndate: 2019-03-29 10:36:23\ntags: css\n---\n\n> 理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。\n> 由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结\n\n浏览器渲染的图层一般包含两大类：普通图层以及复合图层\n\n首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。\n\n无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。\n\n当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。\n\n不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。\n\n### 如何开启硬件加速\n\n在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。\n最常用的方式：`translate3d`、`translateZ`。\n\n很多时候在本身没有使用3D变化的时候，可以用`transform: translateZ(0)`来使用。\n\n还有就是`opacity属性/过渡动画`\n\n### 注意事项\n\n在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。\n\n因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现\n\n### 作用\n\n开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。\n\n同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流\n\n### 总结\n\n图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。","slug":"普通图层和复合图层","published":1,"updated":"2019-03-31T02:31:52.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fj9001h7dxq4cppvnf4","content":"<blockquote>\n<p>理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。<br>由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结</p>\n</blockquote>\n<p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p>\n<p>首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。</p>\n<p>无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。</p>\n<p>当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。</p>\n<p>不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。</p>\n<h3 id=\"如何开启硬件加速\"><a href=\"#如何开启硬件加速\" class=\"headerlink\" title=\"如何开启硬件加速\"></a>如何开启硬件加速</h3><p>在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。<br>最常用的方式：<code>translate3d</code>、<code>translateZ</code>。</p>\n<p>很多时候在本身没有使用3D变化的时候，可以用<code>transform: translateZ(0)</code>来使用。</p>\n<p>还有就是<code>opacity属性/过渡动画</code></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。</p>\n<p>因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。</p>\n<p>同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>理解浏览器渲染的图层，有利于我们去分析更加复杂的css渲染问题。<br>由于本人学艺暂时不精，本博客只对我所了解的片面知识做一个记录以及总结</p>\n</blockquote>\n<p>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p>\n<p>首先这个图层是对于硬件来说的，也就是GPU。在默认的渲染过程中，都只有一个图层，就是一个默认的复合层。</p>\n<p>无论有几个文档流，怎么添加元素都是在这个复合层中渲染的。</p>\n<p>当然，我们可以通过开启硬件加速，开启一个新的复合图层。这样在GPU中，会对这个新的图层进行单独绘制。</p>\n<p>不同的图层的绘制也是互不影响的，同时这样也是会脱离文档流的。</p>\n<h3 id=\"如何开启硬件加速\"><a href=\"#如何开启硬件加速\" class=\"headerlink\" title=\"如何开启硬件加速\"></a>如何开启硬件加速</h3><p>在浏览器中，如果打开的3d变化，浏览器会自动开启硬件加速(开启一个新的复合图层)。<br>最常用的方式：<code>translate3d</code>、<code>translateZ</code>。</p>\n<p>很多时候在本身没有使用3D变化的时候，可以用<code>transform: translateZ(0)</code>来使用。</p>\n<p>还有就是<code>opacity属性/过渡动画</code></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>在使用硬件加速的时候，我们应该尽可能的规定index，防止后面的元素也创建复合图层。</p>\n<p>因为如果开启硬件加速的元素图层index较低，在它之后的index层级的元素也会创建复合图层。我们应该避免这种情况的出现</p>\n<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>开启硬件加速，当然可以使页面的动画效果加载的更加流畅。但是，也不能过度的使用，浪费资源，造成卡顿。</p>\n<p>同时本身还脱离的文档流，大量的变动也不会引起整个页面重绘，回流</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>图层知识的掌握，就对为什么在做css动画的时候，要去做硬件加速，以及其中的原理，有了一个基础的了解。</p>\n"},{"title":"正则表达式","date":"2019-03-12T02:45:22.000Z","_content":"\n> 关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.\n\n## JS正则中的捕获元和非捕获元\n字符 | 描述\n---- | ----\n(pattern) | 匹配 pattern ,并且获取\n(?:pattern) | 匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组\n(?=pattern) | 正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)\n(?!pattern) | 正向预查的否定版\n\n这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)\n\n>题外话,`toLocaleSting('en')`的方式也可以\n\n对比三种正则的获取情况\n```js\nvar reg1 = /\\d{1,3}(\\d{3})+$/\nvar reg2 = /\\d{1,3}(?:(\\d{3})+)/g\nvar reg3 = /\\d{1,3}(?=(\\d{3})+$)/g\nvar num = '1234567890'\nnum.replace(reg1, function (p, $1, $2) {\n    console.log('p: ', p); // 1234567890\n    console.log('$1: ', $1); // 890\n    console.log('$2: ', $2); // 0\n})\nnum.replace(reg2, function (p, $1, $2) {\n    console.log('p: ', p); // 1234567890\n    console.log('$1: ', $1); // 890\n    console.log('$2: ', $2); // 0\n})\nnum.replace(reg3, function (p, $1, $2) {\n    console.log('p: ', p);\n    console.log('$1: ', $1);\n    console.log('$2: ', $2);\n})\n```\n\n首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.\n\n然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.\n`reg2 = /(\\d{1,3})(?:(\\d{3})+?)/g`\n\n```js\nnum.replace(reg2, function (p, $1, $2) {\n    console.log('p: ', p); // 123456   7890\n    console.log('$1: ', $1); // 123     7\n    console.log('$2: ', $2); // 456   890\n})\n```\n这时候会进行两轮,但是因为`?:`非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.\n这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.\n\n第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.\n因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.\n同时P就是我们需要的数值的前面的部分,只需要 `return p + ','`就可以了\n\n### 实用情况\n\n#### 验证密码的复杂性和位数\n要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号\n`/(?=.{6,})(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&&*()_+])/`\n\n#### 验证邮箱\n\n`/^[0-9a-zA-Z\\-_]+@[0-9a-zA-Z\\-_]+[\\.0-9a-zA-Z\\-_]+$/`\n\n#### 匹配汉字\n\n`[\\u4e00-\\u9fa5]`\n\n`[\\u4E00-\\u9FA5\\uf900-\\ufa2d]` \n\n#### 重学js中的正则表达式\n\n> 之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。\n\n不要去看什么教程，走官网的 [介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n)\n\n1. 正则基本API补充\n\nRegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项\n\nRegExp.prototype.source 获取去掉正则两侧的 `/` 以及标志字符的字符串\n\n2. 正则的工具使用\n\n[链接](https://regex101.com/)\n这个网站分析的很不错，比一些什么可视化网站好用的多。\n\n3. 案例分析\n\n> 这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.\n> `/\\{\\{((?:.|\\n)+?)\\}\\}/` & `^<((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)`\n\n```js\nfunction isPrimeNum2(num){\n    return !/^.?$|^(..+?)\\1+$/.test(Array(num + 1).join('1'))\n}\n```\n看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下...\n\nupdate：2019-04-09\n\n> 自我解答来了..\n\n先把正则之外的部分解决一下，`Array(num + 1).join('1')` 返回的是由1组成的num个的字符串。 之所以需要加一，是因为这里用的是join，个数会被减一。\n\n然后才是重头戏，正则部分。\n\n正则分成了两部分，前面的 `^.?$` 是对是否有内容的一个检查，不做多余的说明。\n\n后面的部分才是对真正的判断，这里我们只能判断是否是非素数，然后求反。\n\n`^(..+?)\\1+$`, 是对非素数的判断。\n\n非素数，就是除了1之外还有其他因子的数。\n\n这里，我们就来构造这样的情况。\n\n`(..+?)` 这里是一个非贪婪的捕获，会先用 `(..)` 的情况来进行匹配，后面是`\\1+$`对第一次捕获分组的帅选，如果满足条件，容易发现其实在就满足了被2整除的条件，那么就不是质数了。如果2没有匹配到，因为是`..+`会继续用3,4..etc\n\n这样，被3,4等等的情况，就都考虑进去了，就满足了对一个非素数的判断。\n\n\n>TODO: 有限状态机，在正则中对倍数的判断的使用。\n\n这块有点复杂，有空闲时间再来研究吧。\n\n## ES9 中正则表达式的更新\n\n### 支持分组命名\n\n使用 `?<name>` 放于 `(` 后面，对分组进行命名。\n例如：\n```js\nconst str = '2019-04-11'\nconst reg = /(?<year>....)-(?<month>..)-(?<day>..)/\nconst group = reg.exec(str).groups\nlet {year, month, day} = group\n```\n\n### 反向断言\n\n之前的版本js中的正则是不支持反向断言的，不过现在支持了。\n\n```js\nconst regex = /(?<=2019)-(..)-(..)/\n```\n\n只会匹配2019后面的月份和日期。\n*注意一点: 反向断言中不能使用捕获组* 就是这样使用是不行的： `(?<=\\1)(..)`\n\n### dotAll\n\n这个属性是针对于 `.` 匹配符的，是使用 dotAll 的情况下，`.` 实现了真正的 all 匹配，换行(\\n)，回车(\\r)， 行分隔，段分隔，都可以匹配。\n使用的方式，是使用新增的修饰符 /s\n\n其实完全的 all 匹配，还得加上 /u 修饰符，考虑Unicode的情况\n\n### Unicode 转义\n\n`var regex = new RegExp('\\u{61}', 'u');`\n\n## 反向非贪婪匹配\n\n一个这样的字符串\n```js\nconst str = \"<option value='2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'>大连用户组</option>\"\n```\n要找出 大连用户组 的标签的value是多少。\n本来觉得很简单，一个普通的正则就搞定了， `value\\='(.*?)'>大连用户组`.\n\n然而，匹配到的结果是 \n\n`2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'`\n\n我就蒙蔽了.我不是用了?了啊，应该是非贪婪的啊，怎么会这样呢。\n\n后面查阅了资料才发现，贪婪是对应的正向的匹配，对于一个正向的匹配没有第一次匹配到就放手的情况。。\n\n既然是反向的，我们的思维也反向一下吧。\n\n在前面加一个贪婪的匹配，那后面的不就是非贪婪的了嘛。\n\n`.*value\\='(.*?)'>大连用户组` 这样就bingo啦。\n","source":"_posts/正则表达式.md","raw":"---\ntitle: 正则表达式\ndate: 2019-03-12 10:45:22\ntags: 正则\n---\n\n> 关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.\n\n## JS正则中的捕获元和非捕获元\n字符 | 描述\n---- | ----\n(pattern) | 匹配 pattern ,并且获取\n(?:pattern) | 匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组\n(?=pattern) | 正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)\n(?!pattern) | 正向预查的否定版\n\n这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)\n\n>题外话,`toLocaleSting('en')`的方式也可以\n\n对比三种正则的获取情况\n```js\nvar reg1 = /\\d{1,3}(\\d{3})+$/\nvar reg2 = /\\d{1,3}(?:(\\d{3})+)/g\nvar reg3 = /\\d{1,3}(?=(\\d{3})+$)/g\nvar num = '1234567890'\nnum.replace(reg1, function (p, $1, $2) {\n    console.log('p: ', p); // 1234567890\n    console.log('$1: ', $1); // 890\n    console.log('$2: ', $2); // 0\n})\nnum.replace(reg2, function (p, $1, $2) {\n    console.log('p: ', p); // 1234567890\n    console.log('$1: ', $1); // 890\n    console.log('$2: ', $2); // 0\n})\nnum.replace(reg3, function (p, $1, $2) {\n    console.log('p: ', p);\n    console.log('$1: ', $1);\n    console.log('$2: ', $2);\n})\n```\n\n首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.\n\n然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.\n`reg2 = /(\\d{1,3})(?:(\\d{3})+?)/g`\n\n```js\nnum.replace(reg2, function (p, $1, $2) {\n    console.log('p: ', p); // 123456   7890\n    console.log('$1: ', $1); // 123     7\n    console.log('$2: ', $2); // 456   890\n})\n```\n这时候会进行两轮,但是因为`?:`非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.\n这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.\n\n第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.\n因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.\n同时P就是我们需要的数值的前面的部分,只需要 `return p + ','`就可以了\n\n### 实用情况\n\n#### 验证密码的复杂性和位数\n要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号\n`/(?=.{6,})(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&&*()_+])/`\n\n#### 验证邮箱\n\n`/^[0-9a-zA-Z\\-_]+@[0-9a-zA-Z\\-_]+[\\.0-9a-zA-Z\\-_]+$/`\n\n#### 匹配汉字\n\n`[\\u4e00-\\u9fa5]`\n\n`[\\u4E00-\\u9FA5\\uf900-\\ufa2d]` \n\n#### 重学js中的正则表达式\n\n> 之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。\n\n不要去看什么教程，走官网的 [介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n)\n\n1. 正则基本API补充\n\nRegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项\n\nRegExp.prototype.source 获取去掉正则两侧的 `/` 以及标志字符的字符串\n\n2. 正则的工具使用\n\n[链接](https://regex101.com/)\n这个网站分析的很不错，比一些什么可视化网站好用的多。\n\n3. 案例分析\n\n> 这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.\n> `/\\{\\{((?:.|\\n)+?)\\}\\}/` & `^<((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)`\n\n```js\nfunction isPrimeNum2(num){\n    return !/^.?$|^(..+?)\\1+$/.test(Array(num + 1).join('1'))\n}\n```\n看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下...\n\nupdate：2019-04-09\n\n> 自我解答来了..\n\n先把正则之外的部分解决一下，`Array(num + 1).join('1')` 返回的是由1组成的num个的字符串。 之所以需要加一，是因为这里用的是join，个数会被减一。\n\n然后才是重头戏，正则部分。\n\n正则分成了两部分，前面的 `^.?$` 是对是否有内容的一个检查，不做多余的说明。\n\n后面的部分才是对真正的判断，这里我们只能判断是否是非素数，然后求反。\n\n`^(..+?)\\1+$`, 是对非素数的判断。\n\n非素数，就是除了1之外还有其他因子的数。\n\n这里，我们就来构造这样的情况。\n\n`(..+?)` 这里是一个非贪婪的捕获，会先用 `(..)` 的情况来进行匹配，后面是`\\1+$`对第一次捕获分组的帅选，如果满足条件，容易发现其实在就满足了被2整除的条件，那么就不是质数了。如果2没有匹配到，因为是`..+`会继续用3,4..etc\n\n这样，被3,4等等的情况，就都考虑进去了，就满足了对一个非素数的判断。\n\n\n>TODO: 有限状态机，在正则中对倍数的判断的使用。\n\n这块有点复杂，有空闲时间再来研究吧。\n\n## ES9 中正则表达式的更新\n\n### 支持分组命名\n\n使用 `?<name>` 放于 `(` 后面，对分组进行命名。\n例如：\n```js\nconst str = '2019-04-11'\nconst reg = /(?<year>....)-(?<month>..)-(?<day>..)/\nconst group = reg.exec(str).groups\nlet {year, month, day} = group\n```\n\n### 反向断言\n\n之前的版本js中的正则是不支持反向断言的，不过现在支持了。\n\n```js\nconst regex = /(?<=2019)-(..)-(..)/\n```\n\n只会匹配2019后面的月份和日期。\n*注意一点: 反向断言中不能使用捕获组* 就是这样使用是不行的： `(?<=\\1)(..)`\n\n### dotAll\n\n这个属性是针对于 `.` 匹配符的，是使用 dotAll 的情况下，`.` 实现了真正的 all 匹配，换行(\\n)，回车(\\r)， 行分隔，段分隔，都可以匹配。\n使用的方式，是使用新增的修饰符 /s\n\n其实完全的 all 匹配，还得加上 /u 修饰符，考虑Unicode的情况\n\n### Unicode 转义\n\n`var regex = new RegExp('\\u{61}', 'u');`\n\n## 反向非贪婪匹配\n\n一个这样的字符串\n```js\nconst str = \"<option value='2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'>大连用户组</option>\"\n```\n要找出 大连用户组 的标签的value是多少。\n本来觉得很简单，一个普通的正则就搞定了， `value\\='(.*?)'>大连用户组`.\n\n然而，匹配到的结果是 \n\n`2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'`\n\n我就蒙蔽了.我不是用了?了啊，应该是非贪婪的啊，怎么会这样呢。\n\n后面查阅了资料才发现，贪婪是对应的正向的匹配，对于一个正向的匹配没有第一次匹配到就放手的情况。。\n\n既然是反向的，我们的思维也反向一下吧。\n\n在前面加一个贪婪的匹配，那后面的不就是非贪婪的了嘛。\n\n`.*value\\='(.*?)'>大连用户组` 这样就bingo啦。\n","slug":"正则表达式","published":1,"updated":"2019-04-21T02:21:22.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fja001j7dxq20mip7wv","content":"<blockquote>\n<p>关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.</p>\n</blockquote>\n<h2 id=\"JS正则中的捕获元和非捕获元\"><a href=\"#JS正则中的捕获元和非捕获元\" class=\"headerlink\" title=\"JS正则中的捕获元和非捕获元\"></a>JS正则中的捕获元和非捕获元</h2><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(pattern)</td>\n<td>匹配 pattern ,并且获取</td>\n</tr>\n<tr>\n<td>(?:pattern)</td>\n<td>匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组</td>\n</tr>\n<tr>\n<td>(?=pattern)</td>\n<td>正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)</td>\n</tr>\n<tr>\n<td>(?!pattern)</td>\n<td>正向预查的否定版</td>\n</tr>\n</tbody>\n</table>\n<p>这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)</p>\n<blockquote>\n<p>题外话,<code>toLocaleSting(&#39;en&#39;)</code>的方式也可以</p>\n</blockquote>\n<p>对比三种正则的获取情况<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg1 = <span class=\"regexp\">/\\d&#123;1,3&#125;(\\d&#123;3&#125;)+$/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2 = <span class=\"regexp\">/\\d&#123;1,3&#125;(?:(\\d&#123;3&#125;)+)/g</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg3 = <span class=\"regexp\">/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"string\">'1234567890'</span></span><br><span class=\"line\">num.replace(reg1, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 1234567890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">num.replace(reg2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 1234567890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">num.replace(reg3, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.</p>\n<p>然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.<br><code>reg2 = /(\\d{1,3})(?:(\\d{3})+?)/g</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num.replace(reg2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 123456   7890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 123     7</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 456   890</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候会进行两轮,但是因为<code>?:</code>非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.<br>这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.</p>\n<p>第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.<br>因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.<br>同时P就是我们需要的数值的前面的部分,只需要 <code>return p + &#39;,&#39;</code>就可以了</p>\n<h3 id=\"实用情况\"><a href=\"#实用情况\" class=\"headerlink\" title=\"实用情况\"></a>实用情况</h3><h4 id=\"验证密码的复杂性和位数\"><a href=\"#验证密码的复杂性和位数\" class=\"headerlink\" title=\"验证密码的复杂性和位数\"></a>验证密码的复杂性和位数</h4><p>要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号<br><code>/(?=.{6,})(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;&amp;*()_+])/</code></p>\n<h4 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h4><p><code>/^[0-9a-zA-Z\\-_]+@[0-9a-zA-Z\\-_]+[\\.0-9a-zA-Z\\-_]+$/</code></p>\n<h4 id=\"匹配汉字\"><a href=\"#匹配汉字\" class=\"headerlink\" title=\"匹配汉字\"></a>匹配汉字</h4><p><code>[\\u4e00-\\u9fa5]</code></p>\n<p><code>[\\u4E00-\\u9FA5\\uf900-\\ufa2d]</code> </p>\n<h4 id=\"重学js中的正则表达式\"><a href=\"#重学js中的正则表达式\" class=\"headerlink\" title=\"重学js中的正则表达式\"></a>重学js中的正则表达式</h4><blockquote>\n<p>之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。</p>\n</blockquote>\n<p>不要去看什么教程，走官网的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n\" target=\"_blank\" rel=\"noopener\">介绍</a></p>\n<ol>\n<li>正则基本API补充</li>\n</ol>\n<p>RegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项</p>\n<p>RegExp.prototype.source 获取去掉正则两侧的 <code>/</code> 以及标志字符的字符串</p>\n<ol start=\"2\">\n<li>正则的工具使用</li>\n</ol>\n<p><a href=\"https://regex101.com/\" target=\"_blank\" rel=\"noopener\">链接</a><br>这个网站分析的很不错，比一些什么可视化网站好用的多。</p>\n<ol start=\"3\">\n<li>案例分析</li>\n</ol>\n<blockquote>\n<p>这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.<br><code>/\\{\\{((?:.|\\n)+?)\\}\\}/</code> &amp; <code>^&lt;((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPrimeNum2</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"regexp\">/^.?$|^(..+?)\\1+$/</span>.test(<span class=\"built_in\">Array</span>(num + <span class=\"number\">1</span>).join(<span class=\"string\">'1'</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下…</p>\n<p>update：2019-04-09</p>\n<blockquote>\n<p>自我解答来了..</p>\n</blockquote>\n<p>先把正则之外的部分解决一下，<code>Array(num + 1).join(&#39;1&#39;)</code> 返回的是由1组成的num个的字符串。 之所以需要加一，是因为这里用的是join，个数会被减一。</p>\n<p>然后才是重头戏，正则部分。</p>\n<p>正则分成了两部分，前面的 <code>^.?$</code> 是对是否有内容的一个检查，不做多余的说明。</p>\n<p>后面的部分才是对真正的判断，这里我们只能判断是否是非素数，然后求反。</p>\n<p><code>^(..+?)\\1+$</code>, 是对非素数的判断。</p>\n<p>非素数，就是除了1之外还有其他因子的数。</p>\n<p>这里，我们就来构造这样的情况。</p>\n<p><code>(..+?)</code> 这里是一个非贪婪的捕获，会先用 <code>(..)</code> 的情况来进行匹配，后面是<code>\\1+$</code>对第一次捕获分组的帅选，如果满足条件，容易发现其实在就满足了被2整除的条件，那么就不是质数了。如果2没有匹配到，因为是<code>..+</code>会继续用3,4..etc</p>\n<p>这样，被3,4等等的情况，就都考虑进去了，就满足了对一个非素数的判断。</p>\n<blockquote>\n<p>TODO: 有限状态机，在正则中对倍数的判断的使用。</p>\n</blockquote>\n<p>这块有点复杂，有空闲时间再来研究吧。</p>\n<h2 id=\"ES9-中正则表达式的更新\"><a href=\"#ES9-中正则表达式的更新\" class=\"headerlink\" title=\"ES9 中正则表达式的更新\"></a>ES9 中正则表达式的更新</h2><h3 id=\"支持分组命名\"><a href=\"#支持分组命名\" class=\"headerlink\" title=\"支持分组命名\"></a>支持分组命名</h3><p>使用 <code>?&lt;name&gt;</code> 放于 <code>(</code> 后面，对分组进行命名。<br>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'2019-04-11'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> reg = <span class=\"regexp\">/(?&lt;year&gt;....)-(?&lt;month&gt;..)-(?&lt;day&gt;..)/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> group = reg.exec(str).groups</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;year, month, day&#125; = group</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"反向断言\"><a href=\"#反向断言\" class=\"headerlink\" title=\"反向断言\"></a>反向断言</h3><p>之前的版本js中的正则是不支持反向断言的，不过现在支持了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regex = <span class=\"regexp\">/(?&lt;=2019)-(..)-(..)/</span></span><br></pre></td></tr></table></figure>\n<p>只会匹配2019后面的月份和日期。<br><em>注意一点: 反向断言中不能使用捕获组</em> 就是这样使用是不行的： <code>(?&lt;=\\1)(..)</code></p>\n<h3 id=\"dotAll\"><a href=\"#dotAll\" class=\"headerlink\" title=\"dotAll\"></a>dotAll</h3><p>这个属性是针对于 <code>.</code> 匹配符的，是使用 dotAll 的情况下，<code>.</code> 实现了真正的 all 匹配，换行(\\n)，回车(\\r)， 行分隔，段分隔，都可以匹配。<br>使用的方式，是使用新增的修饰符 /s</p>\n<p>其实完全的 all 匹配，还得加上 /u 修饰符，考虑Unicode的情况</p>\n<h3 id=\"Unicode-转义\"><a href=\"#Unicode-转义\" class=\"headerlink\" title=\"Unicode 转义\"></a>Unicode 转义</h3><p><code>var regex = new RegExp(&#39;\\u{61}&#39;, &#39;u&#39;);</code></p>\n<h2 id=\"反向非贪婪匹配\"><a href=\"#反向非贪婪匹配\" class=\"headerlink\" title=\"反向非贪婪匹配\"></a>反向非贪婪匹配</h2><p>一个这样的字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">\"&lt;option value='2'&gt;default user group&lt;/option&gt;&lt;option value='8'&gt;默认用户组&lt;/option&gt;&lt;option value='11'&gt;OTT默认用户组&lt;/option&gt;&lt;option value='3418'&gt;黑名单用户组&lt;/option&gt;&lt;option value='3433'&gt;zhonggp测试用户组&lt;/option&gt;&lt;option value='14063'&gt;yangcongtest&lt;/option&gt;&lt;option value='14106'&gt;portal_test&lt;/option&gt;&lt;option value='14126'&gt;大连用户组&lt;/option&gt;\"</span></span><br></pre></td></tr></table></figure></p>\n<p>要找出 大连用户组 的标签的value是多少。<br>本来觉得很简单，一个普通的正则就搞定了， <code>value\\=&#39;(.*?)&#39;&gt;大连用户组</code>.</p>\n<p>然而，匹配到的结果是 </p>\n<p><code>2&#39;&gt;default user group&lt;/option&gt;&lt;option value=&#39;8&#39;&gt;默认用户组&lt;/option&gt;&lt;option value=&#39;11&#39;&gt;OTT默认用户组&lt;/option&gt;&lt;option value=&#39;3418&#39;&gt;黑名单用户组&lt;/option&gt;&lt;option value=&#39;3433&#39;&gt;zhonggp测试用户组&lt;/option&gt;&lt;option value=&#39;14063&#39;&gt;yangcongtest&lt;/option&gt;&lt;option value=&#39;14106&#39;&gt;portal_test&lt;/option&gt;&lt;option value=&#39;14126&#39;</code></p>\n<p>我就蒙蔽了.我不是用了?了啊，应该是非贪婪的啊，怎么会这样呢。</p>\n<p>后面查阅了资料才发现，贪婪是对应的正向的匹配，对于一个正向的匹配没有第一次匹配到就放手的情况。。</p>\n<p>既然是反向的，我们的思维也反向一下吧。</p>\n<p>在前面加一个贪婪的匹配，那后面的不就是非贪婪的了嘛。</p>\n<p><code>.*value\\=&#39;(.*?)&#39;&gt;大连用户组</code> 这样就bingo啦。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.</p>\n</blockquote>\n<h2 id=\"JS正则中的捕获元和非捕获元\"><a href=\"#JS正则中的捕获元和非捕获元\" class=\"headerlink\" title=\"JS正则中的捕获元和非捕获元\"></a>JS正则中的捕获元和非捕获元</h2><table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(pattern)</td>\n<td>匹配 pattern ,并且获取</td>\n</tr>\n<tr>\n<td>(?:pattern)</td>\n<td>匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组</td>\n</tr>\n<tr>\n<td>(?=pattern)</td>\n<td>正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)</td>\n</tr>\n<tr>\n<td>(?!pattern)</td>\n<td>正向预查的否定版</td>\n</tr>\n</tbody>\n</table>\n<p>这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)</p>\n<blockquote>\n<p>题外话,<code>toLocaleSting(&#39;en&#39;)</code>的方式也可以</p>\n</blockquote>\n<p>对比三种正则的获取情况<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg1 = <span class=\"regexp\">/\\d&#123;1,3&#125;(\\d&#123;3&#125;)+$/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg2 = <span class=\"regexp\">/\\d&#123;1,3&#125;(?:(\\d&#123;3&#125;)+)/g</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg3 = <span class=\"regexp\">/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"string\">'1234567890'</span></span><br><span class=\"line\">num.replace(reg1, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 1234567890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">num.replace(reg2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 1234567890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">num.replace(reg3, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.</p>\n<p>然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.<br><code>reg2 = /(\\d{1,3})(?:(\\d{3})+?)/g</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num.replace(reg2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p, $<span class=\"number\">1</span>, $<span class=\"number\">2</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'p: '</span>, p); <span class=\"comment\">// 123456   7890</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$1: '</span>, $<span class=\"number\">1</span>); <span class=\"comment\">// 123     7</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'$2: '</span>, $<span class=\"number\">2</span>); <span class=\"comment\">// 456   890</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候会进行两轮,但是因为<code>?:</code>非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.<br>这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.</p>\n<p>第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.<br>因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.<br>同时P就是我们需要的数值的前面的部分,只需要 <code>return p + &#39;,&#39;</code>就可以了</p>\n<h3 id=\"实用情况\"><a href=\"#实用情况\" class=\"headerlink\" title=\"实用情况\"></a>实用情况</h3><h4 id=\"验证密码的复杂性和位数\"><a href=\"#验证密码的复杂性和位数\" class=\"headerlink\" title=\"验证密码的复杂性和位数\"></a>验证密码的复杂性和位数</h4><p>要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号<br><code>/(?=.{6,})(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;&amp;*()_+])/</code></p>\n<h4 id=\"验证邮箱\"><a href=\"#验证邮箱\" class=\"headerlink\" title=\"验证邮箱\"></a>验证邮箱</h4><p><code>/^[0-9a-zA-Z\\-_]+@[0-9a-zA-Z\\-_]+[\\.0-9a-zA-Z\\-_]+$/</code></p>\n<h4 id=\"匹配汉字\"><a href=\"#匹配汉字\" class=\"headerlink\" title=\"匹配汉字\"></a>匹配汉字</h4><p><code>[\\u4e00-\\u9fa5]</code></p>\n<p><code>[\\u4E00-\\u9FA5\\uf900-\\ufa2d]</code> </p>\n<h4 id=\"重学js中的正则表达式\"><a href=\"#重学js中的正则表达式\" class=\"headerlink\" title=\"重学js中的正则表达式\"></a>重学js中的正则表达式</h4><blockquote>\n<p>之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。</p>\n</blockquote>\n<p>不要去看什么教程，走官网的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n\" target=\"_blank\" rel=\"noopener\">介绍</a></p>\n<ol>\n<li>正则基本API补充</li>\n</ol>\n<p>RegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项</p>\n<p>RegExp.prototype.source 获取去掉正则两侧的 <code>/</code> 以及标志字符的字符串</p>\n<ol start=\"2\">\n<li>正则的工具使用</li>\n</ol>\n<p><a href=\"https://regex101.com/\" target=\"_blank\" rel=\"noopener\">链接</a><br>这个网站分析的很不错，比一些什么可视化网站好用的多。</p>\n<ol start=\"3\">\n<li>案例分析</li>\n</ol>\n<blockquote>\n<p>这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.<br><code>/\\{\\{((?:.|\\n)+?)\\}\\}/</code> &amp; <code>^&lt;((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)</code></p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPrimeNum2</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"regexp\">/^.?$|^(..+?)\\1+$/</span>.test(<span class=\"built_in\">Array</span>(num + <span class=\"number\">1</span>).join(<span class=\"string\">'1'</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下…</p>\n<p>update：2019-04-09</p>\n<blockquote>\n<p>自我解答来了..</p>\n</blockquote>\n<p>先把正则之外的部分解决一下，<code>Array(num + 1).join(&#39;1&#39;)</code> 返回的是由1组成的num个的字符串。 之所以需要加一，是因为这里用的是join，个数会被减一。</p>\n<p>然后才是重头戏，正则部分。</p>\n<p>正则分成了两部分，前面的 <code>^.?$</code> 是对是否有内容的一个检查，不做多余的说明。</p>\n<p>后面的部分才是对真正的判断，这里我们只能判断是否是非素数，然后求反。</p>\n<p><code>^(..+?)\\1+$</code>, 是对非素数的判断。</p>\n<p>非素数，就是除了1之外还有其他因子的数。</p>\n<p>这里，我们就来构造这样的情况。</p>\n<p><code>(..+?)</code> 这里是一个非贪婪的捕获，会先用 <code>(..)</code> 的情况来进行匹配，后面是<code>\\1+$</code>对第一次捕获分组的帅选，如果满足条件，容易发现其实在就满足了被2整除的条件，那么就不是质数了。如果2没有匹配到，因为是<code>..+</code>会继续用3,4..etc</p>\n<p>这样，被3,4等等的情况，就都考虑进去了，就满足了对一个非素数的判断。</p>\n<blockquote>\n<p>TODO: 有限状态机，在正则中对倍数的判断的使用。</p>\n</blockquote>\n<p>这块有点复杂，有空闲时间再来研究吧。</p>\n<h2 id=\"ES9-中正则表达式的更新\"><a href=\"#ES9-中正则表达式的更新\" class=\"headerlink\" title=\"ES9 中正则表达式的更新\"></a>ES9 中正则表达式的更新</h2><h3 id=\"支持分组命名\"><a href=\"#支持分组命名\" class=\"headerlink\" title=\"支持分组命名\"></a>支持分组命名</h3><p>使用 <code>?&lt;name&gt;</code> 放于 <code>(</code> 后面，对分组进行命名。<br>例如：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">'2019-04-11'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> reg = <span class=\"regexp\">/(?&lt;year&gt;....)-(?&lt;month&gt;..)-(?&lt;day&gt;..)/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> group = reg.exec(str).groups</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;year, month, day&#125; = group</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"反向断言\"><a href=\"#反向断言\" class=\"headerlink\" title=\"反向断言\"></a>反向断言</h3><p>之前的版本js中的正则是不支持反向断言的，不过现在支持了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regex = <span class=\"regexp\">/(?&lt;=2019)-(..)-(..)/</span></span><br></pre></td></tr></table></figure>\n<p>只会匹配2019后面的月份和日期。<br><em>注意一点: 反向断言中不能使用捕获组</em> 就是这样使用是不行的： <code>(?&lt;=\\1)(..)</code></p>\n<h3 id=\"dotAll\"><a href=\"#dotAll\" class=\"headerlink\" title=\"dotAll\"></a>dotAll</h3><p>这个属性是针对于 <code>.</code> 匹配符的，是使用 dotAll 的情况下，<code>.</code> 实现了真正的 all 匹配，换行(\\n)，回车(\\r)， 行分隔，段分隔，都可以匹配。<br>使用的方式，是使用新增的修饰符 /s</p>\n<p>其实完全的 all 匹配，还得加上 /u 修饰符，考虑Unicode的情况</p>\n<h3 id=\"Unicode-转义\"><a href=\"#Unicode-转义\" class=\"headerlink\" title=\"Unicode 转义\"></a>Unicode 转义</h3><p><code>var regex = new RegExp(&#39;\\u{61}&#39;, &#39;u&#39;);</code></p>\n<h2 id=\"反向非贪婪匹配\"><a href=\"#反向非贪婪匹配\" class=\"headerlink\" title=\"反向非贪婪匹配\"></a>反向非贪婪匹配</h2><p>一个这样的字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">\"&lt;option value='2'&gt;default user group&lt;/option&gt;&lt;option value='8'&gt;默认用户组&lt;/option&gt;&lt;option value='11'&gt;OTT默认用户组&lt;/option&gt;&lt;option value='3418'&gt;黑名单用户组&lt;/option&gt;&lt;option value='3433'&gt;zhonggp测试用户组&lt;/option&gt;&lt;option value='14063'&gt;yangcongtest&lt;/option&gt;&lt;option value='14106'&gt;portal_test&lt;/option&gt;&lt;option value='14126'&gt;大连用户组&lt;/option&gt;\"</span></span><br></pre></td></tr></table></figure></p>\n<p>要找出 大连用户组 的标签的value是多少。<br>本来觉得很简单，一个普通的正则就搞定了， <code>value\\=&#39;(.*?)&#39;&gt;大连用户组</code>.</p>\n<p>然而，匹配到的结果是 </p>\n<p><code>2&#39;&gt;default user group&lt;/option&gt;&lt;option value=&#39;8&#39;&gt;默认用户组&lt;/option&gt;&lt;option value=&#39;11&#39;&gt;OTT默认用户组&lt;/option&gt;&lt;option value=&#39;3418&#39;&gt;黑名单用户组&lt;/option&gt;&lt;option value=&#39;3433&#39;&gt;zhonggp测试用户组&lt;/option&gt;&lt;option value=&#39;14063&#39;&gt;yangcongtest&lt;/option&gt;&lt;option value=&#39;14106&#39;&gt;portal_test&lt;/option&gt;&lt;option value=&#39;14126&#39;</code></p>\n<p>我就蒙蔽了.我不是用了?了啊，应该是非贪婪的啊，怎么会这样呢。</p>\n<p>后面查阅了资料才发现，贪婪是对应的正向的匹配，对于一个正向的匹配没有第一次匹配到就放手的情况。。</p>\n<p>既然是反向的，我们的思维也反向一下吧。</p>\n<p>在前面加一个贪婪的匹配，那后面的不就是非贪婪的了嘛。</p>\n<p><code>.*value\\=&#39;(.*?)&#39;&gt;大连用户组</code> 这样就bingo啦。</p>\n"},{"title":"疯狂的函数","date":"2019-02-22T03:10:09.000Z","_content":"\n>一道函数执行的问题\n\n```js\nfunction Foo (){\n    getName = function () {console.log(1)}\n}\n\nFoo.getName = function () {console.log(2)}\n\nFoo.prototype.getName = function (){console.log(3)}\n\nvar getName = function () {console.log(4)}\n\nfunction getName () {console.log(5)}\n\nFoo.getName(); //2\ngetName(); //4\nFoo().getName();//1\ngetName();//1\nnew Foo.getName();// 运算顺序 Foo.getName()先执行,再是new 所以 2\nnew Foo().getName(); // \nnew new Foo().getName(); // \n\n```\n\n由于变量提升实际上的声明其实会是这个样子的:\n```js\nvar getName\n\nfunction Foo (){\n    getName = function () {console.log(1)}\n}\n\nFoo.getName = function () {console.log(2)}\n\nFoo.prototype.getName = function (){console.log(3}\n\nfunction getName () {console.log(5)}\n\ngetName = function () {console.log(4)}\n\n```\n所以getName在定义完之后会是 `function () {console.log(4)}`,(最后一次的定义会覆盖之前的).\n在执行完Foo()之后,getName 函数会被里面的的赋值语句 getName 污染\n如果是\n`function Foo (){\n    var getName = function () {console.log(1)}\n}`\n才不会被污染.\n所以在Foo()之后, getName 都成了 console.log(1)\n\n接下来的问题就是运算符优先级的问题\n\n> 这里在做的时候有一个误区,同等优先级就从左往右计算就好了..[优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table),同等级是没有更优先的了.\n\n第七问中的new是有参数列表的,优先级和. [] 的相同,所以都是从左往右执行\n先会执行new Foo() ,在构造函数的方法先在原型链上查询有没有这个方法,就定义到了原型 prototype 上的getName方法\n","source":"_posts/疯狂的函数.md","raw":"---\ntitle: 疯狂的函数\ndate: 2019-02-22 11:10:09\ntags: js\n---\n\n>一道函数执行的问题\n\n```js\nfunction Foo (){\n    getName = function () {console.log(1)}\n}\n\nFoo.getName = function () {console.log(2)}\n\nFoo.prototype.getName = function (){console.log(3)}\n\nvar getName = function () {console.log(4)}\n\nfunction getName () {console.log(5)}\n\nFoo.getName(); //2\ngetName(); //4\nFoo().getName();//1\ngetName();//1\nnew Foo.getName();// 运算顺序 Foo.getName()先执行,再是new 所以 2\nnew Foo().getName(); // \nnew new Foo().getName(); // \n\n```\n\n由于变量提升实际上的声明其实会是这个样子的:\n```js\nvar getName\n\nfunction Foo (){\n    getName = function () {console.log(1)}\n}\n\nFoo.getName = function () {console.log(2)}\n\nFoo.prototype.getName = function (){console.log(3}\n\nfunction getName () {console.log(5)}\n\ngetName = function () {console.log(4)}\n\n```\n所以getName在定义完之后会是 `function () {console.log(4)}`,(最后一次的定义会覆盖之前的).\n在执行完Foo()之后,getName 函数会被里面的的赋值语句 getName 污染\n如果是\n`function Foo (){\n    var getName = function () {console.log(1)}\n}`\n才不会被污染.\n所以在Foo()之后, getName 都成了 console.log(1)\n\n接下来的问题就是运算符优先级的问题\n\n> 这里在做的时候有一个误区,同等优先级就从左往右计算就好了..[优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table),同等级是没有更优先的了.\n\n第七问中的new是有参数列表的,优先级和. [] 的相同,所以都是从左往右执行\n先会执行new Foo() ,在构造函数的方法先在原型链上查询有没有这个方法,就定义到了原型 prototype 上的getName方法\n","slug":"疯狂的函数","published":1,"updated":"2019-03-31T02:31:52.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fjb001l7dxqlhu3y2ts","content":"<blockquote>\n<p>一道函数执行的问题</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName(); <span class=\"comment\">//2</span></span><br><span class=\"line\">getName(); <span class=\"comment\">//4</span></span><br><span class=\"line\">Foo().getName();<span class=\"comment\">//1</span></span><br><span class=\"line\">getName();<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo.getName();<span class=\"comment\">// 运算顺序 Foo.getName()先执行,再是new 所以 2</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo().getName(); <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"keyword\">new</span> Foo().getName(); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>由于变量提升实际上的声明其实会是这个样子的:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getName</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以getName在定义完之后会是 <code>function () {console.log(4)}</code>,(最后一次的定义会覆盖之前的).<br>在执行完Foo()之后,getName 函数会被里面的的赋值语句 getName 污染<br>如果是<br><code>function Foo (){\n    var getName = function () {console.log(1)}\n}</code><br>才不会被污染.<br>所以在Foo()之后, getName 都成了 console.log(1)</p>\n<p>接下来的问题就是运算符优先级的问题</p>\n<blockquote>\n<p>这里在做的时候有一个误区,同等优先级就从左往右计算就好了..<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table\" target=\"_blank\" rel=\"noopener\">优先级</a>,同等级是没有更优先的了.</p>\n</blockquote>\n<p>第七问中的new是有参数列表的,优先级和. [] 的相同,所以都是从左往右执行<br>先会执行new Foo() ,在构造函数的方法先在原型链上查询有没有这个方法,就定义到了原型 prototype 上的getName方法</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一道函数执行的问题</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName(); <span class=\"comment\">//2</span></span><br><span class=\"line\">getName(); <span class=\"comment\">//4</span></span><br><span class=\"line\">Foo().getName();<span class=\"comment\">//1</span></span><br><span class=\"line\">getName();<span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo.getName();<span class=\"comment\">// 运算顺序 Foo.getName()先执行,再是new 所以 2</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo().getName(); <span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"keyword\">new</span> Foo().getName(); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>由于变量提升实际上的声明其实会是这个样子的:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getName</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所以getName在定义完之后会是 <code>function () {console.log(4)}</code>,(最后一次的定义会覆盖之前的).<br>在执行完Foo()之后,getName 函数会被里面的的赋值语句 getName 污染<br>如果是<br><code>function Foo (){\n    var getName = function () {console.log(1)}\n}</code><br>才不会被污染.<br>所以在Foo()之后, getName 都成了 console.log(1)</p>\n<p>接下来的问题就是运算符优先级的问题</p>\n<blockquote>\n<p>这里在做的时候有一个误区,同等优先级就从左往右计算就好了..<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table\" target=\"_blank\" rel=\"noopener\">优先级</a>,同等级是没有更优先的了.</p>\n</blockquote>\n<p>第七问中的new是有参数列表的,优先级和. [] 的相同,所以都是从左往右执行<br>先会执行new Foo() ,在构造函数的方法先在原型链上查询有没有这个方法,就定义到了原型 prototype 上的getName方法</p>\n"},{"title":"理解Promise","date":"2019-03-18T01:03:13.000Z","_content":"> 看到很多对博客的探讨的说法，认为博客应该是对网上没有的知识技能的补充。我不能认同，每个人记录的目的是不一样的，我就是为了记录自己学习的过程，很多文章，现在看来对其他人的作用可能很小，甚至没有什么用。但是这是我记录，加深印象的过程。暂时地步还没有到达补充的看法。\n\n### 从promise的实现说起\n\n既然我们想实现一个promise，至少要明白promise是什么。\n一句话解释promise，对异步事件的最终状态的描述。\n\n一个简单的，可以代表实现历程的promise：\n\n```js\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nconst isFunction = fn => typeof fn === 'function'\n\nclass MyPromise {\n    constructor(handle) {\n        if (!isFunction(handle)) {\n            throw new Error('must be a function')\n        }\n        // 初始化状态\n        this._status = PENDING\n        // 初始化返回值\n        this._value = undefined\n        // 执行队列\n        this._fulfilledQueues = []\n        this._rejectedQueues = []\n\n        try {\n            handle(this._resolved.bind(this), this._rejected.bind(this))\n        } catch (error) {\n            this._rejected(error)\n        }\n    }\n    _resolved(val) {\n        if (this._status !== PENDING) return\n        // 还需要处理如果resolve 接受的还是 promise的情况， 接受就是promise的话， 状态会由接受的promise的状态来决定\n        // 上述的解决方法，和then中的设计思路是一样的\n        const run = (value) => {\n            const fulfilled = (value) => {\n                let cb\n                while (cb = this._fulfilledQueues.shift()) {\n                    cb(value)\n                }\n            }\n            const rejected = (err) => {\n                let cb\n                while (cb = this._rejectedQueues.shift()) {\n                    cb(err)\n                }\n            }\n            if (val instanceof MyPromise) {\n                val.then(value => {\n                    this._status = FULFILLED\n                    this._value = value\n                    fulfilled(value)\n                }, err => {\n                    this._status = REJECTED\n                    this._value = err\n                    rejected(err)\n                })\n            } else {\n                this._status = FULFILLED\n                this._value = value\n                fulfilled(value)\n            }\n\n        }\n        setTimeout(() => run(val), 0)\n    }\n    _rejected(err) {\n        if (this._status !== PENDING) return\n        const run = (error) => {\n            this._status = REJECTED\n            this._value = error\n            let cb\n            while (cb = this._rejectedQueues.shift()) {\n                cb(error)\n            }\n        }\n        setTimeout(() => run(err), 0)\n    }\n    then(onFulfilled, onRejected) {\n        const { _status, _value } = this\n        return new MyPromise((onFulfilledNext, onRejectedNext) => {\n            const fulfilled = (val) => {\n                if (!isFunction(onFulfilled)) { //值穿透 ，如果 then中的值不是函数，会忽略这个值，将上一个的value继续传下去\n                    onFulfilledNext(val)\n                }\n                let res = onFulfilled(val)\n                if (res instanceof MyPromise) { // 如果返回的还是一个promise的话，需要等待这个promise的结束，所以把 handle 函数直接then 在其后面\n                    res.then(onFulfilledNext, onRejectedNext)\n                } else {\n                    onFulfilledNext(res) // 一般的情况\n                }\n            }\n            // 失败的执行函数\n            const rejected = (err) => {\n                if (!isFunction(onRejected)) {\n                    onRejectedNext(err)\n                }\n                console.trace()\n                let res = onRejected(err)\n                if (res instanceof MyPromise) {\n                    res.then(onFulfilledNext, onRejectedNext)\n                } else {\n                    onFulfilledNext(res) //  在失败队列中，没有错误的执行完了，进行的还是下一个的成功回调\n                }\n            }\n            switch (_status) {\n                case PENDING:\n                    this._fulfilledQueues.push(fulfilled)\n                    this._rejectedQueues.push(rejected)\n                    break\n                case FULFILLED:\n                    fulfilled(_value)\n                    break\n                case REJECTED:\n                    rejected(_value)\n                    break\n            }\n        })\n    }\n    catch(fn) {\n        return this.then(undefined, fn)\n    }\n    static resolve(value) { // resolve reject 返回的是一个具有成功处理函数（失败处理函数）的promise\n        if (value instanceof MyPromise) return value\n        return new MyPromise(resolve => resolve(value))\n    }\n    static rejected(val) {\n        return new MyPromise((resolve, rejected) => rejected(val))\n    }\n    static all(lists) {\n        return new MyPromise((resolve, rejected) => {\n            let result = []\n            for (let p of lists) {\n                MyPromise.resolve(p).then(val => {\n                    result.push(val)\n                    console.log('val: ', val);\n                    if (result.length === lists.length) {\n                        resolve(result)\n                    }\n                }, err => {\n                    rejected(err)\n                })\n            }\n        })\n    }\n    static race(lists) {\n        return new MyPromise((resolve, rejected) => {\n            for (let p in lists) {\n                p.then(val => {\n                    resolve(val)\n                }, err => {\n                    rejected(err)\n                })\n            }\n        })\n    }\n}\n```","source":"_posts/理解Promise.md","raw":"---\ntitle: 理解Promise\ndate: 2019-03-18 09:03:13\ntags: js\n---\n> 看到很多对博客的探讨的说法，认为博客应该是对网上没有的知识技能的补充。我不能认同，每个人记录的目的是不一样的，我就是为了记录自己学习的过程，很多文章，现在看来对其他人的作用可能很小，甚至没有什么用。但是这是我记录，加深印象的过程。暂时地步还没有到达补充的看法。\n\n### 从promise的实现说起\n\n既然我们想实现一个promise，至少要明白promise是什么。\n一句话解释promise，对异步事件的最终状态的描述。\n\n一个简单的，可以代表实现历程的promise：\n\n```js\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nconst isFunction = fn => typeof fn === 'function'\n\nclass MyPromise {\n    constructor(handle) {\n        if (!isFunction(handle)) {\n            throw new Error('must be a function')\n        }\n        // 初始化状态\n        this._status = PENDING\n        // 初始化返回值\n        this._value = undefined\n        // 执行队列\n        this._fulfilledQueues = []\n        this._rejectedQueues = []\n\n        try {\n            handle(this._resolved.bind(this), this._rejected.bind(this))\n        } catch (error) {\n            this._rejected(error)\n        }\n    }\n    _resolved(val) {\n        if (this._status !== PENDING) return\n        // 还需要处理如果resolve 接受的还是 promise的情况， 接受就是promise的话， 状态会由接受的promise的状态来决定\n        // 上述的解决方法，和then中的设计思路是一样的\n        const run = (value) => {\n            const fulfilled = (value) => {\n                let cb\n                while (cb = this._fulfilledQueues.shift()) {\n                    cb(value)\n                }\n            }\n            const rejected = (err) => {\n                let cb\n                while (cb = this._rejectedQueues.shift()) {\n                    cb(err)\n                }\n            }\n            if (val instanceof MyPromise) {\n                val.then(value => {\n                    this._status = FULFILLED\n                    this._value = value\n                    fulfilled(value)\n                }, err => {\n                    this._status = REJECTED\n                    this._value = err\n                    rejected(err)\n                })\n            } else {\n                this._status = FULFILLED\n                this._value = value\n                fulfilled(value)\n            }\n\n        }\n        setTimeout(() => run(val), 0)\n    }\n    _rejected(err) {\n        if (this._status !== PENDING) return\n        const run = (error) => {\n            this._status = REJECTED\n            this._value = error\n            let cb\n            while (cb = this._rejectedQueues.shift()) {\n                cb(error)\n            }\n        }\n        setTimeout(() => run(err), 0)\n    }\n    then(onFulfilled, onRejected) {\n        const { _status, _value } = this\n        return new MyPromise((onFulfilledNext, onRejectedNext) => {\n            const fulfilled = (val) => {\n                if (!isFunction(onFulfilled)) { //值穿透 ，如果 then中的值不是函数，会忽略这个值，将上一个的value继续传下去\n                    onFulfilledNext(val)\n                }\n                let res = onFulfilled(val)\n                if (res instanceof MyPromise) { // 如果返回的还是一个promise的话，需要等待这个promise的结束，所以把 handle 函数直接then 在其后面\n                    res.then(onFulfilledNext, onRejectedNext)\n                } else {\n                    onFulfilledNext(res) // 一般的情况\n                }\n            }\n            // 失败的执行函数\n            const rejected = (err) => {\n                if (!isFunction(onRejected)) {\n                    onRejectedNext(err)\n                }\n                console.trace()\n                let res = onRejected(err)\n                if (res instanceof MyPromise) {\n                    res.then(onFulfilledNext, onRejectedNext)\n                } else {\n                    onFulfilledNext(res) //  在失败队列中，没有错误的执行完了，进行的还是下一个的成功回调\n                }\n            }\n            switch (_status) {\n                case PENDING:\n                    this._fulfilledQueues.push(fulfilled)\n                    this._rejectedQueues.push(rejected)\n                    break\n                case FULFILLED:\n                    fulfilled(_value)\n                    break\n                case REJECTED:\n                    rejected(_value)\n                    break\n            }\n        })\n    }\n    catch(fn) {\n        return this.then(undefined, fn)\n    }\n    static resolve(value) { // resolve reject 返回的是一个具有成功处理函数（失败处理函数）的promise\n        if (value instanceof MyPromise) return value\n        return new MyPromise(resolve => resolve(value))\n    }\n    static rejected(val) {\n        return new MyPromise((resolve, rejected) => rejected(val))\n    }\n    static all(lists) {\n        return new MyPromise((resolve, rejected) => {\n            let result = []\n            for (let p of lists) {\n                MyPromise.resolve(p).then(val => {\n                    result.push(val)\n                    console.log('val: ', val);\n                    if (result.length === lists.length) {\n                        resolve(result)\n                    }\n                }, err => {\n                    rejected(err)\n                })\n            }\n        })\n    }\n    static race(lists) {\n        return new MyPromise((resolve, rejected) => {\n            for (let p in lists) {\n                p.then(val => {\n                    resolve(val)\n                }, err => {\n                    rejected(err)\n                })\n            }\n        })\n    }\n}\n```","slug":"理解Promise","published":1,"updated":"2019-03-31T02:31:52.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fje001o7dxqs6fwx8lb","content":"<blockquote>\n<p>看到很多对博客的探讨的说法，认为博客应该是对网上没有的知识技能的补充。我不能认同，每个人记录的目的是不一样的，我就是为了记录自己学习的过程，很多文章，现在看来对其他人的作用可能很小，甚至没有什么用。但是这是我记录，加深印象的过程。暂时地步还没有到达补充的看法。</p>\n</blockquote>\n<h3 id=\"从promise的实现说起\"><a href=\"#从promise的实现说起\" class=\"headerlink\" title=\"从promise的实现说起\"></a>从promise的实现说起</h3><p>既然我们想实现一个promise，至少要明白promise是什么。<br>一句话解释promise，对异步事件的最终状态的描述。</p>\n<p>一个简单的，可以代表实现历程的promise：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'FULFILLED'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isFunction = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"keyword\">typeof</span> fn === <span class=\"string\">'function'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(handle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(handle)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'must be a function'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">        <span class=\"comment\">// 初始化返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行队列</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._fulfilledQueues = []</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._rejectedQueues = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            handle(<span class=\"keyword\">this</span>._resolved.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._rejected.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._rejected(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _resolved(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"comment\">// 还需要处理如果resolve 接受的还是 promise的情况， 接受就是promise的话， 状态会由接受的promise的状态来决定</span></span><br><span class=\"line\">        <span class=\"comment\">// 上述的解决方法，和then中的设计思路是一样的</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> run = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> fulfilled = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class=\"line\">                    cb(value)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> rejected = <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">                    cb(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                val.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._value = value</span><br><span class=\"line\">                    fulfilled(value)</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._value = value</span><br><span class=\"line\">                fulfilled(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(val), <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _rejected(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> run = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._value = error</span><br><span class=\"line\">            <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">                cb(error)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(err), <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; _status, _value &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> fulfilled = <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!isFunction(onFulfilled)) &#123; <span class=\"comment\">//值穿透 ，如果 then中的值不是函数，会忽略这个值，将上一个的value继续传下去</span></span><br><span class=\"line\">                    onFulfilledNext(val)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> res = onFulfilled(val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123; <span class=\"comment\">// 如果返回的还是一个promise的话，需要等待这个promise的结束，所以把 handle 函数直接then 在其后面</span></span><br><span class=\"line\">                    res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onFulfilledNext(res) <span class=\"comment\">// 一般的情况</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 失败的执行函数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> rejected = <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!isFunction(onRejected)) &#123;</span><br><span class=\"line\">                    onRejectedNext(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.trace()</span><br><span class=\"line\">                <span class=\"keyword\">let</span> res = onRejected(err)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                    res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onFulfilledNext(res) <span class=\"comment\">//  在失败队列中，没有错误的执行完了，进行的还是下一个的成功回调</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._rejectedQueues.push(rejected)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">                    fulfilled(_value)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">                    rejected(_value)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(fn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> resolve(value) &#123; <span class=\"comment\">// resolve reject 返回的是一个具有成功处理函数（失败处理函数）的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(value))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> rejected(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> rejected(val))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> all(lists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> p <span class=\"keyword\">of</span> lists) &#123;</span><br><span class=\"line\">                MyPromise.resolve(p).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    result.push(val)</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'val: '</span>, val);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (result.length === lists.length) &#123;</span><br><span class=\"line\">                        resolve(result)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> race(lists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> p <span class=\"keyword\">in</span> lists) &#123;</span><br><span class=\"line\">                p.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve(val)</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>看到很多对博客的探讨的说法，认为博客应该是对网上没有的知识技能的补充。我不能认同，每个人记录的目的是不一样的，我就是为了记录自己学习的过程，很多文章，现在看来对其他人的作用可能很小，甚至没有什么用。但是这是我记录，加深印象的过程。暂时地步还没有到达补充的看法。</p>\n</blockquote>\n<h3 id=\"从promise的实现说起\"><a href=\"#从promise的实现说起\" class=\"headerlink\" title=\"从promise的实现说起\"></a>从promise的实现说起</h3><p>既然我们想实现一个promise，至少要明白promise是什么。<br>一句话解释promise，对异步事件的最终状态的描述。</p>\n<p>一个简单的，可以代表实现历程的promise：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">'PENDING'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FULFILLED = <span class=\"string\">'FULFILLED'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">'REJECTED'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isFunction = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"keyword\">typeof</span> fn === <span class=\"string\">'function'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPromise</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(handle) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isFunction(handle)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'must be a function'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._status = PENDING</span><br><span class=\"line\">        <span class=\"comment\">// 初始化返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._value = <span class=\"literal\">undefined</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行队列</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>._fulfilledQueues = []</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._rejectedQueues = []</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            handle(<span class=\"keyword\">this</span>._resolved.bind(<span class=\"keyword\">this</span>), <span class=\"keyword\">this</span>._rejected.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._rejected(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _resolved(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"comment\">// 还需要处理如果resolve 接受的还是 promise的情况， 接受就是promise的话， 状态会由接受的promise的状态来决定</span></span><br><span class=\"line\">        <span class=\"comment\">// 上述的解决方法，和then中的设计思路是一样的</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> run = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> fulfilled = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class=\"line\">                    cb(value)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> rejected = <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">                    cb(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                val.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._value = value</span><br><span class=\"line\">                    fulfilled(value)</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._value = err</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._status = FULFILLED</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._value = value</span><br><span class=\"line\">                fulfilled(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(val), <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _rejected(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._status !== PENDING) <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> run = <span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._status = REJECTED</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._value = error</span><br><span class=\"line\">            <span class=\"keyword\">let</span> cb</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cb = <span class=\"keyword\">this</span>._rejectedQueues.shift()) &#123;</span><br><span class=\"line\">                cb(error)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> run(err), <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    then(onFulfilled, onRejected) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; _status, _value &#125; = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> fulfilled = <span class=\"function\">(<span class=\"params\">val</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!isFunction(onFulfilled)) &#123; <span class=\"comment\">//值穿透 ，如果 then中的值不是函数，会忽略这个值，将上一个的value继续传下去</span></span><br><span class=\"line\">                    onFulfilledNext(val)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> res = onFulfilled(val)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123; <span class=\"comment\">// 如果返回的还是一个promise的话，需要等待这个promise的结束，所以把 handle 函数直接then 在其后面</span></span><br><span class=\"line\">                    res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onFulfilledNext(res) <span class=\"comment\">// 一般的情况</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 失败的执行函数</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> rejected = <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!isFunction(onRejected)) &#123;</span><br><span class=\"line\">                    onRejectedNext(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.trace()</span><br><span class=\"line\">                <span class=\"keyword\">let</span> res = onRejected(err)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (res <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                    res.then(onFulfilledNext, onRejectedNext)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onFulfilledNext(res) <span class=\"comment\">//  在失败队列中，没有错误的执行完了，进行的还是下一个的成功回调</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (_status) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> PENDING:</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>._rejectedQueues.push(rejected)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> FULFILLED:</span><br><span class=\"line\">                    fulfilled(_value)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> REJECTED:</span><br><span class=\"line\">                    rejected(_value)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(fn) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">undefined</span>, fn)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> resolve(value) &#123; <span class=\"comment\">// resolve reject 返回的是一个具有成功处理函数（失败处理函数）的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> resolve(value))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> rejected(val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> rejected(val))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> all(lists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> result = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> p <span class=\"keyword\">of</span> lists) &#123;</span><br><span class=\"line\">                MyPromise.resolve(p).then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    result.push(val)</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'val: '</span>, val);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (result.length === lists.length) &#123;</span><br><span class=\"line\">                        resolve(result)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> race(lists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\">(<span class=\"params\">resolve, rejected</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> p <span class=\"keyword\">in</span> lists) &#123;</span><br><span class=\"line\">                p.then(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    resolve(val)</span><br><span class=\"line\">                &#125;, err =&gt; &#123;</span><br><span class=\"line\">                    rejected(err)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"置顶文章","date":"2019-03-07T07:33:56.000Z","top":10000,"_content":"\n# 博客现在的规划\n\n- [ ] js函数式编程学习\n- [ ] Lodash-分析学习\n> 上面第一个进行的有点困难现在.\n\n2019-03-14: \n1. Promise模仿,手写了一遍实现\n2. 准备完整的搞一遍 js中的 this的问题\n\n2019-03-18:\n1. http 缓存知识复习\n2. promise 再现\n\n2019-03-29\n> 首先，上述的学习任务基本完成，当然规划那两个是长期任务。\n\n去年七月份就刷了这篇(博客)[http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。\n\n浏览器的机制，到如何打开一个tab页。（涉及到进程和线程）\n\n其中有很多后台的和服务器端的内容，暂时不作为我的学习内容，在这里只对其中出现的前端的内容，而我都不是很了解的内容做一个to-learn-list。\n\n简单层与复合层，都是什么，这个完全不了解。(已经做了总结)\n(看这个)[https://segmentfault.com/a/1190000012925872#articleHeader16]\n\n没事多看看这篇博客，对其中不太了解的知识体系做一个梳理。","source":"_posts/置顶文章.md","raw":"---\ntitle: 置顶文章\ndate: 2019-03-07 15:33:56\ntags:\ntop: 10000\n---\n\n# 博客现在的规划\n\n- [ ] js函数式编程学习\n- [ ] Lodash-分析学习\n> 上面第一个进行的有点困难现在.\n\n2019-03-14: \n1. Promise模仿,手写了一遍实现\n2. 准备完整的搞一遍 js中的 this的问题\n\n2019-03-18:\n1. http 缓存知识复习\n2. promise 再现\n\n2019-03-29\n> 首先，上述的学习任务基本完成，当然规划那两个是长期任务。\n\n去年七月份就刷了这篇(博客)[http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。\n\n浏览器的机制，到如何打开一个tab页。（涉及到进程和线程）\n\n其中有很多后台的和服务器端的内容，暂时不作为我的学习内容，在这里只对其中出现的前端的内容，而我都不是很了解的内容做一个to-learn-list。\n\n简单层与复合层，都是什么，这个完全不了解。(已经做了总结)\n(看这个)[https://segmentfault.com/a/1190000012925872#articleHeader16]\n\n没事多看看这篇博客，对其中不太了解的知识体系做一个梳理。","slug":"置顶文章","published":1,"updated":"2019-03-31T02:31:52.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fjh001q7dxqkqorswqb","content":"<h1 id=\"博客现在的规划\"><a href=\"#博客现在的规划\" class=\"headerlink\" title=\"博客现在的规划\"></a>博客现在的规划</h1><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> js函数式编程学习</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> Lodash-分析学习<blockquote>\n<p>上面第一个进行的有点困难现在.</p>\n</blockquote>\n</li>\n</ul>\n<p>2019-03-14: </p>\n<ol>\n<li>Promise模仿,手写了一遍实现</li>\n<li>准备完整的搞一遍 js中的 this的问题</li>\n</ol>\n<p>2019-03-18:</p>\n<ol>\n<li>http 缓存知识复习</li>\n<li>promise 再现</li>\n</ol>\n<p>2019-03-29</p>\n<blockquote>\n<p>首先，上述的学习任务基本完成，当然规划那两个是长期任务。</p>\n</blockquote>\n<p>去年七月份就刷了这篇(博客)[<a href=\"http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。</a></p>\n<p>浏览器的机制，到如何打开一个tab页。（涉及到进程和线程）</p>\n<p>其中有很多后台的和服务器端的内容，暂时不作为我的学习内容，在这里只对其中出现的前端的内容，而我都不是很了解的内容做一个to-learn-list。</p>\n<p>简单层与复合层，都是什么，这个完全不了解。(已经做了总结)<br>(看这个)[<a href=\"https://segmentfault.com/a/1190000012925872#articleHeader16]\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012925872#articleHeader16]</a></p>\n<p>没事多看看这篇博客，对其中不太了解的知识体系做一个梳理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"博客现在的规划\"><a href=\"#博客现在的规划\" class=\"headerlink\" title=\"博客现在的规划\"></a>博客现在的规划</h1><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> js函数式编程学习</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> Lodash-分析学习<blockquote>\n<p>上面第一个进行的有点困难现在.</p>\n</blockquote>\n</li>\n</ul>\n<p>2019-03-14: </p>\n<ol>\n<li>Promise模仿,手写了一遍实现</li>\n<li>准备完整的搞一遍 js中的 this的问题</li>\n</ol>\n<p>2019-03-18:</p>\n<ol>\n<li>http 缓存知识复习</li>\n<li>promise 再现</li>\n</ol>\n<p>2019-03-29</p>\n<blockquote>\n<p>首先，上述的学习任务基本完成，当然规划那两个是长期任务。</p>\n</blockquote>\n<p>去年七月份就刷了这篇(博客)[<a href=\"http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。\" target=\"_blank\" rel=\"noopener\">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html]，当时看完之后基本上没有什么理解的内容，半年之后重新回顾，很多知识已经有所熟悉，但是还是有很多根本没有听说过，在此记录。</a></p>\n<p>浏览器的机制，到如何打开一个tab页。（涉及到进程和线程）</p>\n<p>其中有很多后台的和服务器端的内容，暂时不作为我的学习内容，在这里只对其中出现的前端的内容，而我都不是很了解的内容做一个to-learn-list。</p>\n<p>简单层与复合层，都是什么，这个完全不了解。(已经做了总结)<br>(看这个)[<a href=\"https://segmentfault.com/a/1190000012925872#articleHeader16]\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012925872#articleHeader16]</a></p>\n<p>没事多看看这篇博客，对其中不太了解的知识体系做一个梳理。</p>\n"},{"title":"计算机基础知识补充","date":"2019-03-07T01:55:21.000Z","_content":"\n> 自己好歹也是软件对口专业毕业的, 好多计算机的基础知识还是来补充一下吧\n\n## 什么是镜像\n\n来自百度百科的解释: 镜像是一种冗余的类型, 一个磁盘的数据在另一个磁盘完全相同的存在的副本就是一个镜像.\n总之镜像也是一种文件类型.\n\n## 32位机器和64位机器的差别\n\n首先这个位数是说的 CPU的设计, 64位的设计就会有: 更大的寻址空间,  更多可用的寄存器, 更多可用的CPU指令。\n\n下面是windows官网对于64位系统的解释\n> 若要安装 64 位版本的 Windows，你需要能够运行 64 位版本的 Windows 的 CPU。当你在计算机上安装了大量随机存取内存 (RAM)（通常为 4 GB RAM 或更多）时，使用 64 位操作系统的好处最明显。在此类情况下，由于 64 位操作系统可以比 32 位操作系统更高效地处理大量内存，因此在同时运行多个程序并在它们之间频繁切换时，64 位系统响应速度更快。\n\n## CPU & GPU\n\ncpu的全称是 central processing unit\n\ngpu的全称是 graphics processing unit\n\n在 NVIDIA 的官网上看到一句描述： CPU常常被认为是电脑的大脑，但是这个大脑被电脑的另一个原件——GPU增强，我们认为这是电脑的灵魂。（翻译的有点水）\n\n知乎上的一句话对差异的解释：[link](https://www.zhihu.com/question/19903344/answer/96081382)\n\nCPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。\n\n## 进程(process)与线程(thread)\n\n> 大二学机组的时候，明明记得这么清楚了。然而，现在突然看到竟然会有一阵恍惚..\n\n把CPU比做一个工厂，如果是单核CPU，那么这个的意思就是，一次只能一个运行一个车间，一个车间就是一个进程(process)\n\n车间里会有很多协同工作的工人，这些工人就看做是线程(thread)。在一个进程中就可以有多个线程。\n同时一个进程中间的内存是共享的，但是是不能同时使用的。\n\n### 浏览器最小宽度\n\n窗口缩小最小宽度是400px(来自Google)\n\n<details open>\n<summary>Want to ruin the surprise?</summary>\n<br>\nWell, you asked for it!\n<a href='www.baidu.com'>fds\n\n<image src='./io'>\n","source":"_posts/计算机基础知识补充.md","raw":"---\ntitle: 计算机基础知识补充\ndate: 2019-03-07 09:55:21\ntags: 基础\n---\n\n> 自己好歹也是软件对口专业毕业的, 好多计算机的基础知识还是来补充一下吧\n\n## 什么是镜像\n\n来自百度百科的解释: 镜像是一种冗余的类型, 一个磁盘的数据在另一个磁盘完全相同的存在的副本就是一个镜像.\n总之镜像也是一种文件类型.\n\n## 32位机器和64位机器的差别\n\n首先这个位数是说的 CPU的设计, 64位的设计就会有: 更大的寻址空间,  更多可用的寄存器, 更多可用的CPU指令。\n\n下面是windows官网对于64位系统的解释\n> 若要安装 64 位版本的 Windows，你需要能够运行 64 位版本的 Windows 的 CPU。当你在计算机上安装了大量随机存取内存 (RAM)（通常为 4 GB RAM 或更多）时，使用 64 位操作系统的好处最明显。在此类情况下，由于 64 位操作系统可以比 32 位操作系统更高效地处理大量内存，因此在同时运行多个程序并在它们之间频繁切换时，64 位系统响应速度更快。\n\n## CPU & GPU\n\ncpu的全称是 central processing unit\n\ngpu的全称是 graphics processing unit\n\n在 NVIDIA 的官网上看到一句描述： CPU常常被认为是电脑的大脑，但是这个大脑被电脑的另一个原件——GPU增强，我们认为这是电脑的灵魂。（翻译的有点水）\n\n知乎上的一句话对差异的解释：[link](https://www.zhihu.com/question/19903344/answer/96081382)\n\nCPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。\n\n## 进程(process)与线程(thread)\n\n> 大二学机组的时候，明明记得这么清楚了。然而，现在突然看到竟然会有一阵恍惚..\n\n把CPU比做一个工厂，如果是单核CPU，那么这个的意思就是，一次只能一个运行一个车间，一个车间就是一个进程(process)\n\n车间里会有很多协同工作的工人，这些工人就看做是线程(thread)。在一个进程中就可以有多个线程。\n同时一个进程中间的内存是共享的，但是是不能同时使用的。\n\n### 浏览器最小宽度\n\n窗口缩小最小宽度是400px(来自Google)\n\n<details open>\n<summary>Want to ruin the surprise?</summary>\n<br>\nWell, you asked for it!\n<a href='www.baidu.com'>fds\n\n<image src='./io'>\n","slug":"计算机基础知识补充","published":1,"updated":"2019-04-21T02:21:22.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuqb3fnv001u7dxq9zj47jix","content":"<blockquote>\n<p>自己好歹也是软件对口专业毕业的, 好多计算机的基础知识还是来补充一下吧</p>\n</blockquote>\n<h2 id=\"什么是镜像\"><a href=\"#什么是镜像\" class=\"headerlink\" title=\"什么是镜像\"></a>什么是镜像</h2><p>来自百度百科的解释: 镜像是一种冗余的类型, 一个磁盘的数据在另一个磁盘完全相同的存在的副本就是一个镜像.<br>总之镜像也是一种文件类型.</p>\n<h2 id=\"32位机器和64位机器的差别\"><a href=\"#32位机器和64位机器的差别\" class=\"headerlink\" title=\"32位机器和64位机器的差别\"></a>32位机器和64位机器的差别</h2><p>首先这个位数是说的 CPU的设计, 64位的设计就会有: 更大的寻址空间,  更多可用的寄存器, 更多可用的CPU指令。</p>\n<p>下面是windows官网对于64位系统的解释</p>\n<blockquote>\n<p>若要安装 64 位版本的 Windows，你需要能够运行 64 位版本的 Windows 的 CPU。当你在计算机上安装了大量随机存取内存 (RAM)（通常为 4 GB RAM 或更多）时，使用 64 位操作系统的好处最明显。在此类情况下，由于 64 位操作系统可以比 32 位操作系统更高效地处理大量内存，因此在同时运行多个程序并在它们之间频繁切换时，64 位系统响应速度更快。</p>\n</blockquote>\n<h2 id=\"CPU-amp-GPU\"><a href=\"#CPU-amp-GPU\" class=\"headerlink\" title=\"CPU &amp; GPU\"></a>CPU &amp; GPU</h2><p>cpu的全称是 central processing unit</p>\n<p>gpu的全称是 graphics processing unit</p>\n<p>在 NVIDIA 的官网上看到一句描述： CPU常常被认为是电脑的大脑，但是这个大脑被电脑的另一个原件——GPU增强，我们认为这是电脑的灵魂。（翻译的有点水）</p>\n<p>知乎上的一句话对差异的解释：<a href=\"https://www.zhihu.com/question/19903344/answer/96081382\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<p>CPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。</p>\n<h2 id=\"进程-process-与线程-thread\"><a href=\"#进程-process-与线程-thread\" class=\"headerlink\" title=\"进程(process)与线程(thread)\"></a>进程(process)与线程(thread)</h2><blockquote>\n<p>大二学机组的时候，明明记得这么清楚了。然而，现在突然看到竟然会有一阵恍惚..</p>\n</blockquote>\n<p>把CPU比做一个工厂，如果是单核CPU，那么这个的意思就是，一次只能一个运行一个车间，一个车间就是一个进程(process)</p>\n<p>车间里会有很多协同工作的工人，这些工人就看做是线程(thread)。在一个进程中就可以有多个线程。<br>同时一个进程中间的内存是共享的，但是是不能同时使用的。</p>\n<h3 id=\"浏览器最小宽度\"><a href=\"#浏览器最小宽度\" class=\"headerlink\" title=\"浏览器最小宽度\"></a>浏览器最小宽度</h3><p>窗口缩小最小宽度是400px(来自Google)</p>\n<p><details open></details></p>\n<p><summary>Want to ruin the surprise?</summary><br><br><br>Well, you asked for it!<br><a href=\"www.baidu.com\">fds</a></p>\n<image src=\"./io\">\n</image>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>自己好歹也是软件对口专业毕业的, 好多计算机的基础知识还是来补充一下吧</p>\n</blockquote>\n<h2 id=\"什么是镜像\"><a href=\"#什么是镜像\" class=\"headerlink\" title=\"什么是镜像\"></a>什么是镜像</h2><p>来自百度百科的解释: 镜像是一种冗余的类型, 一个磁盘的数据在另一个磁盘完全相同的存在的副本就是一个镜像.<br>总之镜像也是一种文件类型.</p>\n<h2 id=\"32位机器和64位机器的差别\"><a href=\"#32位机器和64位机器的差别\" class=\"headerlink\" title=\"32位机器和64位机器的差别\"></a>32位机器和64位机器的差别</h2><p>首先这个位数是说的 CPU的设计, 64位的设计就会有: 更大的寻址空间,  更多可用的寄存器, 更多可用的CPU指令。</p>\n<p>下面是windows官网对于64位系统的解释</p>\n<blockquote>\n<p>若要安装 64 位版本的 Windows，你需要能够运行 64 位版本的 Windows 的 CPU。当你在计算机上安装了大量随机存取内存 (RAM)（通常为 4 GB RAM 或更多）时，使用 64 位操作系统的好处最明显。在此类情况下，由于 64 位操作系统可以比 32 位操作系统更高效地处理大量内存，因此在同时运行多个程序并在它们之间频繁切换时，64 位系统响应速度更快。</p>\n</blockquote>\n<h2 id=\"CPU-amp-GPU\"><a href=\"#CPU-amp-GPU\" class=\"headerlink\" title=\"CPU &amp; GPU\"></a>CPU &amp; GPU</h2><p>cpu的全称是 central processing unit</p>\n<p>gpu的全称是 graphics processing unit</p>\n<p>在 NVIDIA 的官网上看到一句描述： CPU常常被认为是电脑的大脑，但是这个大脑被电脑的另一个原件——GPU增强，我们认为这是电脑的灵魂。（翻译的有点水）</p>\n<p>知乎上的一句话对差异的解释：<a href=\"https://www.zhihu.com/question/19903344/answer/96081382\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<p>CPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。</p>\n<h2 id=\"进程-process-与线程-thread\"><a href=\"#进程-process-与线程-thread\" class=\"headerlink\" title=\"进程(process)与线程(thread)\"></a>进程(process)与线程(thread)</h2><blockquote>\n<p>大二学机组的时候，明明记得这么清楚了。然而，现在突然看到竟然会有一阵恍惚..</p>\n</blockquote>\n<p>把CPU比做一个工厂，如果是单核CPU，那么这个的意思就是，一次只能一个运行一个车间，一个车间就是一个进程(process)</p>\n<p>车间里会有很多协同工作的工人，这些工人就看做是线程(thread)。在一个进程中就可以有多个线程。<br>同时一个进程中间的内存是共享的，但是是不能同时使用的。</p>\n<h3 id=\"浏览器最小宽度\"><a href=\"#浏览器最小宽度\" class=\"headerlink\" title=\"浏览器最小宽度\"></a>浏览器最小宽度</h3><p>窗口缩小最小宽度是400px(来自Google)</p>\n<p><details open></details></p>\n<p><summary>Want to ruin the surprise?</summary><br><br><br>Well, you asked for it!<br><a href=\"www.baidu.com\">fds</a></p>\n<image src=\"./io\">\n</image>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjuqb3fho00007dxqrozui855","category_id":"cjuqb3fhy00027dxqjhqdk698","_id":"cjuqb3fia000b7dxq5ip0wct1"},{"post_id":"cjuqb3fht00017dxqvvr3nc5e","category_id":"cjuqb3fi600077dxq628myzek","_id":"cjuqb3fie000h7dxqa5uho9ej"},{"post_id":"cjuqb3fhy00037dxq5klan254","category_id":"cjuqb3fia000c7dxqxvgolpqm","_id":"cjuqb3fil000n7dxqc7rttl1b"},{"post_id":"cjuqb3fi200067dxqtm859u4l","category_id":"cjuqb3fi600077dxq628myzek","_id":"cjuqb3fiq000s7dxq71iqo5ny"},{"post_id":"cjuqb3fim000o7dxq16lnac5q","category_id":"cjuqb3fia000c7dxqxvgolpqm","_id":"cjuqb3fit000w7dxqtmsfljpu"},{"post_id":"cjuqb3fiy00157dxq6h3evri0","category_id":"cjuqb3fhy00027dxqjhqdk698","_id":"cjuqb3fj7001b7dxqt03996ij"},{"post_id":"cjuqb3fiv00107dxqrt02yj80","category_id":"cjuqb3fiy00147dxqtspz17gl","_id":"cjuqb3fj9001f7dxq56nitcpq"}],"PostTag":[{"post_id":"cjuqb3fhy00037dxq5klan254","tag_id":"cjuqb3fi200057dxqvpdtqy5y","_id":"cjuqb3fia000d7dxqc5i54ljo"},{"post_id":"cjuqb3fi000047dxq7jyy6xvw","tag_id":"cjuqb3fi9000a7dxqcittrlmw","_id":"cjuqb3fii000k7dxq1ap2j1i5"},{"post_id":"cjuqb3fi200067dxqtm859u4l","tag_id":"cjuqb3fie000g7dxqcjv425ef","_id":"cjuqb3fin000p7dxq4osa740x"},{"post_id":"cjuqb3fi600087dxqp9v6dv96","tag_id":"cjuqb3fi9000a7dxqcittrlmw","_id":"cjuqb3fis000u7dxq3rjknlgc"},{"post_id":"cjuqb3fi800097dxqi204gqun","tag_id":"cjuqb3fie000g7dxqcjv425ef","_id":"cjuqb3fiv000z7dxq4buf3lgl"},{"post_id":"cjuqb3fia000e7dxqz5nooz9x","tag_id":"cjuqb3fie000g7dxqcjv425ef","_id":"cjuqb3fiy00137dxqkk9sv6im"},{"post_id":"cjuqb3fio000q7dxq6tq5pq0i","tag_id":"cjuqb3fix00117dxqfetrzayc","_id":"cjuqb3fj300187dxqzfrgved2"},{"post_id":"cjuqb3fj300197dxq3y28djlf","tag_id":"cjuqb3fi200057dxqvpdtqy5y","_id":"cjuqb3fj7001d7dxqubr6dbmk"},{"post_id":"cjuqb3fiu000y7dxq5syzr7ep","tag_id":"cjuqb3fiz00167dxqnoi4r0p7","_id":"cjuqb3fj9001g7dxqar3c4rdo"},{"post_id":"cjuqb3fiv00107dxqrt02yj80","tag_id":"cjuqb3fj7001c7dxqqdri8tu1","_id":"cjuqb3fjb001k7dxq2xp2cxo8"},{"post_id":"cjuqb3fj9001h7dxq4cppvnf4","tag_id":"cjuqb3fi9000a7dxqcittrlmw","_id":"cjuqb3fjd001m7dxqpu6wvq3t"},{"post_id":"cjuqb3fj6001a7dxq8qrls9sp","tag_id":"cjuqb3fja001i7dxqwgr5gski","_id":"cjuqb3fjh001p7dxqf9m27uok"},{"post_id":"cjuqb3fjb001l7dxqlhu3y2ts","tag_id":"cjuqb3fie000g7dxqcjv425ef","_id":"cjuqb3fji001r7dxqwrh4hca1"},{"post_id":"cjuqb3fje001o7dxqs6fwx8lb","tag_id":"cjuqb3fie000g7dxqcjv425ef","_id":"cjuqb3fji001s7dxqnn8q309h"},{"post_id":"cjuqb3fja001j7dxq20mip7wv","tag_id":"cjuqb3fje001n7dxq1z0w6dmf","_id":"cjuqb3fjk001t7dxqjzwq4p4d"},{"post_id":"cjuqb3fnv001u7dxq9zj47jix","tag_id":"cjuqb3fnz001w7dxqsow0s4j2","_id":"cjuqb3fnz001x7dxqjx8v6w5t"}],"Tag":[{"name":"总结","_id":"cjuqb3fi200057dxqvpdtqy5y"},{"name":"css","_id":"cjuqb3fi9000a7dxqcittrlmw"},{"name":"js","_id":"cjuqb3fie000g7dxqcjv425ef"},{"name":"http","_id":"cjuqb3fix00117dxqfetrzayc"},{"name":"JS","_id":"cjuqb3fiz00167dxqnoi4r0p7"},{"name":"杂文","_id":"cjuqb3fj7001c7dxqqdri8tu1"},{"name":"算法","_id":"cjuqb3fja001i7dxqwgr5gski"},{"name":"正则","_id":"cjuqb3fje001n7dxq1z0w6dmf"},{"name":"基础","_id":"cjuqb3fnz001w7dxqsow0s4j2"}]}}