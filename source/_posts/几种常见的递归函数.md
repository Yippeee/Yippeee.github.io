---
title: 几种常见的递归函数
date: 2019-03-25 15:53:22
tags: 算法
---
> 本文的主题是，常见的几种递归函数，以及如何用非递归的方式实现

## 树形结构对象的遍历

完成一个函数，作用是返回对象的最大深度（其实就是树的深度）

首先的思路，是从DP问题开始。位于N位置的最大深度，就是位于N-1位置的最大深度 + 1， 且如果没有子项了，深度就为1

一个递归的原型就形成了

1. 相连项目之间的关系
2. 递归退出的条件

所以递归的套路模板一般形如：
```js
if (基本情况) {
    直接返回，退出函数
} else {
    继续调用(新的参数)
}
```

那么，按照上面的描述，写出这个函数

```js
function traverse(obj) {
    if (obj === null) return 0
    // 判断是不是单层对象
    const getSons = (obj) => {
        return getObjChildren(obj).every((item) => {
            return Object.prototype.toString.call(item) !== '[object Object]' // 对象类型判断
        })
    }
    if (getSons(obj)) return 1
    let max = 0
    getObjChildren(obj).forEach(item => {
        max = traverse(item) > max ? traverse(item) : max
    })
    return max + 1
}
// 获取对象的直接儿子元素，返回数组
function getObjChildren(obj) {
    let result = []
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const element = obj[key];
            result.push(element)
        }
    }
    return result
}
```

使用递归就是这么做的，如果不能使用递归呢。

我们将思维转化一下，不要江化。

这样的每一个去遍历，做了很多的无用功，如果我们直接以层为单位，这一层只要有子元素就把层数加一，知道最后一层所有的元素都没有子元素了，那么最后不就是树的层数了嘛。

```js
function layerTraverse(obj) {
    if (obj === null) return 0
    let layer = 1
    let queues = [] // 用于存放一层的所有数据
    queues = getObjChildren(obj)
    // 如何通过两个while 完成对所有节点的遍历
    // 第一个while 作为外圈， 判断下一层是否还有数据
    // 第二个while 用来判断当层的数据是否全部都执行完（将子元素 push进入 queue
    while (queues.length > 0) {
        layer++
        let length = queues.length
        while (length > 0) {
            let item = queues.shift()
            queues.push(...getObjChildren(item))
            length--
        }
    }
    return layer
}
```
同时这还利用了堆的思想。  

## 阶乘、Fibonacci函数以及 HanoiTower(汉诺塔)

明确这三个的定义：

阶乘就是 6! = 6 x 5 x 4 x 3 x 2 x 1

Fibonacci 函数就是 每一个数都是前两个数之和，第一个和第二个数都是1

HanoiTower(汉诺塔)：
有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：

1.  每次只能移动一个圆盘；
2.  大盘不能叠在小盘上面。

提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。

问：如何移？最少要移动多少次？

### Fibonacci函数

```js
function Fibonacci(n){
    if (n === 1 || n === 2) return 1
    return Fibonacci(n - 1) + Fibonacci(n - 2)
}

```
这就是最简单的实现，这个实现基本上就很垃圾，因为运行一下就知道了，耗费的时间非常大。

这里的解决办法很多，例如建一个缓存，每次先从缓存里面拿值，如果没有在调用，之后再更新缓存。

我们不适用这些办法，我这里想做的是用循环代替递归。

也就是适用DP的思想，只保存当前运算时需要的数据。

```js
function Fibonacci2(n) {
    if (n === 1 || n === 2) return 1
    let result = 1, 
    a1 = 1
    for (let i = 3; i <= n; i++){
        result = result + a1
        a1 = result - a1
    }    
}
```
上面这种写法只用了一个a1， 是为了节省变量，如果用两个变量，一个代表前一个的值，另一个代表前两个的值，就会更容易看懂。


### 阶乘

```js
function factorial(n) {
    if (n == 1) return 1
    return factorial(n - 1) * n
}
```

```js
function factorial2(n){
    if (n===1) return 1
    let result = 1
    for (let i = 2; i <= n; i++){
        result = i * result
    }
    return result
}
```

### HanoiTower(汉诺塔)

![汉诺塔](https://upload.wikimedia.org/wikipedia/commons/0/07/Tower_of_Hanoi.jpeg)

思路就是如果得把N个全都移动C柱，那么分解一下，就是把N-1个移动BY柱，把第N个移到C柱，再把N-1个从by柱移到C柱去

```js
function HanoiTower(n, from, by, to) {
    if (n === 1) {
        move(1, from, to)
    } else {
        HanoiTower(n - 1, from, by, to)
        move(n, from, to)
        HanoiTower(n - 1, to, by, from)
    }
}
function move(n, from, to, index) {
    console.log(`移动第${n}个从${from} ----> ${to}`)
}
```

## 尾调用

> 除了我们手动的去优化递归，ES6中本身也有对递归优化的方法。那就是尾调用。

尾调用一定是在函数的最后一步，返回了一个没有进行任何操作的函数。

只有这样，才能完全的丢弃外层函数的调用栈，只保留内部返回函数的调用记录。

这是对Fibonacci函数的尾递归改造：
```js
function Fibonacci3(n, val1, val2) {
    if (n === 1) return val2
    return Fibonacci3(n - 1, val1 + val2, val1)
}
```

再对阶乘函数进行改造：
```js
function factorial(n, total){
    if (n === 1) return total
    return factorial(n - 1, n * total)
}
```

看以上两个尾递归的函数，我们在使用的时候，都得显试的传入 val1 或者 total 这种开始的值。

会让函数的意义不容易懂。

这里有两种办法，一种是**柯里化**，另一种是**参数默认值**

### 柯里化

需要在外圈再包一个函数，如果是Fibonacci 函数的话。

```js
function currying(fn, n){
    return function(val) {
        fn.call(this, val, n)
    }
}

const Fibonacci3_1 = currying(Fibonacci3, 1)
```

### 函数默认值

```js
function Fibonacci3(n, val1 = 1, val2 = 1) {
    if (n === 1) return val2
    return Fibonacci3(n - 1, val1 + val2, val1)
}
```