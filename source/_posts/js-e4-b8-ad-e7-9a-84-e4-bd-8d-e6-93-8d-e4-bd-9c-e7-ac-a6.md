---
title: JS中的位操作符
tags:
  - 算法
url: 61.html
id: 61
categories:
  - 笔记
date: 2019-01-07 11:39:05
---

> 位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.

刚刚看到位操作的英语 bit operation 在看mdn中的Polyfill中,常常可以看到这样的做法: length = length >>> 0 google一下, 先总结这样使用的作用 **1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分** 为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: [位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6) 说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算

 名称 | 操作 | 举例
 ------------ | ------------- | ------------
<<(左移位)	 | 将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. **左边移出的几位被丢弃.右边多出的空位由0补齐** | 9<<2产生36，因为1001移位2比特向左变为100100，它是36。
\>>(带符号右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由原值的最左边数字补齐**. | 9>>2产生2，因为1001移位2位向右变为10，其是2。同样，-9>>2产生-3，由于符号被保留。
\>>>(补零右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由0补齐**. | 19>>>2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。

左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. 例如 19 << 2 -> 76 -19 << 2 -> 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 >> 2 -> 4 10010 变成了 100 -> 4 -19 >> 4 -> -5 -19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -> -5 两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 >>> 2 -> 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 >>> 2 -> 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0

* * *

接下来再对其他的位操作对理解 先看一道题, [![](https://i.loli.net/2019/01/07/5c32efafcf701.png)](https://i.loli.net/2019/01/07/5c32efafcf701.png) 大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96),在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -> 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a & b >> 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a & b << 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.
```js
function tc_add (a, b) {
    while (b != 0) {
        let _a = a ^ b
        let _b = (a & b) << 1
        a = _a
        b = _b
        console.log('a:', a)
        console.log('b:', b)
    }
    return a
}
console.log(tc_add(9, 5))
// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算
```

再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身

> 这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题

题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 看这个题目, 想法有没有和这个交换变量的题的思想一模一样... 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..