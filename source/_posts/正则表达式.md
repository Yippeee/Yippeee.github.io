---
title: 正则表达式
date: 2019-03-12 10:45:22
tags: 正则
---

> 关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.

## JS正则中的捕获元和非捕获元
字符 | 描述
---- | ----
(pattern) | 匹配 pattern ,并且获取
(?:pattern) | 匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组
(?=pattern) | 正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)
(?!pattern) | 正向预查的否定版

这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)

>题外话,`toLocaleSting('en')`的方式也可以

对比三种正则的获取情况
```js
var reg1 = /\d{1,3}(\d{3})+$/
var reg2 = /\d{1,3}(?:(\d{3})+)/g
var reg3 = /\d{1,3}(?=(\d{3})+$)/g
var num = '1234567890'
num.replace(reg1, function (p, $1, $2) {
    console.log('p: ', p); // 1234567890
    console.log('$1: ', $1); // 890
    console.log('$2: ', $2); // 0
})
num.replace(reg2, function (p, $1, $2) {
    console.log('p: ', p); // 1234567890
    console.log('$1: ', $1); // 890
    console.log('$2: ', $2); // 0
})
num.replace(reg3, function (p, $1, $2) {
    console.log('p: ', p);
    console.log('$1: ', $1);
    console.log('$2: ', $2);
})
```

首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.

然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.
`reg2 = /(\d{1,3})(?:(\d{3})+?)/g`

```js
num.replace(reg2, function (p, $1, $2) {
    console.log('p: ', p); // 123456   7890
    console.log('$1: ', $1); // 123     7
    console.log('$2: ', $2); // 456   890
})
```
这时候会进行两轮,但是因为`?:`非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.
这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.

第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.
因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.
同时P就是我们需要的数值的前面的部分,只需要 `return p + ','`就可以了

### 实用情况

#### 验证密码的复杂性和位数
要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号
`/(?=.{6,})(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&&*()_+])/`

#### 验证邮箱

`/^[0-9a-zA-Z\-_]+@[0-9a-zA-Z\-_]+[\.0-9a-zA-Z\-_]+$/`

#### 匹配汉字

`[\u4e00-\u9fa5]`

#### 重学js中的正则表达式

> 之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。

不要去看什么教程，走官网的 [介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n)

1. 正则基本API补充

RegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项

RegExp.prototype.source 获取去掉正则两侧的 `/` 以及标志字符的字符串

2. 正则的工具使用

[链接](https://regex101.com/)
这个网站分析的很不错，比一些什么可视化网站好用的多。

3. 案例分析

> 这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.
> `/\{\{((?:.|\n)+?)\}\}/` & `^<((?:[a-zA-Z_][\w\-\.]*\:)?[a-zA-Z_][\w\-\.]*)`

```js
function isPrimeNum2(num){
    return !/^.?$|^(..+?)\1+$/.test(Array(num + 1).join('1'))
}
```
看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下...

update：2019-04-09

> 自我解答来了..

先把正则之外的部分解决一下，`Array(num + 1).join('1')` 返回的是由1组成的num个的字符串。 之所以需要加一，是因为这里用的是join，个数会被减一。

然后才是重头戏，正则部分。

正则分成了两部分，前面的 `^.?$` 是对是否有内容的一个检查，不做多余的说明。

后面的部分才是对真正的判断，这里我们只能判断是否是非素数，然后求反。

`^(..+?)\1+$`, 是对非素数的判断。

非素数，就是除了1之外还有其他因子的数。

这里，我们就来构造这样的情况。

`(..+?)` 这里是一个非贪婪的捕获，会先用 `(..)` 的情况来进行匹配，后面是`\1+$`对第一次捕获分组的帅选，如果满足条件，容易发现其实在就满足了被2整除的条件，那么就不是质数了。如果2没有匹配到，因为是`..+`会继续用3,4..etc

这样，被3,4等等的情况，就都考虑进去了，就满足了对一个非素数的判断。


>TODO: 有限状态机，在正则中对倍数的判断的使用。

这块有点复杂，有空闲时间再来研究吧。

## ES9 中正则表达式的更新

### 支持分组命名

使用 `?<name>` 放于 `(` 后面，对分组进行命名。
例如：
```js
const str = '2019-04-11'
const reg = /(?<year>....)-(?<month>..)-(?<day>..)/
const group = reg.exec(str).groups
let {year, month, day} = group
```

### 反向断言

之前的版本js中的正则是不支持反向断言的，不过现在支持了。

```js
const regex = /(?<=2019)-(..)-(..)/
```

只会匹配2019后面的月份和日期。
*注意一点: 反向断言中不能使用捕获组* 就是这样使用是不行的： `(?<=\1)(..)`

### dotAll

这个属性是针对于 `.` 匹配符的，是使用 dotAll 的情况下，`.` 实现了真正的 all 匹配，换行(\n)，回车(\r)， 行分隔，段分隔，都可以匹配。
使用的方式，是使用新增的修饰符 /s

其实完全的 all 匹配，还得加上 /u 修饰符，考虑Unicode的情况

### Unicode 转义

`var regex = new RegExp('\u{61}', 'u');`

## 反向非贪婪匹配

一个这样的字符串
```js
const str = "<option value='2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'>大连用户组</option>"
```
要找出 大连用户组 的标签的value是多少。
本来觉得很简单，一个普通的正则就搞定了， `value\='(.*?)'>大连用户组`.

然而，匹配到的结果是 

`2'>default user group</option><option value='8'>默认用户组</option><option value='11'>OTT默认用户组</option><option value='3418'>黑名单用户组</option><option value='3433'>zhonggp测试用户组</option><option value='14063'>yangcongtest</option><option value='14106'>portal_test</option><option value='14126'`

我就蒙蔽了.我不是用了?了啊，应该是非贪婪的啊，怎么会这样呢。

后面查阅了资料才发现，贪婪是对应的正向的匹配，对于一个正向的匹配没有第一次匹配到就放手的情况。。

既然是反向的，我们的思维也反向一下吧。

在前面加一个贪婪的匹配，那后面的不就是非贪婪的了嘛。

`.*value\='(.*?)'>大连用户组` 这样就bingo啦。
