---
title: 正则表达式
date: 2019-03-12 10:45:22
tags: 正则
---

> 关于正则表达式也使用过很久了,但是总是会有点遗漏和本身就没有掌握的地方.在此做记录.

## JS正则中的捕获元和非捕获元
字符 | 描述
---- | ----
(pattern) | 匹配 pattern ,并且获取
(?:pattern) | 匹配pattern, 但是不捕获结果, 就是在分组中不考虑pattern的分组
(?=pattern) | 正向预查,也不捕获结果,同时还不获取pattern的结果,只是做一个预查(就是在P中, 都不会包含pattern匹配的结果,这也是?=和?:的差别所在)
(?!pattern) | 正向预查的否定版

这里用一道面试题作为例子: 将数值转化成千分位(00,000,000的形式)

>题外话,`toLocaleSting('en')`的方式也可以

对比三种正则的获取情况
```js
var reg1 = /\d{1,3}(\d{3})+$/
var reg2 = /\d{1,3}(?:(\d{3})+)/g
var reg3 = /\d{1,3}(?=(\d{3})+$)/g
var num = '1234567890'
num.replace(reg1, function (p, $1, $2) {
    console.log('p: ', p); // 1234567890
    console.log('$1: ', $1); // 890
    console.log('$2: ', $2); // 0
})
num.replace(reg2, function (p, $1, $2) {
    console.log('p: ', p); // 1234567890
    console.log('$1: ', $1); // 890
    console.log('$2: ', $2); // 0
})
num.replace(reg3, function (p, $1, $2) {
    console.log('p: ', p);
    console.log('$1: ', $1);
    console.log('$2: ', $2);
})
```

首先看第一种正则的情况,虽然的确这就是最后千分位分割的样式,但是这样我们无法匹配以及获取到我们每次需要的数据,它只能讲整个结果返回出来.

然后是第二种情况,首先说明,我们的匹配符都是用的正则中默认的规则也就是贪婪获取,所以可以看到第二种会和第一种得到一样的情况.如果我们这这种情况下进行优化呢.
`reg2 = /(\d{1,3})(?:(\d{3})+?)/g`

```js
num.replace(reg2, function (p, $1, $2) {
    console.log('p: ', p); // 123456   7890
    console.log('$1: ', $1); // 123     7
    console.log('$2: ', $2); // 456   890
})
```
这时候会进行两轮,但是因为`?:`非捕获元的特性, ?:后面的内容会进行消耗,也就是在P中会有消耗,所以下一轮的时候,会略过被消耗用掉的pattern.
这个时候肯定会说应该在最后加上$啊,是的,这只是为了举这个例而已,即便加上了$造成的结果还是一样的.

第三种情况,当然就是正确的方法了.我们来分析这个为什么可以达到我们的效果.
因为?=不会消耗pattern匹配的内容,所以会保证每个值都会被捕获.同时由于第一次的匹配情况,保证了除了第一次之外的后面每次匹配都是{3}的情况.
同时P就是我们需要的数值的前面的部分,只需要 `return p + ','`就可以了

### 实用情况

#### 验证密码的复杂性和位数
要求:位数大于6,而且包含有字母小写和大写,同时有特殊符号
`/(?=.{6,})(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&&*()_+])/`

#### 验证邮箱

`/^[0-9a-zA-Z\-_]+@[0-9a-zA-Z\-_]+[\.0-9a-zA-Z\-_]+$/`

#### 匹配汉字

`[\u4e00-\u9fa5]`

#### 重学js中的正则表达式

> 之前，自认为对正则的掌握已经有一丢丢的火候了。但是今天阅读了vue中对 template parse 形成 AST 过程中的原码。我哭了。so，重学正则。

不要去看什么教程，走官网的 [介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n)

1. 正则基本API补充

RegExp.$1~$9 可以直接获取当前正则表达式获取到的括号中的匹配项

RegExp.prototype.source 获取去掉正则两侧的 `/` 以及标志字符的字符串
2. 正则的工具使用

[链接](https://regex101.com/)
这个网站分析的很不错，比一些什么可视化网站好用的多。
3. 案例分析
> 这一部分不出意外，将会持续一段时间，将会记录我对其中的正则不断分析和领会的过程.
> `/\{\{((?:.|\n)+?)\}\}/` & `^<((?:[a-zA-Z_][\w\-\.]*\:)?[a-zA-Z_][\w\-\.]*)`

```js
function isPrimeNum2(num){
    return !/^.?$|^(..+?)\1+$/.test(Array(num + 1).join('1'))
}
```
看到一个用正则判断是不是质数的函数，呆了，这是啥玩意。容我细细品味下...