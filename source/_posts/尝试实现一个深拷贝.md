---
title: 尝试实现一个深拷贝
date: 2019-05-16 09:17:41
tags:
---

> 本文旨在尝试实现一个功能考虑完备的深拷贝

什么是深拷贝，什么是浅拷贝，这里就不做多余的赘述了。

## 明确需求

需要实现的深拷贝，需要考虑到的问题有：

1. 复杂的数据类型

2. 性能上的优化，防止内存堆栈溢出

3. 重复引用问题的解决

上面就是实现的函数需要考虑到的功能，开始实现

## 复杂的数据类型

深拷贝本身需要解决的问题，就是对引用类型的内容拷贝，而不是指针拷贝。原有类型的保持当然是毕不可少的。

```js
const getType = x => {
    return x._prop_.constructor
}

function deepClone(source, type = Object){
    let result = new type()
    for (const key in source) {
		if (source.hasOwnProperty(key)) {
			const element = source[key];
			if (typeof element === 'object') { // 这个地方考虑的不够严谨    
				result[key] = deepClone(element, getType(element));
			} else {
				result[key] = element;
			}
		}
	}
	return result;
}
```

通过返回复杂类型的构造函数，来保证类型的一样。

## 性能优化

上面的解决办法使用了递归，如果在层级很深很深的情况下，是会造成爆栈的。

经过测试，上面的方法，大概在10000层的时候，就会产生爆栈的错误了。

为了解决这个问题，我们用while 来代替递归。（这个，在我之前递归的文章中有提及过）

```js
class Node {
	/**
	 * @param  {} prev
	 * @param  {} content
	 */
	constructor(prev, content) {
		this.prev = prev;
		this.content = content;
	}
}

function deepCloneBreadth(source) {
	// 广度优先遍历 使用队列  shift()出队列  push()进队列
	let result = new source.__proto__.constructor();
	let queues = [new Node(result, source)]; // 队列
	while (queues.length > 0) {
		let item = queues.shift();
		const { prev, content } = item;
		for (const key in content) {
			console.log('keyBreadth: ', key);
			if (content.hasOwnProperty(key)) {
				if (typeof content[key] === 'object') {
					prev[key] = new content[key].__proto__.constructor();
					queues.push(new Node(prev[key], content[key]));
				} else {
					prev[key] = content[key];
				}
			}
		}
	}
	return result;
}
```

这个方法其实在时间上没有很大的进步，但是在处理多层级的时候不会导致堆栈溢出，但是还是会很慢。

## 重复引用

有时候会出现这样的情况：

```js
let b = {a : 1}
let obj = {q: b, p: b}
```

这种时候，我们其实希望 obj 中的 q 和 p 应该是同一个引用。

新建一个数组来存储出现的过的引用类型，在每一次循环的时候，得判断这个值之前有没有出现过，出现过就直接用数组中存储的。

这里会有一个问题，这个数组中的值需要有两个属性，一个是用于判断是否出现过，一个是用于返回存储的引用指针。所以这个数组中应该存储的是一个对象。

```js
function deepCloneBreadth(source) {
	// 广度优先遍历 使用队列  shift()出队列  push()进队列
	let result = new source.__proto__.constructor();
	let queues = [new Node(result, source)]; // 队列

	/*======增加部分=======*/
	let objArr = [];
	function findInObjArr(arr, item) {
		for (const iterator of arr) {
			if (iterator.source === item) {
				return iterator.target;
			}
		}
	}
	/*=======增加部分======*/

	while (queues.length > 0) {
		let item = queues.shift();
		const { prev, content } = item;
		for (const key in content) {
			if (content.hasOwnProperty(key)) {
				if (typeof content[key] === 'object') {
					if (findInObjArr(objArr, content[key])) {
						prev[key] = findInObjArr(objArr, content[key]);
						continue;
					}
					prev[key] = new content[key].__proto__.constructor();
					queues.push(new Node(prev[key], content[key]));
					objArr.push({
						target: prev[key],
						source: content[key],
					});
				} else {
					prev[key] = content[key];
				}
			}
		}
	}
	return result;
}
```

同时测试，这样还解决了引用自身的问题。

## 总结

上面的所有的方法，都只是提供的一个参考和一个思路。都有各自使用的场景，在特定的时候使用特定的代码。

当然最后不忘来一手在平常开发中常使用的，简单类型的数组的深拷贝： JSON.parse(JSON.stringify())