---
title: JS中的位操作符
tags: js
url: 61.html
id: 61
categories:
  - 笔记
date: 2019-01-07 11:39:05
---

> 位操作符在数字逻辑课程中,曾经系统的学习过,但是在JS中对应的是什么,往往好像不是很可以一次说的清楚.

刚刚看到位操作的英语 bit operation 

在看mdn中的Polyfill中,常常可以看到这样的做法: length = length >>> 0 google一下, 在使用 >>>0的时候,基本上保证了参数不会为负数,但是可能会为其他类型的数值,这样就会把其他类型的都变成0.作用和~~是一样的.

>这里再吐槽一句js吧.这设计的啥玩意啊,有点太混乱的了.上面的原因都是位操作符会把参数全部转成32位的2进制的补码进行操作,而且对参数没有限制, 所以是非数组的数值,都被当成了0进行的操作.同时还会忽略掉62位浮点型的精度,所以对于数字也只会保留数字的整数部分.

先总结这样使用的作用 **1.把非数字的字符转化成0 2.把数字取大于等于零的整数部分** 

为了整理清楚上述结果产生的原因,我们需要对JS中的位操作符有一个基本的认识: [位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6) 

说一点基础的知识,位操作符是给电脑内存中二进制运算使用的.所以在使用位操作运算的时候,一定得把数字转化成2进制来运算.同时数值在计算机中存储都是用的补码,然后再转回到10进制呈现. 

对于负数的操作,记录一下.  当发现数值的首位是1的时候, 说明此时数为负数. 所以就不能直接转成10进制的数值. 需要取反,然后加一(就是补码操作).然后再把**负数符号加上去**.反之,如果本身首位都是0了,则说明是正数, 直接转成10进制就完事了.

**同时在js中,**

 名称 | 操作 | 举例
 ------------ | ------------- | ------------
<<(左移位)	 | 将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. **左边移出的几位被丢弃.右边多出的空位由0补齐** | 9<<2产生36，因为1001移位2比特向左变为100100，它是36。
\>>(带符号右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由原值的最左边数字补齐**. | 9>>2产生2，因为1001移位2位向右变为10，其是2。同样，-9>>2产生-3，由于符号被保留。
\>>>(补零右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. **左边多出的空位由0补齐**. | 19>>>2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。

左移中,正数和负数的逻辑是一样的,只是符号会不一样而已. 

例如 19 << 2 -> 76 -19 << 2 -> 76 而对于右移,结果就会有所不同,使用带符号右移或者是补零右移的结果会完全不一样 带符号的移动: 19 >> 2 -> 4 10010 变成了 100 -> 4 -19 >> 4 -> -5 

-19的原码: 110011 补码:101101 移位: (注意这个地方需要高位用1补齐) 111011 补码:100101 -> -5 

两点注意事项: 负数在计算移位的使用用的补码移位; 移位中左边的补齐是用的最左边的符号数字(负数的话也就是1)来补齐 对于正数,两种右移的方式是一样的 19 >>> 2 -> 4 而对于负数来说就不一样了,产生的原因则是移动补位的数值不同导致的,在补零右移中,无论正数负数都是用的0来补齐(或者这正是为什么叫做补零右移的原因吧),所以对于正数来说就是一样的结果,而对于负数来说差异就会很大了. -19 >>> 2 -> 1073741819 正是因为补零右移的特性,所以才可以使用这个方法来讲数字强行取整,或者是把非数字转成0

* * *

接下来再对其他的位操作对理解 先看一道题:

[![](https://i.loli.net/2019/01/07/5c32efafcf701.png)](https://i.loli.net/2019/01/07/5c32efafcf701.png) 

大意如下:如何不使用+完成加法 意思很明显了就是适用位操作来完成加法,这个地方就得提到一下异或(XOR),在JS中用^来表示.[异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96),在百科中就可以知道,异或的名称又叫做半加运算,因为它实现的逻辑法则和加法是一样的,只是不进位,所以也叫做不进位加法. 理一下我的思路,有点乱了.a^b得到的是a+b在二进制的情况下没有进位得到的结果 eg. 9 + 5 -> 1001 + 101 1001 ^ 101 = 1100 竟然我们知道了在没有进位的情况下获得的值,那么现在只需要知道哪些地方进位了,再加上不就是加法的最终结果了嘛 什么情况下才会进位呢,当然是都为1的情况啊. 什么? 都为1,这不就是与操作吗,但是还要想到的是,在与操作的时候,获取到的都为1的位置,但是在真实的加法的情况下,进位的数值应该在都是1的左边的位置 所以,将a & b >> 1就可以得到a b相加的情况下,进位的位置了 现在思路有了,那怎么实现这个加法呢. 可以看到在上面思路中, a + b = (a ^ b) + (a & b << 1) 前一个部分是a b不进位的加法的结果,后一部分是进位的数值,也就是说,如果后一部分不为0那么怎么都需要加法. 那么,如果后一部分为0的话,也就是a b不进位的加法正好等于 a+b 的时候,就不需要用到+号了.
```js
function tc_add (a, b) {
    while (b != 0) {
        let _a = a ^ b
        let _b = (a & b) << 1
        a = _a
        b = _b
        console.log('a:', a)
        console.log('b:', b)
    }
    return a
}
console.log(tc_add(9, 5))
// 其实看来就像是一个递归,直到b等于0的时候就完成了加法运算
```

再写一个不用临时变量来交换变量的方法 a = a ^ b b = a ^ b a = a ^ b 并不提倡这么使用,但是可以搞懂一下这个的原理. b = a ^ b ^ b = a ^ 0 = a a = a ^ b ^ a = b ^ 0 = b 就是因为,任何数和0异或还是本身

> 这还真的是巧了,从来没哟这么觉得这个异或有这么多功能,今天本来想做一下这块的记录.结果又看到了一道关于异或的题

题目描述: 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 

看这个题目, 想法有没有和这个交换变量的题的思想一模一样... 你可能会说为啥,两次就是偶数次,一次的就是奇数次. 还记得上面的那个 a ^ b ^ a = b 吧,所以这道题直接把所有的元素异或一道剩下的就是那个只有一次的元素了..

>2019 - 03 - 06 add

### 按位逻辑操作符

>操作数被转换成32位整数，用比特序列（0和1组成）表示。超过32位的数字会被丢弃。例如, 以下具有32位以上的整数将转换为32位整数:

同时 | & 是js中的位比较符号, 也是对其数的二进制进行的位操作.

| 是或, &是与 , ~ 是非 

举一个使用&的栗子,在 js中的 Node的 API - compareDocumentPosition
在这个 API中, 返回值都是二进制

`node.compareDocumentPosition( otherNode ) `

返回值 | 含义
- | -
1 | 不在同一个文档中
2 | otherNode 在 node 之前
4 | otherNode 在 node 之后
8 | otherNode 包含 node
16 |  otherNode 被 node 包含

**注意:这个compare是 other和 node之间的关系**

而且,关系并存的情况下,返回的值是和. 
所以,这个地方就是用到的& 来进行判断了.

`node.compareDocumentPosition( otherNode ) & 4`返回的如果是false,则说明other不在 node 之后,反之则反.

~也是按位操作符,按位取反
对于是数值的情况下, ~x = -(x + 1)

使用情景:
和indexOf 一起使用, ``` if(~str.indexOf(searchStr)) { // 包含} ```

同时还可以使用 ~~ 将操作符转化成32位有符号正数
```js
~~ null // 0
~~ undefined // 0
~~ NaN // 0
~~ {} // 0
~~ true // 1
~~ '' // 0
~~ 'string' // 0
~~ '1' // 1
~~ Number.POSITIVE_INFINITY // 0

~~ 1.2 // 1
~~ -1.2 // -1
~~ 1.6 // 1
~~ -1.6 // -1
~~ (Math.pow(2, 31) - 1) // 2147483647 = 2^31-1
~~ (Math.pow(2, 31)) // -2147483648 = -2^31
~~ (-Math.pow(2, 31)) // -2147483648 = -2^31
~~ (-Math.pow(2, 31) - 1) // 2147483647 = 2^31-1
~~ (Math.pow(2, 32)) // 0
```